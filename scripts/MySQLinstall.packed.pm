#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;
  use strict;
  use warnings;
  package Capture::Tiny;
  # ABSTRACT: Capture STDOUT and STDERR from Perl, XS or external programs
  our $VERSION = '0.28';
  use Carp ();
  use Exporter ();
  use IO::Handle ();
  use File::Spec ();
  use File::Temp qw/tempfile tmpnam/;
  use Scalar::Util qw/reftype blessed/;
  # Get PerlIO or fake it
  BEGIN {
    local $@;
    eval { require PerlIO; PerlIO->can('get_layers') }
      or *PerlIO::get_layers = sub { return () };
  }
  
  #--------------------------------------------------------------------------#
  # create API subroutines and export them
  # [do STDOUT flag, do STDERR flag, do merge flag, do tee flag]
  #--------------------------------------------------------------------------#
  
  my %api = (
    capture         => [1,1,0,0],
    capture_stdout  => [1,0,0,0],
    capture_stderr  => [0,1,0,0],
    capture_merged  => [1,1,1,0],
    tee             => [1,1,0,1],
    tee_stdout      => [1,0,0,1],
    tee_stderr      => [0,1,0,1],
    tee_merged      => [1,1,1,1],
  );
  
  for my $sub ( keys %api ) {
    my $args = join q{, }, @{$api{$sub}};
    eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"; ## no critic
  }
  
  our @ISA = qw/Exporter/;
  our @EXPORT_OK = keys %api;
  our %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  
  #--------------------------------------------------------------------------#
  # constants and fixtures
  #--------------------------------------------------------------------------#
  
  my $IS_WIN32 = $^O eq 'MSWin32';
  
  ##our $DEBUG = $ENV{PERL_CAPTURE_TINY_DEBUG};
  ##
  ##my $DEBUGFH;
  ##open $DEBUGFH, "> DEBUG" if $DEBUG;
  ##
  ##*_debug = $DEBUG ? sub(@) { print {$DEBUGFH} @_ } : sub(){0};
  
  our $TIMEOUT = 30;
  
  #--------------------------------------------------------------------------#
  # command to tee output -- the argument is a filename that must
  # be opened to signal that the process is ready to receive input.
  # This is annoying, but seems to be the best that can be done
  # as a simple, portable IPC technique
  #--------------------------------------------------------------------------#
  my @cmd = ($^X, '-C0', '-e', <<'HERE');
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
  
  #--------------------------------------------------------------------------#
  # filehandle manipulation
  #--------------------------------------------------------------------------#
  
  sub _relayer {
    my ($fh, $layers) = @_;
    # _debug("# requested layers (@{$layers}) for @{[fileno $fh]}\n");
    my %seen = ( unix => 1, perlio => 1 ); # filter these out
    my @unique = grep { !$seen{$_}++ } @$layers;
    # _debug("# applying unique layers (@unique) to @{[fileno $fh]}\n");
    binmode($fh, join(":", ":raw", @unique));
  }
  
  sub _name {
    my $glob = shift;
    no strict 'refs'; ## no critic
    return *{$glob}{NAME};
  }
  
  sub _open {
    open $_[0], $_[1] or Carp::confess "Error from open(" . join(q{, }, @_) . "): $!";
    # _debug( "# open " . join( ", " , map { defined $_ ? _name($_) : 'undef' } @_ ) . " as " . fileno( $_[0] ) . "\n" );
  }
  
  sub _close {
    # _debug( "# closing " . ( defined $_[0] ? _name($_[0]) : 'undef' )  . " on " . fileno( $_[0] ) . "\n" );
    close $_[0] or Carp::confess "Error from close(" . join(q{, }, @_) . "): $!";
  }
  
  my %dup; # cache this so STDIN stays fd0
  my %proxy_count;
  sub _proxy_std {
    my %proxies;
    if ( ! defined fileno STDIN ) {
      $proxy_count{stdin}++;
      if (defined $dup{stdin}) {
        _open \*STDIN, "<&=" . fileno($dup{stdin});
        # _debug( "# restored proxy STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
      }
      else {
        _open \*STDIN, "<" . File::Spec->devnull;
        # _debug( "# proxied STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
        _open $dup{stdin} = IO::Handle->new, "<&=STDIN";
      }
      $proxies{stdin} = \*STDIN;
      binmode(STDIN, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDOUT ) {
      $proxy_count{stdout}++;
      if (defined $dup{stdout}) {
        _open \*STDOUT, ">&=" . fileno($dup{stdout});
        # _debug( "# restored proxy STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
      }
      else {
        _open \*STDOUT, ">" . File::Spec->devnull;
         # _debug( "# proxied STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
        _open $dup{stdout} = IO::Handle->new, ">&=STDOUT";
      }
      $proxies{stdout} = \*STDOUT;
      binmode(STDOUT, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDERR ) {
      $proxy_count{stderr}++;
      if (defined $dup{stderr}) {
        _open \*STDERR, ">&=" . fileno($dup{stderr});
         # _debug( "# restored proxy STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
      }
      else {
        _open \*STDERR, ">" . File::Spec->devnull;
         # _debug( "# proxied STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
        _open $dup{stderr} = IO::Handle->new, ">&=STDERR";
      }
      $proxies{stderr} = \*STDERR;
      binmode(STDERR, ':utf8') if $] >= 5.008; ## no critic
    }
    return %proxies;
  }
  
  sub _unproxy {
    my (%proxies) = @_;
    # _debug( "# unproxying: " . join(" ", keys %proxies) . "\n" );
    for my $p ( keys %proxies ) {
      $proxy_count{$p}--;
      # _debug( "# unproxied " . uc($p) . " ($proxy_count{$p} left)\n" );
      if ( ! $proxy_count{$p} ) {
        _close $proxies{$p};
        _close $dup{$p} unless $] < 5.008; # 5.6 will have already closed this as dup
        delete $dup{$p};
      }
    }
  }
  
  sub _copy_std {
    my %handles;
    for my $h ( qw/stdout stderr stdin/ ) {
      next if $h eq 'stdin' && ! $IS_WIN32; # WIN32 hangs on tee without STDIN copied
      my $redir = $h eq 'stdin' ? "<&" : ">&";
      _open $handles{$h} = IO::Handle->new(), $redir . uc($h); # ">&STDOUT" or "<&STDIN"
    }
    return \%handles;
  }
  
  # In some cases we open all (prior to forking) and in others we only open
  # the output handles (setting up redirection)
  sub _open_std {
    my ($handles) = @_;
    _open \*STDIN, "<&" . fileno $handles->{stdin} if defined $handles->{stdin};
    _open \*STDOUT, ">&" . fileno $handles->{stdout} if defined $handles->{stdout};
    _open \*STDERR, ">&" . fileno $handles->{stderr} if defined $handles->{stderr};
  }
  
  #--------------------------------------------------------------------------#
  # private subs
  #--------------------------------------------------------------------------#
  
  sub _start_tee {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    # setup pipes
    $stash->{$_}{$which} = IO::Handle->new for qw/tee reader/;
    pipe $stash->{reader}{$which}, $stash->{tee}{$which};
    # _debug( "# pipe for $which\: " .  _name($stash->{tee}{$which}) . " " . fileno( $stash->{tee}{$which} ) . " => " . _name($stash->{reader}{$which}) . " " . fileno( $stash->{reader}{$which}) . "\n" );
    select((select($stash->{tee}{$which}), $|=1)[0]); # autoflush
    # setup desired redirection for parent and child
    $stash->{new}{$which} = $stash->{tee}{$which};
    $stash->{child}{$which} = {
      stdin   => $stash->{reader}{$which},
      stdout  => $stash->{old}{$which},
      stderr  => $stash->{capture}{$which},
    };
    # flag file is used to signal the child is ready
    $stash->{flag_files}{$which} = scalar tmpnam();
    # execute @cmd as a separate process
    if ( $IS_WIN32 ) {
      local $@;
      eval "use Win32API::File qw/CloseHandle GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";
      # _debug( "# Win32API::File loaded\n") unless $@;
      my $os_fhandle = GetOsFHandle( $stash->{tee}{$which} );
      # _debug( "# Couldn't get OS handle: " . fileLastError() . "\n") if ! defined $os_fhandle || $os_fhandle == INVALID_HANDLE_VALUE();
      my $result = SetHandleInformation( $os_fhandle, HANDLE_FLAG_INHERIT(), 0);
      # _debug( $result ? "# set no-inherit flag on $which tee\n" : ("# can't disable tee handle flag inherit: " . fileLastError() . "\n"));
      _open_std( $stash->{child}{$which} );
      $stash->{pid}{$which} = system(1, @cmd, $stash->{flag_files}{$which});
      # not restoring std here as it all gets redirected again shortly anyway
    }
    else { # use fork
      _fork_exec( $which, $stash );
    }
  }
  
  sub _fork_exec {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    my $pid = fork;
    if ( not defined $pid ) {
      Carp::confess "Couldn't fork(): $!";
    }
    elsif ($pid == 0) { # child
      # _debug( "# in child process ...\n" );
      untie *STDIN; untie *STDOUT; untie *STDERR;
      _close $stash->{tee}{$which};
      # _debug( "# redirecting handles in child ...\n" );
      _open_std( $stash->{child}{$which} );
      # _debug( "# calling exec on command ...\n" );
      exec @cmd, $stash->{flag_files}{$which};
    }
    $stash->{pid}{$which} = $pid
  }
  
  my $have_usleep = eval "use Time::HiRes 'usleep'; 1";
  sub _files_exist {
    return 1 if @_ == grep { -f } @_;
    Time::HiRes::usleep(1000) if $have_usleep;
    return 0;
  }
  
  sub _wait_for_tees {
    my ($stash) = @_;
    my $start = time;
    my @files = values %{$stash->{flag_files}};
    my $timeout = defined $ENV{PERL_CAPTURE_TINY_TIMEOUT}
                ? $ENV{PERL_CAPTURE_TINY_TIMEOUT} : $TIMEOUT;
    1 until _files_exist(@files) || ($timeout && (time - $start > $timeout));
    Carp::confess "Timed out waiting for subprocesses to start" if ! _files_exist(@files);
    unlink $_ for @files;
  }
  
  sub _kill_tees {
    my ($stash) = @_;
    if ( $IS_WIN32 ) {
      # _debug( "# closing handles with CloseHandle\n");
      CloseHandle( GetOsFHandle($_) ) for values %{ $stash->{tee} };
      # _debug( "# waiting for subprocesses to finish\n");
      my $start = time;
      1 until wait == -1 || (time - $start > 30);
    }
    else {
      _close $_ for values %{ $stash->{tee} };
      waitpid $_, 0 for values %{ $stash->{pid} };
    }
  }
  
  sub _slurp {
    my ($name, $stash) = @_;
    my ($fh, $pos) = map { $stash->{$_}{$name} } qw/capture pos/;
    # _debug( "# slurping captured $name from " . fileno($fh) . " at pos $pos with layers: @{[PerlIO::get_layers($fh)]}\n");
    seek( $fh, $pos, 0 ) or die "Couldn't seek on capture handle for $name\n";
    my $text = do { local $/; scalar readline $fh };
    return defined($text) ? $text : "";
  }
  
  #--------------------------------------------------------------------------#
  # _capture_tee() -- generic main sub for capturing or teeing
  #--------------------------------------------------------------------------#
  
  sub _capture_tee {
    # _debug( "# starting _capture_tee with (@_)...\n" );
    my ($do_stdout, $do_stderr, $do_merge, $do_tee, $code, @opts) = @_;
    my %do = ($do_stdout ? (stdout => 1) : (),  $do_stderr ? (stderr => 1) : ());
    Carp::confess("Custom capture options must be given as key/value pairs\n")
      unless @opts % 2 == 0;
    my $stash = { capture => { @opts } };
    for ( keys %{$stash->{capture}} ) {
      my $fh = $stash->{capture}{$_};
      Carp::confess "Custom handle for $_ must be seekable\n"
        unless ref($fh) eq 'GLOB' || (blessed($fh) && $fh->isa("IO::Seekable"));
    }
    # save existing filehandles and setup captures
    local *CT_ORIG_STDIN  = *STDIN ;
    local *CT_ORIG_STDOUT = *STDOUT;
    local *CT_ORIG_STDERR = *STDERR;
    # find initial layers
    my %layers = (
      stdin   => [PerlIO::get_layers(\*STDIN) ],
      stdout  => [PerlIO::get_layers(\*STDOUT, output => 1)],
      stderr  => [PerlIO::get_layers(\*STDERR, output => 1)],
    );
    # _debug( "# existing layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # get layers from underlying glob of tied filehandles if we can
    # (this only works for things that work like Tie::StdHandle)
    $layers{stdout} = [PerlIO::get_layers(tied *STDOUT)]
      if tied(*STDOUT) && (reftype tied *STDOUT eq 'GLOB');
    $layers{stderr} = [PerlIO::get_layers(tied *STDERR)]
      if tied(*STDERR) && (reftype tied *STDERR eq 'GLOB');
    # _debug( "# tied object corrected layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # bypass scalar filehandles and tied handles
    # localize scalar STDIN to get a proxy to pick up FD0, then restore later to CT_ORIG_STDIN
    my %localize;
    $localize{stdin}++,  local(*STDIN)
      if grep { $_ eq 'scalar' } @{$layers{stdin}};
    $localize{stdout}++, local(*STDOUT)
      if $do_stdout && grep { $_ eq 'scalar' } @{$layers{stdout}};
    $localize{stderr}++, local(*STDERR)
      if ($do_stderr || $do_merge) && grep { $_ eq 'scalar' } @{$layers{stderr}};
    $localize{stdin}++, local(*STDIN), _open( \*STDIN, "<&=0")
      if tied *STDIN && $] >= 5.008;
    $localize{stdout}++, local(*STDOUT), _open( \*STDOUT, ">&=1")
      if $do_stdout && tied *STDOUT && $] >= 5.008;
    $localize{stderr}++, local(*STDERR), _open( \*STDERR, ">&=2")
      if ($do_stderr || $do_merge) && tied *STDERR && $] >= 5.008;
    # _debug( "# localized $_\n" ) for keys %localize;
    # proxy any closed/localized handles so we don't use fds 0, 1 or 2
    my %proxy_std = _proxy_std();
    # _debug( "# proxy std: @{ [%proxy_std] }\n" );
    # update layers after any proxying
    $layers{stdout} = [PerlIO::get_layers(\*STDOUT, output => 1)] if $proxy_std{stdout};
    $layers{stderr} = [PerlIO::get_layers(\*STDERR, output => 1)] if $proxy_std{stderr};
    # _debug( "# post-proxy layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # store old handles and setup handles for capture
    $stash->{old} = _copy_std();
    $stash->{new} = { %{$stash->{old}} }; # default to originals
    for ( keys %do ) {
      $stash->{new}{$_} = ($stash->{capture}{$_} ||= File::Temp->new);
      seek( $stash->{capture}{$_}, 0, 2 ) or die "Could not seek on capture handle for $_\n";
      $stash->{pos}{$_} = tell $stash->{capture}{$_};
      # _debug("# will capture $_ on " . fileno($stash->{capture}{$_})."\n" );
      _start_tee( $_ => $stash ) if $do_tee; # tees may change $stash->{new}
    }
    _wait_for_tees( $stash ) if $do_tee;
    # finalize redirection
    $stash->{new}{stderr} = $stash->{new}{stdout} if $do_merge;
    # _debug( "# redirecting in parent ...\n" );
    _open_std( $stash->{new} );
    # execute user provided code
    my ($exit_code, $inner_error, $outer_error, @result);
    {
      local *STDIN = *CT_ORIG_STDIN if $localize{stdin}; # get original, not proxy STDIN
      # _debug( "# finalizing layers ...\n" );
      _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
      _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
      # _debug( "# running code $code ...\n" );
      local $@;
      eval { @result = $code->(); $inner_error = $@ };
      $exit_code = $?; # save this for later
      $outer_error = $@; # save this for later
      STDOUT->flush if $do_stdout;
      STDERR->flush if $do_stderr;
    }
    # restore prior filehandles and shut down tees
    # _debug( "# restoring filehandles ...\n" );
    _open_std( $stash->{old} );
    _close( $_ ) for values %{$stash->{old}}; # don't leak fds
    # shouldn't need relayering originals, but see rt.perl.org #114404
    _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
    _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
    _unproxy( %proxy_std );
    # _debug( "# killing tee subprocesses ...\n" ) if $do_tee;
    _kill_tees( $stash ) if $do_tee;
    # return captured output, but shortcut in void context
    # unless we have to echo output to tied/scalar handles;
    my %got;
    if ( defined wantarray or ($do_tee && keys %localize) ) {
      for ( keys %do ) {
        _relayer($stash->{capture}{$_}, $layers{$_});
        $got{$_} = _slurp($_, $stash);
        # _debug("# slurped " . length($got{$_}) . " bytes from $_\n");
      }
      print CT_ORIG_STDOUT $got{stdout}
        if $do_stdout && $do_tee && $localize{stdout};
      print CT_ORIG_STDERR $got{stderr}
        if $do_stderr && $do_tee && $localize{stderr};
    }
    $? = $exit_code;
    $@ = $inner_error if $inner_error;
    die $outer_error if $outer_error;
    # _debug( "# ending _capture_tee with (@_)...\n" );
    return unless defined wantarray;
    my @return;
    push @return, $got{stdout} if $do_stdout;
    push @return, $got{stderr} if $do_stderr && ! $do_merge;
    push @return, @result;
    return wantarray ? @return : $return[0];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Capture::Tiny - Capture STDOUT and STDERR from Perl, XS or external programs
  
  =head1 VERSION
  
  version 0.28
  
  =head1 SYNOPSIS
  
     use Capture::Tiny ':all';
   
     # capture from external command
   
     ($stdout, $stderr, $exit) = capture {
       system( $cmd, @args );
     };
   
     # capture from arbitrary code (Perl or external)
   
     ($stdout, $stderr, @result) = capture {
       # your code here
     };
   
     # capture partial or merged output
   
     $stdout = capture_stdout { ... };
     $stderr = capture_stderr { ... };
     $merged = capture_merged { ... };
   
     # tee output
   
     ($stdout, $stderr) = tee {
       # your code here
     };
   
     $stdout = tee_stdout { ... };
     $stderr = tee_stderr { ... };
     $merged = tee_merged { ... };
  
  =head1 DESCRIPTION
  
  Capture::Tiny provides a simple, portable way to capture almost anything sent
  to STDOUT or STDERR, regardless of whether it comes from Perl, from XS code or
  from an external program.  Optionally, output can be teed so that it is
  captured while being passed through to the original filehandles.  Yes, it even
  works on Windows (usually).  Stop guessing which of a dozen capturing modules
  to use in any particular situation and just use this one.
  
  =head1 USAGE
  
  The following functions are available.  None are exported by default.
  
  =head2 capture
  
     ($stdout, $stderr, @result) = capture \&code;
     $stdout = capture \&code;
  
  The C<<< capture >>> function takes a code reference and returns what is sent to
  STDOUT and STDERR as well as any return values from the code reference.  In
  scalar context, it returns only STDOUT.  If no output was received for a
  filehandle, it returns an empty string for that filehandle.  Regardless of calling
  context, all output is captured -- nothing is passed to the existing filehandles.
  
  It is prototyped to take a subroutine reference as an argument. Thus, it
  can be called in block form:
  
     ($stdout, $stderr) = capture {
       # your code here ...
     };
  
  Note that the coderef is evaluated in list context.  If you wish to force
  scalar context on the return value, you must use the C<<< scalar >>> keyword.
  
     ($stdout, $stderr, $count) = capture {
       my @list = qw/one two three/;
       return scalar @list; # $count will be 3
     };
  
  Also note that within the coderef, the C<<< @_ >>> variable will be empty.  So don't
  use arguments from a surrounding subroutine without copying them to an array
  first:
  
     sub wont_work {
       my ($stdout, $stderr) = capture { do_stuff( @_ ) };    # WRONG
       ...
     }
   
     sub will_work {
       my @args = @_;
       my ($stdout, $stderr) = capture { do_stuff( @args ) }; # RIGHT
       ...
     }
  
  Captures are normally done to an anonymous temporary filehandle.  To
  capture via a named file (e.g. to externally monitor a long-running capture),
  provide custom filehandles as a trailing list of option pairs:
  
     my $out_fh = IO::File->new("out.txt", "w+");
     my $err_fh = IO::File->new("out.txt", "w+");
     capture { ... } stdout => $out_fh, stderr => $err_fh;
  
  The filehandles must be readE<sol>write and seekable.  Modifying the files or
  filehandles during a capture operation will give unpredictable results.
  Existing IO layers on them may be changed by the capture.
  
  When called in void context, C<<< capture >>> saves memory and time by
  not reading back from the capture handles.
  
  =head2 capture_stdout
  
     ($stdout, @result) = capture_stdout \&code;
     $stdout = capture_stdout \&code;
  
  The C<<< capture_stdout >>> function works just like C<<< capture >>> except only
  STDOUT is captured.  STDERR is not captured.
  
  =head2 capture_stderr
  
     ($stderr, @result) = capture_stderr \&code;
     $stderr = capture_stderr \&code;
  
  The C<<< capture_stderr >>> function works just like C<<< capture >>> except only
  STDERR is captured.  STDOUT is not captured.
  
  =head2 capture_merged
  
     ($merged, @result) = capture_merged \&code;
     $merged = capture_merged \&code;
  
  The C<<< capture_merged >>> function works just like C<<< capture >>> except STDOUT and
  STDERR are merged. (Technically, STDERR is redirected to the same capturing
  handle as STDOUT before executing the function.)
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head2 tee
  
     ($stdout, $stderr, @result) = tee \&code;
     $stdout = tee \&code;
  
  The C<<< tee >>> function works just like C<<< capture >>>, except that output is captured
  as well as passed on to the original STDOUT and STDERR.
  
  When called in void context, C<<< tee >>> saves memory and time by
  not reading back from the capture handles, except when the
  original STDOUT OR STDERR were tied or opened to a scalar
  handle.
  
  =head2 tee_stdout
  
     ($stdout, @result) = tee_stdout \&code;
     $stdout = tee_stdout \&code;
  
  The C<<< tee_stdout >>> function works just like C<<< tee >>> except only
  STDOUT is teed.  STDERR is not teed (output goes to STDERR as usual).
  
  =head2 tee_stderr
  
     ($stderr, @result) = tee_stderr \&code;
     $stderr = tee_stderr \&code;
  
  The C<<< tee_stderr >>> function works just like C<<< tee >>> except only
  STDERR is teed.  STDOUT is not teed (output goes to STDOUT as usual).
  
  =head2 tee_merged
  
     ($merged, @result) = tee_merged \&code;
     $merged = tee_merged \&code;
  
  The C<<< tee_merged >>> function works just like C<<< capture_merged >>> except that output
  is captured as well as passed on to STDOUT.
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head1 LIMITATIONS
  
  =head2 Portability
  
  Portability is a goal, not a guarantee.  C<<< tee >>> requires fork, except on
  Windows where C<<< system(1, @cmd) >>> is used instead.  Not tested on any
  particularly esoteric platforms yet.  See the
  L<CPAN Testers Matrix|http://matrix.cpantesters.org/?dist=Capture-Tiny>
  for test result by platform.
  
  =head2 PerlIO layers
  
  Capture::Tiny does it's best to preserve PerlIO layers such as ':utf8' or
  ':crlf' when capturing (only for Perl 5.8.1+) .  Layers should be applied to
  STDOUT or STDERR I<before> the call to C<<< capture >>> or C<<< tee >>>.  This may not work
  for tied filehandles (see below).
  
  =head2 Modifying filehandles before capturing
  
  Generally speaking, you should do little or no manipulation of the standard IO
  filehandles prior to using Capture::Tiny.  In particular, closing, reopening,
  localizing or tying standard filehandles prior to capture may cause a variety of
  unexpected, undesirable andE<sol>or unreliable behaviors, as described below.
  Capture::Tiny does its best to compensate for these situations, but the
  results may not be what you desire.
  
  B<Closed filehandles>
  
  Capture::Tiny will work even if STDIN, STDOUT or STDERR have been previously
  closed.  However, since they will be reopened to capture or tee output, any
  code within the captured block that depends on finding them closed will, of
  course, not find them to be closed.  If they started closed, Capture::Tiny will
  close them again when the capture block finishes.
  
  Note that this reopening will happen even for STDIN or a filehandle not being
  captured to ensure that the filehandle used for capture is not opened to file
  descriptor 0, as this causes problems on various platforms.
  
  Prior to Perl 5.12, closed STDIN combined with PERL_UNICODE=D leaks filehandles
  and also breaks tee() for undiagnosed reasons.  So don't do that.
  
  B<Localized filehandles>
  
  If code localizes any of Perl's standard filehandles before capturing, the capture
  will affect the localized filehandles and not the original ones.  External system
  calls are not affected by localizing a filehandle in Perl and will continue
  to send output to the original filehandles (which will thus not be captured).
  
  B<Scalar filehandles>
  
  If STDOUT or STDERR are reopened to scalar filehandles prior to the call to
  C<<< capture >>> or C<<< tee >>>, then Capture::Tiny will override the output filehandle for
  the duration of the C<<< capture >>> or C<<< tee >>> call and then, for C<<< tee >>>, send captured
  output to the output filehandle after the capture is complete.  (Requires Perl
  5.8)
  
  Capture::Tiny attempts to preserve the semantics of STDIN opened to a scalar
  reference, but note that external processes will not be able to read from such
  a handle.  Capture::Tiny tries to ensure that external processes will read from
  the null device instead, but this is not guaranteed.
  
  B<Tied output filehandles>
  
  If STDOUT or STDERR are tied prior to the call to C<<< capture >>> or C<<< tee >>>, then
  Capture::Tiny will attempt to override the tie for the duration of the
  C<<< capture >>> or C<<< tee >>> call and then send captured output to the tied filehandle after
  the capture is complete.  (Requires Perl 5.8)
  
  Capture::Tiny may not succeed resending UTF-8 encoded data to a tied
  STDOUT or STDERR filehandle.  Characters may appear as bytes.  If the tied filehandle
  is based on L<Tie::StdHandle>, then Capture::Tiny will attempt to determine
  appropriate layers like C<<< :utf8 >>> from the underlying filehandle and do the right
  thing.
  
  B<Tied input filehandle>
  
  Capture::Tiny attempts to preserve the semantics of tied STDIN, but this
  requires Perl 5.8 and is not entirely predictable.  External processes
  will not be able to read from such a handle.
  
  Unless having STDIN tied is crucial, it may be safest to localize STDIN when
  capturing:
  
     my ($out, $err) = do { local *STDIN; capture { ... } };
  
  =head2 Modifying filehandles during a capture
  
  Attempting to modify STDIN, STDOUT or STDERR I<during> C<<< capture >>> or C<<< tee >>> is
  almost certainly going to cause problems.  Don't do that.
  
  =head2 No support for Perl 5.8.0
  
  It's just too buggy when it comes to layers and UTF-8.  Perl 5.8.1 or later
  is recommended.
  
  =head2 Limited support for Perl 5.6
  
  Perl 5.6 predates PerlIO.  UTF-8 data may not be captured correctly.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_CAPTURE_TINY_TIMEOUT
  
  Capture::Tiny uses subprocesses internally for C<<< tee >>>.  By default,
  Capture::Tiny will timeout with an error if such subprocesses are not ready to
  receive data within 30 seconds (or whatever is the value of
  C<<< $Capture::Tiny::TIMEOUT >>>).  An alternate timeout may be specified by setting
  the C<<< PERL_CAPTURE_TINY_TIMEOUT >>> environment variable.  Setting it to zero will
  disable timeouts.  BE<lt>NOTEE<gt>, this does not timeout the code reference being
  captured -- this only prevents Capture::Tiny itself from hanging your process
  waiting for its child processes to be ready to proceed.
  
  =head1 SEE ALSO
  
  This module was, inspired by L<IO::CaptureOutput>, which provides
  similar functionality without the ability to tee output and with more
  complicated code and API.  L<IO::CaptureOutput> does not handle layers
  or most of the unusual cases described in the L</Limitations> section and
  I no longer recommend it.
  
  There are many other CPAN modules that provide some sort of output capture,
  albeit with various limitations that make them appropriate only in particular
  circumstances.  I'm probably missing some.  The long list is provided to show
  why I felt Capture::Tiny was necessary.
  
  =over
  
  =item *
  
  L<IO::Capture>
  
  =item *
  
  L<IO::Capture::Extended>
  
  =item *
  
  L<IO::CaptureOutput>
  
  =item *
  
  L<IPC::Capture>
  
  =item *
  
  L<IPC::Cmd>
  
  =item *
  
  L<IPC::Open2>
  
  =item *
  
  L<IPC::Open3>
  
  =item *
  
  L<IPC::Open3::Simple>
  
  =item *
  
  L<IPC::Open3::Utils>
  
  =item *
  
  L<IPC::Run>
  
  =item *
  
  L<IPC::Run::SafeHandles>
  
  =item *
  
  L<IPC::Run::Simple>
  
  =item *
  
  L<IPC::Run3>
  
  =item *
  
  L<IPC::System::Simple>
  
  =item *
  
  L<Tee>
  
  =item *
  
  L<IO::Tee>
  
  =item *
  
  L<File::Tee>
  
  =item *
  
  L<Filter::Handle>
  
  =item *
  
  L<Tie::STDERR>
  
  =item *
  
  L<Tie::STDOUT>
  
  =item *
  
  L<Test::Output>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Capture-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Capture-Tiny>
  
    git clone https://github.com/dagolden/Capture-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David E. Wheeler
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David E. Wheeler <david@justatheory.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2009 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
CAPTURE_TINY

$fatpacked{"Class/Std.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_STD';
  package Class::Std;
  
  our $VERSION = '0.013';
  use strict;
  use warnings;
  use Carp;
  use Scalar::Util;
  
  use overload;
  
  BEGIN { *ID = \&Scalar::Util::refaddr; }
  
  my (%attribute, %cumulative, %anticumulative, %restricted, %private, %overload);
  
  my @exported_subs = qw(
      new
      DESTROY
      AUTOLOAD
      _DUMP
  );
  
  my @exported_extension_subs = qw(
      MODIFY_HASH_ATTRIBUTES
      MODIFY_CODE_ATTRIBUTES
  );
  
  sub import {
      my $caller = caller;
  
      no strict 'refs';
      *{ $caller . '::ident'   } = \&Scalar::Util::refaddr;
      for my $sub ( @exported_subs ) {
          *{ $caller . '::' . $sub } = \&{$sub};
      }
      for my $sub ( @exported_extension_subs ) {
          my $target = $caller . '::' . $sub;
          my $real_sub = *{ $target }{CODE} || sub { return @_[2..$#_] };
          no warnings 'redefine';
          *{ $target } = sub {
              my ($package, $referent, @unhandled) = @_;
              for my $handler ($sub, $real_sub) {
                  next if !@unhandled;
                  @unhandled = $handler->($package, $referent, @unhandled);
              }
              return @unhandled;
          };
      }
  }
  
  sub _find_sub {
      my ($package, $sub_ref) = @_;
      no strict 'refs';
      for my $name (keys %{$package.'::'}) {
          my $candidate = *{$package.'::'.$name}{CODE};
          return $name if $candidate && $candidate == $sub_ref;
      }
      croak q{Can't make anonymous subroutine cumulative};
  }
  
  sub _raw_str {
      my ($pat) = @_;
      return qr{ ('$pat') | ("$pat")
               | qq? (?:
                       /($pat)/ | \{($pat)\} | \(($pat)\) | \[($pat)\] | <($pat)>
                     )
               }xms;
  }
  
  sub _str {
      my ($pat) = @_;
      return qr{ '($pat)' | "($pat)"
               | qq? (?:
                       /($pat)/ | \{($pat)\} | \(($pat)\) | \[($pat)\] | <($pat)>
                     )
               }xms;
  }
  
  sub _extractor_for_pair_named {
      my ($key, $raw) = @_;
  
      $key = qr{\Q$key\E};
      my $str_key = _str($key);
  
      my $LDAB = "(?:\x{AB})";
      my $RDAB = "(?:\x{BB})";
  
      my $STR = $raw ? _raw_str( qr{.*?} ) : _str( qr{.*?} );
      my $NUM = qr{ ( [-+]? (?:\d+\.?\d*|\.\d+) (?:[eE]\d+)? ) }xms;
  
      my $matcher = qr{ :$key<  \s* ([^>]*) \s* >
                      | :$key$LDAB  \s* ([^$RDAB]*) \s* $RDAB
                      | :$key\( \s*  (?:$STR | $NUM )   \s* \)
                      | (?: $key | $str_key ) \s* => \s* (?: $STR | $NUM )
                      }xms;
  
      return sub { return $_[0] =~ $matcher ? $+ : undef };
  }
  
  BEGIN {
      *_extract_default  = _extractor_for_pair_named('default','raw');
      *_extract_init_arg = _extractor_for_pair_named('init_arg');
      *_extract_get      = _extractor_for_pair_named('get');
      *_extract_set      = _extractor_for_pair_named('set');
      *_extract_name     = _extractor_for_pair_named('name');
  }
  
  sub MODIFY_HASH_ATTRIBUTES {
      my ($package, $referent, @attrs) = @_;
      for my $attr (@attrs) {
          next if $attr !~ m/\A ATTRS? \s* (?: \( (.*) \) )? \z/xms;
          my ($default, $init_arg, $getter, $setter, $name);
          if (my $config = $1) {
              $default  = _extract_default($config);
              $name     = _extract_name($config);
              $init_arg = _extract_init_arg($config) || $name;
  
              if ($getter = _extract_get($config) || $name) {
                  no strict 'refs';
                  *{$package.'::get_'.$getter} = sub {
                      return $referent->{ID($_[0])};
                  }
              }
              if ($setter = _extract_set($config) || $name) {
                  no strict 'refs';
                  *{$package.'::set_'.$setter} = sub {
                      croak "Missing new value in call to 'set_$setter' method"
                          unless @_ == 2;
                      my ($self, $new_val) = @_;
                      my $old_val = $referent->{ID($self)};
                      $referent->{ID($self)} = $new_val;
                      return $old_val;
                  }
              }
          }
          undef $attr;
          push @{$attribute{$package}}, {
              ref      => $referent,
              default  => $default,
              init_arg => $init_arg,
              name     => $name || $init_arg || $getter || $setter || '????',
          };
      }
      return grep {defined} @attrs;
  }
  
  sub _DUMP {
      my ($self) = @_;
      my $id = ID($self);
  
      my %dump;
      for my $package (keys %attribute) { 
          my $attr_list_ref = $attribute{$package};
          for my $attr_ref ( @{$attr_list_ref} ) {
              next if !exists $attr_ref->{ref}{$id};
              $dump{$package}{$attr_ref->{name}} = $attr_ref->{ref}{$id};
          }
      }
  
      require Data::Dumper;
      my $dump = Data::Dumper::Dumper(\%dump);
      $dump =~ s/^.{8}//gxms;
      return $dump;
  }
  
  my $STD_OVERLOADER
      = q{ package %%s;
           use overload (
              q{%s} => sub { $_[0]->%%s($_[0]->ident()) },
              fallback => 1
           );
         };
  
  my %OVERLOADER_FOR = (
      STRINGIFY => sprintf( $STD_OVERLOADER, q{""}   ),
      NUMERIFY  => sprintf( $STD_OVERLOADER, q{0+}   ),
      BOOLIFY   => sprintf( $STD_OVERLOADER, q{bool} ),
      SCALARIFY => sprintf( $STD_OVERLOADER, q{${}}  ),
      ARRAYIFY  => sprintf( $STD_OVERLOADER, q{@{}}  ),
      HASHIFY   => sprintf( $STD_OVERLOADER, q{%%{}} ),  # %% to survive sprintf
      GLOBIFY   => sprintf( $STD_OVERLOADER, q{*{}}  ),
      CODIFY    => sprintf( $STD_OVERLOADER, q{&{}}  ),
  );
  
  sub MODIFY_CODE_ATTRIBUTES {
      my ($package, $referent, @attrs) = @_;
      for my $attr (@attrs) {
          if ($attr eq 'CUMULATIVE') {
              push @{$cumulative{$package}}, $referent;
          }
          elsif ($attr =~ m/\A CUMULATIVE \s* [(] \s* BASE \s* FIRST \s* [)] \z/xms) {
              push @{$anticumulative{$package}}, $referent;
          }
          elsif ($attr =~ m/\A RESTRICTED \z/xms) {
              push @{$restricted{$package}}, $referent;
          }
          elsif ($attr =~ m/\A PRIVATE \z/xms) {
              push @{$private{$package}}, $referent;
          }
          elsif (exists $OVERLOADER_FOR{$attr}) {
              push @{$overload{$package}}, [$referent, $attr];
          }
          undef $attr;
      }
      return grep {defined} @attrs;
  }
  
  my %_hierarchy_of;
  
  sub _hierarchy_of {
      my ($class) = @_;
  
      return @{$_hierarchy_of{$class}} if exists $_hierarchy_of{$class};
  
      no strict 'refs';
  
      my @hierarchy = $class;
      my @parents   = @{$class.'::ISA'};
  
      while (defined (my $parent = shift @parents)) {
          push @hierarchy, $parent;
          push @parents, @{$parent.'::ISA'};
      }
  
      my %seen;
      return @{$_hierarchy_of{$class}}
          = sort { $a->isa($b) ? -1
                 : $b->isa($a) ? +1
                 :                0
                 } grep !$seen{$_}++, @hierarchy;
  }
  
  my %_reverse_hierarchy_of;
  
  sub _reverse_hierarchy_of {
      my ($class) = @_;
  
      return @{$_reverse_hierarchy_of{$class}}
          if exists $_reverse_hierarchy_of{$class};
  
      no strict 'refs';
  
      my @hierarchy = $class;
      my @parents   = reverse @{$class.'::ISA'};
  
      while (defined (my $parent = shift @parents)) {
          push @hierarchy, $parent;
          push @parents, reverse @{$parent.'::ISA'};
      }
  
      my %seen;
      return @{$_reverse_hierarchy_of{$class}}
          = reverse sort { $a->isa($b) ? -1
                         : $b->isa($a) ? +1
                         :                0
                         } grep !$seen{$_}++, @hierarchy;
  }
  
  {
      no warnings qw( void );
      CHECK { initialize() }
  }
  
  sub initialize {
      # Short-circuit if nothing to do...
      return if keys(%restricted) + keys(%private)
              + keys(%cumulative) + keys(%anticumulative)
              + keys(%overload)
                  == 0;
  
      my (%cumulative_named, %anticumulative_named);
  
      # Implement restricted methods (only callable within hierarchy)...
      for my $package (keys %restricted) {
          for my $sub_ref (@{$restricted{$package}}) {
              my $name = _find_sub($package, $sub_ref);
              no warnings 'redefine';
              no strict 'refs';
              my $sub_name = $package.'::'.$name;
              my $original = *{$sub_name}{CODE}
                  or croak "Restricted method ${package}::$name() declared ",
                           'but not defined';
              *{$sub_name} = sub {
                  my $caller;
                  my $level = 0;
                  while ($caller = caller($level++)) {
                       last if $caller !~ /^(?: Class::Std | attributes )$/xms;
                  }
                  goto &{$original} if !$caller || $caller->isa($package)
                                                || $package->isa($caller);
                  croak "Can't call restricted method $sub_name() from class $caller";
              }
          }
      }
  
      # Implement private methods (only callable from class itself)...
      for my $package (keys %private) {
          for my $sub_ref (@{$private{$package}}) {
              my $name = _find_sub($package, $sub_ref);
              no warnings 'redefine';
              no strict 'refs';
              my $sub_name = $package.'::'.$name;
              my $original = *{$sub_name}{CODE}
                  or croak "Private method ${package}::$name() declared ",
                           'but not defined';
              *{$sub_name} = sub {
                  my $caller = caller;
                  goto &{$original} if $caller eq $package;
                  croak "Can't call private method $sub_name() from class $caller";
              }
          }
      }
  
      for my $package (keys %cumulative) {
          for my $sub_ref (@{$cumulative{$package}}) {
              my $name = _find_sub($package, $sub_ref);
              $cumulative_named{$name}{$package} = $sub_ref;
              no warnings 'redefine';
              no strict 'refs';
              *{$package.'::'.$name} = sub {
                  my @args = @_;
                  my $class = ref($_[0]) || $_[0];
                  my $list_context = wantarray; 
                  my (@results, @classes);
                  for my $parent (_hierarchy_of($class)) {
                      my $sub_ref = $cumulative_named{$name}{$parent} or next;
                      ${$parent.'::AUTOLOAD'} = our $AUTOLOAD if $name eq 'AUTOLOAD';
                      if (!defined $list_context) {
                          $sub_ref->(@args);
                          next;
                      }
                      push @classes, $parent;
                      if ($list_context) {
                          push @results, $sub_ref->(@args);
                      }
                      else {
                          push @results, scalar $sub_ref->(@args);
                      }
                  }
                  return if !defined $list_context;
                  return @results if $list_context;
                  return Class::Std::SCR->new({
                      values  => \@results,
                      classes => \@classes,
                  });
              };
          }
      }
  
      for my $package (keys %anticumulative) {
          for my $sub_ref (@{$anticumulative{$package}}) {
              my $name = _find_sub($package, $sub_ref);
              if ($cumulative_named{$name}) {
                  for my $other_package (keys %{$cumulative_named{$name}}) {
                      next unless $other_package->isa($package)
                               || $package->isa($other_package);
                      print STDERR
                          "Conflicting definitions for cumulative method",
                          " '$name'\n",
                          "(specified as :CUMULATIVE in class '$other_package'\n",
                          " but declared :CUMULATIVE(BASE FIRST) in class ",
                          " '$package')\n";
                      exit(1);
                  }
              }
              $anticumulative_named{$name}{$package} = $sub_ref;
              no warnings 'redefine';
              no strict 'refs';
              *{$package.'::'.$name} = sub {
                  my $class = ref($_[0]) || $_[0];
                  my $list_context = wantarray; 
                  my (@results, @classes);
                  for my $parent (_reverse_hierarchy_of($class)) {
                      my $sub_ref = $anticumulative_named{$name}{$parent} or next;
                      if (!defined $list_context) {
                          &{$sub_ref};
                          next;
                      }
                      push @classes, $parent;
                      if ($list_context) {
                          push @results, &{$sub_ref};
                      }
                      else {
                          push @results, scalar &{$sub_ref};
                      }
                  }
                  return if !defined $list_context;
                  return @results if $list_context;
                  return Class::Std::SCR->new({
                      values  => \@results,
                      classes => \@classes,
                  });
              };
          }
      }
  
      for my $package (keys %overload) {
          foreach my $operation (@{ $overload{$package} }) {
              my ($referent, $attr) = @$operation;
              local $^W;
              my $method = _find_sub($package, $referent);
              eval sprintf $OVERLOADER_FOR{$attr}, $package, $method;
              die "Internal error: $@" if $@;
          }
      }
  
      # Remove initialization data to prevent re-initializations...
      %restricted     = ();
      %private        = ();
      %cumulative     = ();
      %anticumulative = ();
      %overload       = ();
  }
  
  sub new {
      my ($class, $arg_ref) = @_;
  
      Class::Std::initialize();   # Ensure run-time (and mod_perl) setup is done
  
      no strict 'refs';
      croak "Can't find class $class" if ! keys %{$class.'::'};
  
      croak "Argument to $class->new() must be hash reference"
          if @_ > 1 && ref $arg_ref ne 'HASH';
  
      my $new_obj = bless \my($anon_scalar), $class;
      my $new_obj_id = ID($new_obj);
      my (@missing_inits, @suss_keys);
  
      $arg_ref ||= {};
      my %arg_set;
      BUILD: for my $base_class (_reverse_hierarchy_of($class)) {
          my $arg_set = $arg_set{$base_class}
              = { %{$arg_ref}, %{$arg_ref->{$base_class}||{}} };
  
          # Apply BUILD() methods...
          {
              no warnings 'once';
              if (my $build_ref = *{$base_class.'::BUILD'}{CODE}) {
                  $build_ref->($new_obj, $new_obj_id, $arg_set);
              }
          }
  
          # Apply init_arg and default for attributes still undefined...
          INITIALIZATION:
          for my $attr_ref ( @{$attribute{$base_class}} ) {
              next INITIALIZATION if defined $attr_ref->{ref}{$new_obj_id};
  
              # Get arg from initializer list...
              if (defined $attr_ref->{init_arg}
                  && exists $arg_set->{$attr_ref->{init_arg}}) {
                  $attr_ref->{ref}{$new_obj_id} = $arg_set->{$attr_ref->{init_arg}};
  
                  next INITIALIZATION;
              }
              elsif (defined $attr_ref->{default}) {
                  # Or use default value specified...
                  $attr_ref->{ref}{$new_obj_id} = eval $attr_ref->{default};
  
                  if ($@) {
                      $attr_ref->{ref}{$new_obj_id} = $attr_ref->{default};
                  }
  
                  next INITIALIZATION;
              }
  
              if (defined $attr_ref->{init_arg}) {
                  # Record missing init_arg...
                  push @missing_inits, 
                       "Missing initializer label for $base_class: "
                       . "'$attr_ref->{init_arg}'.\n";
                  push @suss_keys, keys %{$arg_set};
              }
          }
      }
  
      croak @missing_inits, _mislabelled(@suss_keys),
            'Fatal error in constructor call'
                  if @missing_inits;
  
      # START methods run after all BUILD methods complete...
      for my $base_class (_reverse_hierarchy_of($class)) {
          my $arg_set = $arg_set{$base_class};
  
          # Apply START() methods...
          {
              no warnings 'once';
              if (my $init_ref = *{$base_class.'::START'}{CODE}) {
                  $init_ref->($new_obj, $new_obj_id, $arg_set);
              }
          }
      }
  
      return $new_obj;
  }
  
  sub uniq (@) {
      my %seen;
      return grep { $seen{$_}++ } @_;
  }
  
  
  sub _mislabelled {
      my (@names) = map { qq{'$_'} } uniq @_;
  
      return q{} if @names == 0;
  
      my $arglist
          = @names == 1 ? $names[0]
          : @names == 2 ? join q{ or }, @names
          :               join(q{, }, @names[0..$#names-1]) . ", or $names[-1]"
          ;
      return "(Did you mislabel one of the args you passed: $arglist?)\n";
  }
  
  sub DESTROY {
      my ($self) = @_;
      my $id = ID($self);
      push @_, $id;
  
      for my $base_class (_hierarchy_of(ref $_[0])) {
          no strict 'refs';
          if (my $demolish_ref = *{$base_class.'::DEMOLISH'}{CODE}) {
              &{$demolish_ref};
          }
  
          for my $attr_ref ( @{$attribute{$base_class}} ) {
              delete $attr_ref->{ref}{$id};
          }
      }
  }
  
  sub AUTOLOAD {
      my ($invocant) = @_;
      my $invocant_class = ref $invocant || $invocant;
      my ($package_name, $method_name) = our $AUTOLOAD =~ m/ (.*) :: (.*) /xms;
  
      my $ident = ID($invocant);
      if (!defined $ident) { $ident = $invocant }
  
      for my $parent_class ( _hierarchy_of($invocant_class) ) {
          no strict 'refs';
          if (my $automethod_ref = *{$parent_class.'::AUTOMETHOD'}{CODE}) {
              local $CALLER::_ = $_;
              local $_ = $method_name;
              if (my $method_impl
                      = $automethod_ref->($invocant, $ident, @_[1..$#_])) {
                  goto &$method_impl;
              }
          }
      }
  
      my $type = ref $invocant ? 'object' : 'class';
      croak qq{Can't locate $type method "$method_name" via package "$package_name"};
  }
  
  {
      my $real_can = \&UNIVERSAL::can;
      no warnings 'redefine', 'once';
      *UNIVERSAL::can = sub {
          my ($invocant, $method_name) = @_;
  
          if ( defined $invocant ) {
              if (my $sub_ref = $real_can->(@_)) {
                  return $sub_ref;
              }
  
              for my $parent_class ( _hierarchy_of(ref $invocant || $invocant) ) {
                  no strict 'refs';
                  if (my $automethod_ref = *{$parent_class.'::AUTOMETHOD'}{CODE}) {
                      local $CALLER::_ = $_;
                      local $_ = $method_name;
                      if (my $method_impl = $automethod_ref->(@_)) {
                          return sub { my $inv = shift; $inv->$method_name(@_) }
                      }
                  }
              }
          }
  
          return;
      };
  }
  
  package Class::Std::SCR;
  use base qw( Class::Std );
  
  our $VERSION = '0.013';
  
  BEGIN { *ID = \&Scalar::Util::refaddr; }
  
  my %values_of  : ATTR( :init_arg<values> );
  my %classes_of : ATTR( :init_arg<classes> );
  
  sub new {
      my ($class, $opt_ref) = @_;
      my $new_obj = bless \do{my $scalar}, $class;
      my $new_obj_id = ID($new_obj);
      $values_of{$new_obj_id}  = $opt_ref->{values};
      $classes_of{$new_obj_id} = $opt_ref->{classes};
      return $new_obj;
  }
  
  use overload (
      q{""}  => sub { return join q{}, grep { defined $_ } @{$values_of{ID($_[0])}}; },
      q{0+}  => sub { return scalar @{$values_of{ID($_[0])}};    },
      q{@{}} => sub { return $values_of{ID($_[0])};              },
      q{%{}} => sub {
          my ($self) = @_;
          my %hash;
          @hash{@{$classes_of{ID($self)}}} = @{$values_of{ID($self)}};
          return \%hash;
      },
      fallback => 1,
  );
  
  1; # Magic true value required at end of module
  __END__
  
  =encoding ISO-8859-1
  
  =head1 NAME
  
  Class::Std - Support for creating standard "inside-out" classes
  
  
  =head1 VERSION
  
  This document describes Class::Std version 0.013
  
  
  =head1 SYNOPSIS
  
      package MyClass;
      use Class::Std;
  
      # Create storage for object attributes...
      my %name : ATTR;
      my %rank : ATTR;
      my %snum : ATTR;
  
      my %public_data : ATTR;
  
      # Handle initialization of objects of this class...
      sub BUILD {
          my ($self, $obj_ID, $arg_ref) = @_;
  
          $name{$obj_ID} = check_name( $arg_ref->{name} );
          $rank{$obj_ID} = check_rank( $arg_ref->{rank} );
          $snum{$obj_ID} = _gen_uniq_serial_num();
      }
  
      # Handle cleanup of objects of this class...
      sub DEMOLISH {
          my ($self, $obj_ID) = @_;
  
          _recycle_serial_num( $snum{$obj_ID} );
      }
  
      # Handle unknown method calls...
      sub AUTOMETHOD {
          my ($self, $obj_ID, @other_args) = @_;
  
          # Return any public data...
          if ( m/\A get_(.*)/ ) {  # Method name passed in $_
              my $get_what = $1;
              return sub {
                  return $public_data{$obj_ID}{$get_what};
              }
          }
  
          warn "Can't call $method_name on ", ref $self, " object";
  
          return;   # The call is declined by not returning a sub ref
      }
    
    
  =head1 DESCRIPTION
  
  This module provides tools that help to implement the "inside out object"
  class structure in a convenient and standard way.
  
  I<Portions of the following code and documentation from "Perl Best Practices"
  copyright (c) 2005 by O'Reilly Media, Inc. and reprinted with permission.>
  
  =head2 Introduction
  
  Most programmers who use Perl's object-oriented features construct their
  objects by blessing a hash. But, in doing so, they undermine the
  robustness of the OO approach. Hash-based objects are unencapsulated:
  their entries are open for the world to access and modify.
  
  Objects without effective encapsulation are vulnerable. Instead of
  politely respecting their public interface, some clever client coder
  inevitably will realize that it's marginally faster to interact directly
  with the underlying implementation, pulling out attribute values
  directly from the hash of an object:
  
      for my $file ( get_file_objs() ) {
          print $file->{name}, "\n";
      }
  
  instead of using the official interface:
  
      for my $file ( get_file_objs() ) {
          print $file->get_name(), "\n";
      }
  
  From the moment someone does that, your class is no longer cleanly
  decoupled from the code that uses it. You can't be sure that any bugs in
  your class are actually caused by the internals of your class, and not
  the result of some kind of monkeying by the client code. And to make
  matters worse, now you can't ever change those internals without the
  risk of breaking some other part of the system.
  
  There is a simple, convenient, and utterly secure way to prevent client
  code from accessing the internals of the objects you provide. Happily,
  that approach also guards against misspelling attribute names (a common
  error in hash-based classes), as well as being just as fast as--and
  often more memory-efficient than--ordinary hash-based objects.
  
  That approach is referred to by various names--flyweight scalars,
  warehoused attributes, inverted indices--but most commonly it's known
  as: inside-out objects. Consider the following class definitions:
  
      package File::Hierarchy;
      {
          # Objects of this class have the following attributes...
          my %root_of;   # The root directory of the file hierarchy
          my %files_of;  # Array storing object for each file in root directory
          
          # Constructor takes path of file system root directory...
          sub new {
              my ($class, $root) = @_;
          
              # Bless a scalar to instantiate the new object...
              my $new_object = bless \do{my $anon_scalar}, $class;
          
              # Initialize the object's "root" attribute...
              $root_of{ident $new_object} = $root;
          
              return $new_object;
          }
          
          # Retrieve files from root directory...
          sub get_files {
              my ($self) = @_;
          
              # Load up the "files" attribute, if necessary...
              if (!exists $files_of{ident $self}) {
                  $files_of{ident $self} 
                      = File::System->list_files($root_of{ident $self});
              }
          
              # Flatten the "files" attribute's array to produce a file list...
              return @{ $files_of{ident $self} };
          }
      }
  
      package File::Hierarchy::File;
      {    
          # Objects of this class have the following attributes...
          my %name_of;  # the name of the file
          
          # Constructor takes name of file...
          sub new {
              my ($class, $filename) = @_;
          
              # Bless a scalar to instantiate the new object...
              my $new_object = bless \do{my $anon_scalar}, $class;
          
              # Initialize the object's "name" attribute...
              $name_of{ident $new_object} = $filename;
          
              return $new_object;
          }
          
          # Retrieve name of file...
          sub get_name {
              my ($self) = @_;
          
              return $name_of{ident $self};
          }
      }
  
  Unlike a hash-based class, each of these inside-out class is specified
  inside a surrounding code block:
  
      package File::Hierarchy;
      {
          # [Class specification here]
      }
  
      package File::Hierarchy::File;
      {
          # [Class specification here]
      }
  
  That block is vital, because it creates a limited scope, to which any
  lexical variables that are declared as part of the class will
  automatically be restricted. 
  
  The next difference between the two versions of the classes is that each 
  attribute of I<all> the objects in the class is now stored in a separate
  single hash:
  
      # Objects of this class have the following attributes...
  
      my %root_of;   # The root directory of the file hierarchy
      my %files_of;  # Array storing object for each file in root directory
  
  This is 90 degrees to the usual hash-based approach. In hash-based
  classes, all the attributes of one object are stored in a single hash;
  in inside-out classes, one attribute from all objects is stored in a
  single hash. Diagrammatically:
  
      Hash-based:
                       Attribute 1      Attribute 2
  
       Object A    { attr1 => $valA1,  attr2 => $val2 }
  
       Object B    { attr1 => $valB1,  attr2 => $val2 }
  
       Object C    { attr1 => $valB1,  attr2 => $val2 }
  
  
  
      Inside-out:
                        Object A           Object B          Object C
  
      Attribute 1  { 19817 => $valA1,  172616 => $valB1,  67142 => $valC1 }
  
      Attribute 2  { 19817 => $valA2,  172616 => $valB2,  67142 => $valC3 }
  
      Attribute 3  { 19817 => $valA3,  172616 => $valB3,  67142 => $valC3 }
  
  So the attributes belonging to each object are distributed across a set of
  predeclared hashes, rather than being squashed together into one anonymous
  hash.
  
  This is a significant improvement. By telling Perl what attributes you
  expect to use, you enable the compiler to check--via use strict--that
  you do indeed use only those attributes.
  
  That's because of the third difference in the two approaches. Each
  attribute of a hash-based object is stored in an entry in the object's
  hash: C<< $self->{name} >>. In other words, the name of a hash-based attribute
  is symbolic: specified by the string value of a hash key. In contrast,
  each attribute of an inside-out object is stored in an entry of the
  attribute's hash: C<$name_of{ident $self}>. So the name of an inside-out
  attribute isn't symbolic; it's a hard-coded variable name.
  
  With hash-based objects, if an attribute name is accidentally misspelled
  in some method:
  
      sub set_name {
          my ($self, $new_name) = @_;
  
          $self->{naem} = $new_name;             # Oops!
  
          return;
      }
  
  then the C<$self> hash will obligingly--and silently!--create a new entry
  in the hash, with the key C<'naem'>, then assign the new name to it. But
  since every other method in the class correctly refers to the attribute
  as C<$self->{name}>, assigning the new value to C<$self->{naem}> effectively
  makes that assigned value "vanish".
  
  With inside-out objects, however, an object's "name" attribute is stored
  as an entry in the class's lexical C<%name_of> hash. If the attribute name
  is misspelled then you're attempting to refer to an entirely different
  hash: C<%naem_of>. Like so:
  
      sub set_name {
          my ($self, $new_name) = @_;
  
          $naem_of{ident $self} = $new_name;     # Kaboom!
  
          return;
      }
  
  But, since there's no such hash declared in the scope, use strict will
  complain (with extreme prejudice):
  
      Global symbol "%naem_of" requires explicit package name at Hierarchy.pm line 86
  
  Not only is that consistency check now automatic, it's also performed at
  compile time.
  
  The next difference is even more important and beneficial. Instead of
  blessing an empty anonymous hash as the new object:
  
      my $new_object = bless {}, $class;
  
  the inside-out constructor blesses an empty anonymous scalar:
  
      my $new_object = bless \do{my $anon_scalar}, $class;
  
  That odd-looking C<\do{my $anon_scalar}> construct is needed because
  there's no built-in syntax in Perl for creating a reference to an
  anonymous scalar; you have to roll-your-own.
      
  The anonymous scalar is immediately passed to bless, which anoints it as
  an object of the appropriate class. The resulting object reference is
  then stored in C<$new_object>.
  
  Once the object exists, it's used to create a unique key
  (C<ident $new_object>) under which each attribute that belongs to the
  object will be stored (e.g. C<$root_of{ident $new_object}> or
  C<$name_of{ident $self}>). The C<ident()> utility that produces this unique
  key is provided by the Class::Std module and is identical in effect to
  the C<refaddr()> function in the standard Scalar::Util module.
  
  To recap: every inside-out object is a blessed scalar, and
  has--intrinsic to it--a unique identifying integer. That integer can be
  obtained from the object reference itself, and then used to access a
  unique entry for the object in each of the class's attribute hashes.
  
  This means that every inside-out object is nothing more than an
  unintialized scalar. When your constructor passes a new inside-out
  object back to the client code, all that comes back is an empty scalar,
  which makes it impossible for that client code to gain direct access to
  the object's internal state.
  
  Of the several popular methods of reliably enforcing encapsulation in
  Perl, inside-out objects are also by far the cheapest. The run-time
  performance of inside-out classes is effectively identical to that of
  regular hash-based classes. In particular, in both schemes, every
  attribute access requires only a single hash look-up. The only
  appreciable difference in speed occurs when an inside-out object is
  destroyed.
  
  Hash-based classes usually don't even have destructors. When the
  object's reference count decrements to zero, the hash is automatically
  reclaimed, and any data structures stored inside the hash are likewise
  cleaned up. This works so well that many OO Perl programmers find they
  never need to write a C<DESTROY()> method; Perl's built-in garbage
  collection handles everything just fine. In fact, the only time a
  destructor is needed is when objects have to manage resources outside
  that are not actually located inside the object, resources that need to
  be separately deallocated.
  
  But the whole point of an inside-out object is that its attributes are
  stored in allocated hashes that are not actually located inside the
  object. That's precisely how it achieves secure encapsulation: by not
  sending the attributes out into the client code.
  
  Unfortunately, that means when an inside-out object is eventually
  garbage collected, the only storage that is reclaimed is the single
  blessed scalar implementing the object. The object's attributes are
  entirely unaffected by the object's deallocation, because the attributes
  are not inside the object, nor are they referred to by it in any way.
  
  Instead, the attributes are referred to by the various attribute hashes
  in which they're stored. And since those hashes will continue to exist
  until the end of the program, the defunct object's orphaned attributes
  will likewise continue to exist, safely nestled inside their respective
  hashes, but now untended by any object. In other words, when an inside-
  out object dies, its associated attribute hashes leak memory.
  
  The solution is simple. Every inside-out class has to provide a
  destructor that "manually" cleans up the attributes of the object being
  destructed:
  
      package File::Hierarchy;
      {
          # Objects of this class have the following attributes...
          my %root_of;   # The root directory of the file hierarchy
          my %files_of;  # Array storing object for each file in root directory
          
          # Constructor takes path of file system root directory...
          sub new {
              # As before
          }
          
          # Retrieve files from root directory...
          sub get_files {
              # As before
          }
  
          # Clean up attributes when object is destroyed...
          sub DESTROY {
              my ($self) = @_;
  
              delete $root_of{ident $self};
              delete $files_of{ident $self};
          }
      }
  
  The obligation to provide a destructor like this in every inside-out
  class can be mildly irritating, but it is still a very small price to
  pay for the considerable benefits that the inside-out approach otherwise
  provides for free. And the irritation can easily be eliminated by using
  the appropriate class construction tools. See below.
  
  =head2 Automating Inside-Out Classes
  
  Perhaps the most annoying part about building classes in Perl (no matter how
  the objects are implemented) is that the basic structure of every class is 
  more or less identical. For example, the implementation of the
  C<File::Hierarchy::File> class used in C<File::Hierarchy> looks like this:
  
      package File::Hierarchy::File;
      {    
          # Objects of this class have the following attributes...
          my %name_of;  # the name of the file
          
          # Constructor takes name of file...
          sub new {
              my ($class, $filename) = @_;
          
              # Bless a scalar to instantiate the new object...
              my $new_object = bless \do{my $anon_scalar}, $class;
          
              # Initialize the object's "name" attribute...
              $name_of{ident $new_object} = $filename;
          
              return $new_object;
          }
          
          # Retrieve name of file...
          sub get_name {
              my ($self) = @_;
          
              return $name_of{ident $self};
          }
  
          # Clean up attributes when object is destroyed...
          sub DESTROY {
              my ($self) = @_;
  
              delete $name_of{ident $self};
          }
      }
  
  Apart from the actual names of the attributes, and their accessor methods,
  that's exactly the same structure, and even the same code, as in the
  C<File::Hierarchy> class.
  
  Indeed, the standard infrastructure of I<every> inside-out class looks
  exactly the same. So it makes sense not to have to rewrite that standard
  infrastructure code in every separate class.
  
  That's precisely what this module does: it implements the necessary
  infrastructure for inside-out objects. See below.
  
  
  =head1 INTERFACE 
  
  =head2 Exported subroutines
  
  =over 
  
  =item C<ident()>
  
  Class::Std always exports a subroutine called C<ident()>. This subroutine
  returns a unique integer ID for any object passed to it. 
  
  =back
  
  =head2 Non-exported subroutines
  
  =over 
  
  =item C<Class::Std::initialize()>
  
  This subroutine sets up all the infrastructure to support your Class::Std-
  based class. It is usually called automatically in a C<CHECK> block, or
  (if the C<CHECK> block fails to run -- under C<mod_perl> or C<require
  Class::Std> or C<eval "...">) during the first constructor call made to
  a Class::Std-based object.
  
  In rare circumstances, you may need to call this subroutine directly yourself.
  Specifically, if you set up cumulative, restricted, private, or automethodical
  class methods (see below), and call any of them before you create any objects,
  then you need to call C<Class::Std::initialize()> first.
  
  =back
  
  =head2 Methods created automatically
  
  The following subroutines are installed in any class that uses the
  Class::Std module.
  
  =over
  
  =item C<new()>
  
  Every class that loads the Class::Std module automatically has a C<new()>
  constructor, which returns an inside-out object (i.e. a blessed scalar).
  
      $obj = MyClass->new();
  
  The constructor can be passed a single argument to initialize the
  object. This argument must be a hash reference. 
  
      $obj = MyClass->new({ name=>'Foo', location=>'bar' });
  
  See the subsequent descriptions of the C<BUILD()> and C<START()> methods
  and C<:ATTR()> trait, for an explanation of how the contents of this
  optional hash can be used to initialize the object.
  
  It is almost always an error to implement your own C<new()> in any class
  that uses Class::Std. You almost certainly want to write a C<BUILD()> or
  C<START()> method instead. See below.
  
  
  =item C<DESTROY()>
  
  Every class that loads the Class::Std module automatically has a C<DESTROY()>
  destructor, which automatically cleans up any attributes declared with the
  C<:ATTR()> trait (see below).
  
  It is almost always an error to write your own C<DESTROY()> in any class that
  uses Class::Std. You almost certainly want to write your own C<DEMOLISH()>
  instead. See below.
  
  
  =item C<AUTOLOAD()>
  
  Every class that loads the Class::Std module automatically has an
  C<AUTOLOAD()> method, which implements the C<AUTOMETHOD()> mechanism
  described below. 
  
  It is almost always an error to write your own C<AUTOLOAD()> in any class that
  uses Class::Std. You almost certainly want to write your own C<AUTOMETHOD()>
  instead.
  
  =item C<_DUMP()>
  
  This method returns a string that represents the internal state (i.e. the
  attribute values) of the object on which it's called. Only those attributes
  which are marked with an C<:ATTR> (see below) are reported. Attribute names
  are reported only if they can be ascertained from an C<:init_arg>, C<:get>, or
  C<:set> option within the C<:ATTR()>.
  
  Note that C<_DUMP()> is not designed to support full
  serialization/deserialization of objects. See the separate
  Class::Std::Storable module (on CPAN) for that.
  
  =back
  
  
  =head2 Methods that can be supplied by the developer
  
  The following subroutines can be specified as standard methods of a
  Class::Std class.
  
  =over
  
  =item C<BUILD()>
  
  When the C<new()> constructor of a Class::Std class is called, it
  automatically calls every method named C<BUILD()> in I<all> the classes
  in the new object's hierarchy. That is, when the constructor is called,
  it walks the class's inheritance tree (from base classes downwards) and
  calls every C<BUILD()> method it finds along the way.
  
  This means that, to initialize any class, you merely need to provide a
  C<BUILD()> method for that class. You don't have to worry about ensuring
  that any ancestral C<BUILD()> methods also get called; the constructor
  will take care of that.
  
  Each C<BUILD()> method is called with three arguments: the invocant object,
  the identifier number of that object, and a reference to (a customized version
  of) the hash of arguments that was originally passed to the constructor:
  
      sub BUILD {
          my ($self, $ident, $args_ref) = @_;
          ...
      }
  
  The argument hash is a "customized version" because the module
  automatically does some fancy footwork to ensure that the arguments are
  the ones appropriate to the class itself. That's because there's a
  potential for collisions when Class::Std classes are used in a
  hierarchy.
  
  One of the great advantages of using inside-out classes instead of hash-based
  classes is that an inside-out base class and an inside-out derived
  class can then each have an attribute of exactly the same name, which
  are stored in separate lexical hashes in separate scopes. In a hash-based
  object that's impossible, because the single hash can't have two
  attributes with the same key.
  
  But that very advantage also presents something of a problem when
  constructor arguments are themselves passed by hash. If two or more
  classes in the name hierarchy do happen to have attributes of the same
  name, the constructor will need two or more initializers with the name
  key. Which a single hash can't provide.
  
  The solution is to allow initializer values to be partitioned into
  distinct sets, each uniquely named, and which are then passed to the
  appropriate base class. The easiest way to accomplish that is to pass
  in a hash of hashes, where each top level key is the name of one of
  the base classes, and the corresponding value is a hash of
  initializers specifically for that base class. 
  
  For example:
  
      package Client;
      use Class::Std::Utils;
      {
          my %client_num_of :ATTR;  # Every client has a basic ID number
          my %name_of       :ATTR;
  
          sub BUILD {
              my ($self, $ident, $arg_ref) = @_;
  
              $client_num_of{$ident} = $arg_ref->{'Client'}{client_num};
              $name_of{$ident}       = $arg_ref->{'Client'}{client_name};
          }
      }
  
      package Client::Corporate;
      use base qw( Client );
      use Class::Std::Utils;
      {
          my %client_num_of;     # Corporate clients have an additional ID number
          my %corporation_of;
          my %position_of; 
  
          sub BUILD {
              my ($self, $ident, $arg_ref) = @_;
  
              $client_num_of{$ident} 
                  = $arg_ref->{'Client::Corporate'}{client_num};
              $corporation_of{$ident}
                  = $arg_ref->{'Client::Corporate'}{corp_name};
              $position_of{$ident}
                  = $arg_ref->{'Client::Corporate'}{position};
          }
      }
  
      # and later...
  
      my $new_client 
          = Client::Corporate->new( {
              'Client' => { 
                  client_num  => '124C1', 
                  client_name => 'Humperdinck',
              },
              'Client::Corporate' => { 
                  client_num  => 'F_1692', 
                  corp_name   => 'Florin', 
                  position    => 'CEO',
              },
          });
  
  Now each class's C<BUILD()> method picks out only the initializer sub-hash
  whose key is that class's own name. Since every class name is
  different, the top-level keys of this multi-level initializer hash are
  guaranteed to be unique. And since no single class can have two
  identically named attributes, the keys of each second-level hash will be
  unique as well. If two classes in the hierarchy both need an initializer
  of the same name (e.g. 'client_num'), those two hash entries will now be
  in separate sub-hashes, so they will never clash.
  
  Class::Std provides an even more sophisticated variation on this
  functionality, which is generally much more convenient for the users of
  classes. Classes that use Class::Std infrastructure allow both general
  and class-specific initializers in the initialization hash. Clients only
  need to specify classes for those initializers whose names actually are
  ambiguous. Any other arguments can just be passed directly in the
  top-level hash:
  
      my $new_client 
          = Client::Corporate->new( {
              client_name => 'Humperdinck',
              corp_name   => 'Florin', 
              position    => 'CEO',
  
              'Client'            => { client_num  => '124C1'  }, 
              'Client::Corporate' => { client_num  => 'F_1692' },
          });
  
  Class::Std also makes it easy for each class's C<BUILD()> to access
  these class-specific initializer values. Before each C<BUILD()> is
  invoked, the nested hash whose key is the same as the class name is
  flattened back into the initializer hash itself. That is, C<Client::BUILD()>
  is passed the hash:
  
      {
          client_name => 'Humperdinck',
          corp_name   => 'Florin', 
          position    => 'CEO',
          client_num  => '124C1',   # Flattened from 'Client' nested subhash
  
          'Client'            => { client_num  => '124C1'  }, 
          'Client::Corporate' => { client_num  => 'F_1692' },
      }
  
  whereas C<Client::Corporate::BUILD()> is passed the hash:
  
      {
          client_name => 'Humperdinck',
          corp_name   => 'Florin', 
          position    => 'CEO',
          client_num  => 'F_1692',   # Flattened from 'Client::Corporate' subhash
  
          'Client'            => { client_num  => '124C1'  }, 
          'Client::Corporate' => { client_num  => 'F_1692' },
      }
  
  This means that the C<BUILD()> method for each class can just assume that the
  correct class-specific initializer values will available at the top level of
  the hash. For example:
  
          sub Client::BUILD {
              my ($self, $ident, $arg_ref) = @_;
  
              $client_num_of{$ident} = $arg_ref->{client_num};    # '124C1'
              $name_of{$ident}       = $arg_ref->{client_name};
          }
  
          sub Client::Corporate::BUILD {
              my ($self, $ident, $arg_ref) = @_;
  
              $client_num_of{$ident}  = $arg_ref->{client_num};   # 'F_1692'
              $corporation_of{$ident} = $arg_ref->{corp_name};
              $position_of{$ident}    = $arg_ref->{position};
          }
  
  Both classes use the C<< $arg_ref->{client_num} >> initializer value, but
  Class::Std automatically arranges for that value to be the right one for each
  class.
  
  Also see the C<:ATTR()> marker (described below) for a simpler way of
  initializing attributes.
  
  
  =item C<START()>
  
  Once all the C<BUILD()> methods of a class have been called and any
  initialization values or defaults have been subsequently applied to
  uninitialized attributes, Class::Std arranges for any C<START()> methods
  in the class's hierarchy to be called befre the constructor finishes.
  That is, after the build and default initialization processes are
  complete, the constructor walks down the class's inheritance tree a
  second time and calls every C<START()> method it finds along the way.
  
  As with C<BUILD()>, each C<START()> method is called with three arguments:
  the invocant object, the identifier number of that object, and a
  reference to (a customized version of) the hash of arguments that was
  originally passed to the constructor.
  
  The main difference between a C<BUILD()> method and a C<START()> method
  is that a C<BUILD()> method runs before any attribute of the class is
  auto-initialized or default-initialized, whereas a C<START()> method
  runs after all the attributes of the class (including attributes in derived
  classes) have been initialized in some way. So if you want to pre-empt
  the initialization process, write a C<BUILD()>. But if you want to do
  something with the newly created and fully initialized object, write a
  C<START()> instead. Of course, any class can define I<both> a C<BUILD()>
  and a C<START()> method, if that happens to be appropriate.
  
  
  =item C<DEMOLISH()>
  
  The C<DESTROY()> method that is automatically provided by Class::Std ensures
  that all the marked attributes (see the C<:ATTR()> marker below) of an object,
  from all the classes in its inheritance hierarchy, are automatically cleaned
  up.
  
  But, if a class requires other destructor behaviours (e.g. closing
  filehandles, decrementing allocation counts, etc.) then you may need to
  specify those explicitly.
  
  Whenever an object of a Class::Std class is destroyed, the C<DESTROY()>
  method supplied by Class::Std automatically calls every method named
  C<DEMOLISH()> in I<all> the classes in the new object's hierarchy. That
  is, when the destructor is called, it walks the class's inheritance
  tree (from derived classes upwards) and calls every C<DEMOLISH()> method it
  finds along the way.
  
  This means that, to clean up any class, you merely need to provide a
  C<DEMOLISH()> method for that class. You don't have to worry about ensuring
  that any ancestral C<DEMOLISH()> methods also get called; the destructor
  will take care of that.
  
  Each C<DEMOLISH()> method is called with two arguments: the invocant object,
  and the identifier number of that object. For example:
  
      sub DEMOLISH {
          my ($self, $ident) = @_;
  
          $filehandle_of{$ident}->flush();
          $filehandle_of{$ident}->close();
      }
  
  Note that the attributes of the object are cleaned up I<after> the
  C<DEMOLISH()> method is complete, so they may still be used within
  that method.
  
  
  =item C<AUTOMETHOD()>
  
  There is a significant problem with Perl's built-in C<AUTOLOAD> mechanism:
  there's no way for a particular C<AUTOLOAD()> to say "no".
  
  If two or more classes in a class hierarchy have separate C<AUTOLOAD()>
  methods, then the one belonging to the left-most-depth-first class in
  the inheritance tree will always be invoked in preference to any others.
  If it can't handle a particular call, the call will probably fail
  catastrophically. This means that derived classes can't always be used
  in place of base classes (a feature known as "Liskov substitutability")
  because their inherited autoloading behaviour may be pre-empted by some
  other unrelated base class on their left in the hierarchy.
  
  Class::Std provides a mechanism that solves this problem: the
  C<AUTOMETHOD> method. An AUTOMETHOD() is expected to return either a
  handler subroutine that implements the requested method functionality,
  or else an C<undef> to indicate that it doesn't know how to handle the
  request. Class::Std then coordinates every C<AUTOMETHOD()> in an object's
  hierarchy, trying each one in turn until one of them produces a
  suitable handler.
  
  The advantage of this approach is that the first C<AUTOMETHOD()> that's
  invoked doesn't have to disenfranchise every other C<AUTOMETHOD()> in the
  hierarchy. If the first one can't handle a particular method call, it
  simply declines it and Class::Std tries the next candidate instead.
  
  Using C<AUTOMETHOD()> instead of C<AUTOLOAD()> makes a class
  cleaner, more robust, and less disruptive in class hierarchies.
  For example:
  
      package Phonebook;
      use Class::Std;
      {
          my %entries_of : ATTR;
  
          # Any method call is someone's name:
          # so store their phone number or get it...
          sub AUTOMETHOD {
              my ($self, $ident, $number) = @_;
  
              my $subname = $_;   # Requested subroutine name is passed via $_
  
              # Return failure if not a get_<name> or set_<name>
              # (Next AUTOMETHOD() in hierarchy will then be tried instead)...
              my ($mode, $name) = $subname =~ m/\A ([gs]et)_(.*) \z/xms
                  or return;
  
              # If get_<name>, return a handler that just returns the old number...
              return sub { return $entries_of{$ident}->{$name}; }
                  if $mode eq 'get';
  
              # Otherwise, set_<name>, so return a handler that
              # updates the entry and then returns the old number...
              return sub {
                  $entries_of{$ident}->{$name} = $number;
                  return;
              };
          }
      }
  
      # and later...
  
      my $lbb = Phonebook->new();
  
      $lbb->set_Jenny(867_5309);
      $lbb->set_Glenn(736_5000);
  
      print $lbb->get_Jenny(), "\n";
      print $lbb->get_Glenn(), "\n";
  
  Note that, unlike C<AUTOLOAD()>, an C<AUTOMETHOD()> is called with both the
  invocant and the invocant's unique C<ident> number, followed by the actual
  arguments that were passed to the method.
  
  Note too that the name of the method being called is passed as C<$_>
  instead of C<$AUTOLOAD>, and does I<not> have the class name prepended
  to it, so you don't have to strip that name off the front like almost
  everyone almost always does in their C<AUTOLOAD()>. If your C<AUTOMETHOD()>
  also needs to access the C<$_> from the caller's scope, that's still
  available as C<$CALLER::_>.
  
  =back
  
  
  =head2 Variable traits that can be ascribed
  
  The following markers can be added to the definition of any hash
  used as an attribute storage within a Class::Std class
  
  =over
  
  =item C<:ATTR()>
  
  This marker can be used to indicate that a lexical hash is being used
  to store one particular attribute of all the objects of the class. That is:
  
      package File::Hierarchy;
      {
          my %root_of  :ATTR;  
          my %files_of :ATTR;
          
          # etc.
      }
  
      package File::Hierarchy::File;
      {    
          my %name_of;  :ATTR;
  
          # etc.
      }
  
  Adding the C<:ATTR> marker to an attribute hash ensures that the corresponding 
  attribute belonging to each object of the class is automatically cleaned up 
  when the object is destroyed.
  
  The C<:ATTR> marker can also be given a number of options which automate
  other attribute-related behaviours. Each of these options consists of a
  key/value pair, which may be specified in either Perl 5 "fat comma" syntax
  ( C<< S<< key => 'value' >> >> ) or in one of the Perl 6 option syntaxes
  ( C<< S<< :key<value> >> >> or C<< S<< :key('value') >> >> or 
  C<< S<< :keyvalue >> >>).
  
  Note that, due to a limitation in Perl itself, the complete C<:ATTR> marker,
  including its options must appear on a single line.
  interpolate variables into the option values
  
  =over
  
  =item C<< :ATTR( :init_arg<initializer_key> ) >>
  
  This option tells Class::Std which key in the constructor's initializer hash
  holds the value with which the marked attribute should be initialized. That
  is, instead of writing:
  
      my %rank_of :ATTR;
  
      sub BUILD {
          my ($self, $ident, $arg_ref) = @_;
  
          $rank_of{$ident} = $arg_ref->{rank};
      }
  
  you can achieve the same initialization, by having Class::Std I<automatically>
  pull that entry out of the hash and store it in the right attribute:
  
      my %rank_of :ATTR( :init_arg<rank> );
  
      # No BUILD() method required
  
  
  =item C<< :ATTR( :default<compile_time_default_value> ) >>
  
  If a marked attribute is not initialized (either directly within a
  C<BUILD()>, or automatically via an C<:init_arg> option), the constructor
  supplied by Class::Std checks to see if a default value was specified
  for that attribute. If so, that value is assigned to the attribute.
  
  So you could replace:
  
      my %seen_of :ATTR;
  
      sub BUILD {
          my ($self, $ident, $arg_ref) = @_;
  
          $seen_of{$ident} = 0;  # Not seen yet
      }
  
  with:
  
      my %seen_of :ATTR( :default(0) );
  
      # No BUILD() required
  
  Note that only literal strings and numbers can be used as default values. A
  common mistake is to write:
  
      my %seen_of :ATTR( :default($some_variable) );
  
  But variables like this aren't interpolated into C<:ATTR> markers (this is a
  limitation of Perl, not Class::Std).
  
  If your attribute needs something more complex, you will have to default
  initialize it in a C<START()> method:
  
      my %seen_of :ATTR;
  
      sub START {
          my ($self, $id, $args_ref) = @_;
  
          if (!defined $seen_of{$id}) {
              $seen_of{$id} = $some_variable;
          }
      }
  
  =item C<< :ATTR( :get<name> ) >>
  
  If the C<:get> option is specified, a read accessor is created for the
  corresponding attribute. The name of the accessor is C<get_> followed by
  whatever name is specified as the value of the C<:get> option. For example,
  instead of:
  
      my %current_count_of :ATTR;
  
      sub get_count {
          my ($self) = @_;
  
          return $current_count_of{ident($self)};
      }
  
  you can just write:
  
      my %count_of :ATTR( :get<count> );
  
  Note that there is no way to prevent Class::Std adding the initial C<get_> to
  each accessor name it creates. That's what "standard" means. See Chapter 15
  of I<Perl Best Practices> (O'Reilly, 2005) for a full discussion on why
  accessors should be named this way.
  
  =item C<< :ATTR( :set<name> ) >>
  
  If the C<:set> option is specified, a write accessor is created for the
  corresponding attribute. The name of the accessor is C<set_> followed by
  whatever name is specified as the value of the C<:set> option. For example,
  instead of:
  
      my %current_count_of :ATTR;
  
      sub set_count {
          my ($self, $new_value) = @_;
  
          croak "Missing new value in call to 'set_count' method"
              unless @_ == 2;
  
          $current_count_of{ident($self)} = $new_value;
      }
  
  you can just write:
  
      my %count_of :ATTR( :set<count> );
  
  Note that there is no way to prevent Class::Std adding the initial
  C<set_> to each accessor name it creates. Nor is there any way to create
  a combined "getter/setter" accessor. See Chapter 15 of I<Perl Best
  Practices> (O'Reilly, 2005) for a full discussion on why accessors
  should be named and implemented this way.
  
  =item C<< :ATTR( :name<name> ) >>
  
  Specifying the C<:name> option is merely a convenient 
  shorthand for specifying all three of C<:get>, C<:set>, and C<:init_arg>.
  
  =back
  
  You can, of course, specify two or more arguments in a single C<:ATTR()>
  specification:
  
      my %rank_of : ATTR( :init_arg<starting_rank>  :get<rank>  :set<rank> );
  
  
  =item C<:ATTRS()>
  
  This is just another name for the C<:ATTR> marker (see above). The plural
  form is convenient when you want to specify a series of attribute hashes in
  the same statement:
  
      my (
          %name_of,
          %rank_of,
          %snum_of,
          %age_of,
          %unit_of,
          %assignment_of,
          %medals_of,
      ) : ATTRS;
  
  =back
  
  =head2 Method traits that can be ascribed
  
  The following markers can be added to the definition of any subroutine
  used as a method within a Class::Std class
  
  =over
  
  =item C<:RESTRICTED()>
  
  =item C<:PRIVATE()>
  
  Occasionally, it is useful to be able to create subroutines that can only be
  accessed within a class's own hierarchy (that is, by derived classes). And
  sometimes it's even more useful to be able to create methods that can only be
  called within a class itself.
  
  Typically these types of methods are I<utility> methods: subroutines
  that provide some internal service for a class, or a class hierarchy.
  Class::Std supports the creation of these kinds of methods by providing two
  special markers: C<:RESTRICTED()> and C<:PRIVATE()>.
  
  Methods marked C<:RESTRICTED()> are modified at the end of the
  compilation phase so that they throw an exception when called from
  outside a class's hierarchy. Methods marked C<:PRIVATE()> are modified
  so that they throw an exception when called from outside the class in
  which they're declared.
  
  For example:
  
      package DogTag;
      use Class::Std;
      {
          my %ID_of   : ATTR;
          my %rank_of : ATTR;
  
          my $ID_num = 0;
  
          sub _allocate_next_ID : RESTRICTED {
              my ($self) = @_;
              $ID_of{ident $self} = $ID_num++;
              return;
          }
  
          sub _check_rank : PRIVATE {
              my ($rank) = @_;
              return $rank if $VALID_RANK{$rank};
              croak "Unknown rank ($rank) specified";
          }
  
          sub BUILD {
              my ($self, $ident, $arg_ref) = @_;
  
              $self->_allocate_next_ID();
              $rank_of{$ident} = _check_rank($arg_ref->{rank});
          }
      }
  
  Of course, this code would run exactly the same without the C<:RESTRICTED()>
  and C<:PRIVATE()> markers, but they ensure that any attempt to call the two
  subroutines inappropriately:
  
      package main;
  
      my $dogtag = DogTag->new({ rank => 'PFC' });
  
      $dogtag->_allocate_next_ID();
  
  is suitably punished:
  
      Can't call restricted method DogTag::_allocate_next_ID() from class main
  
  
  =item C<:CUMULATIVE()>
  
  One of the most important advantages of using the C<BUILD()> and C<DEMOLISH()>
  mechanisms supplied by Class::Std is that those methods don't require
  nested calls to their ancestral methods, via the C<SUPER> pseudo-class. The
  constructor and destructor provided by Class::Std take care of the
  necessary redispatching automatically. Each C<BUILD()> method can focus
  solely on its own responsibilities; it doesn't have to also help
  orchestrate the cumulative constructor effects across the class
  hierarchy by remembering to call C<< $self->SUPER::BUILD() >>.
  
  Moreover, calls via C<SUPER> can only ever call the method of exactly one
  ancestral class, which is not sufficient under multiple inheritance.
  
  Class::Std provides a different way of creating methods whose effects
  accumulate through a class hierarchy, in the same way as those of
  C<BUILD()> and C<DEMOLISH()> do. Specifically, the module allows you to define
  your own "cumulative methods".
  
  An ordinary non-cumulative method hides any method of the same name
  inherited from any base class, so when a non-cumulative method is
  called, only the most-derived version of it is ever invoked. In
  contrast, a cumulative method doesn't hide ancestral methods of the same
  name; it assimilates them. When a cumulative method is called, the
  most-derived version of it is invoked, then any parental versions, then any
  grandparental versions, etc. etc, until every cumulative method of the
  same name throughout the entire hierarchy has been called.
  
  For example, you could define a cumulative C<describe()> method to the various
  classes in a simple class hierarchy like so:
  
      package Wax::Floor;
      use Class::Std;
      {
          my %name_of    :ATTR( init_arg => 'name'   );
          my %patent_of  :ATTR( init_arg => 'patent' );
  
          sub describe :CUMULATIVE {
              my ($self) = @_;
  
              print "The floor wax $name_of{ident $self} ",
                    "(patent: $patent_of{ident $self})\n";
  
              return;
          }
      }
  
      package Topping::Dessert;
      use Class::Std;
      {
          my %name_of     :ATTR( init_arg => 'name'    );
          my %flavour_of  :ATTR( init_arg => 'flavour' );
  
          sub describe :CUMULATIVE {
              my ($self) = @_;
  
              print "The dessert topping $name_of{ident $self} ",
                    "with that great $flavour_of{ident $self} taste!\n";
  
              return;
          }
      }
  
      package Shimmer;
      use base qw( Wax::Floor  Topping::Dessert );
      use Class::Std;
      {
          my %name_of    :ATTR( init_arg => 'name'   );
          my %patent_of  :ATTR( init_arg => 'patent' );
  
          sub describe :CUMULATIVE {
              my ($self) = @_;
  
              print "New $name_of{ident $self} ",
                    "(patent: $patent_of{ident $self})\n",
                    "Combining...\n";
  
              return;
          }
      }
  
  Because the various C<describe()> methods are marked as being cumulative, a
  subsequent call to:
  
      my $product 
          = Shimmer->new({
                name    => 'Shimmer',
                patent  => 1562516251,
                flavour => 'Vanilla',
            });
  
      $product->describe();
  
  will work its way up through the classes of Shimmer's inheritance tree
  (in the same order as a destructor call would), calling each C<describe()>
  method it finds along the way. So the single call to C<describe()> would
  invoke the corresponding method in each class, producing:
  
      New Shimmer (patent: 1562516251)
      Combining...
      The floor wax Shimmer (patent: 1562516251)
      The dessert topping Shimmer with that great Vanilla taste!
  
  Note that the accumulation of C<describe()> methods is hierarchical, and
  dynamic in nature. That is, each class only sees those cumulative
  methods that are defined in its own package or in one of its ancestors.
  So calling the same C<describe()> on a base class object:
  
      my $wax 
          = Wax::Floor->new({ name=>'Shimmer ', patent=>1562516251 });
  
      $wax->describe();
  
  only invokes the corresponding cumulative methods from that point on up
  the hierarchy, and hence only prints:
  
      The floor wax Shimmer (patent: 1562516251)
  
  Cumulative methods also accumulate their return values. In a list
  context, they return a (flattened) list that accumulates the lists
  returned by each individual method invoked.
  
  In a scalar context, a set of cumulative methods returns an object that,
  in a string context, concatenates individual scalar returns to produce a
  single string. When used as an array reference that same scalar-context-return
  object acts like an array of the list context values. When used as a hash
  reference, the object acts like a hash whose keys are the classnames from the
  object's hierarchy, and whose corresponding values are the return values of
  the cumulative method from that class.
  
  For example, if the classes each have a cumulative method that returns
  their list of sales features:
  
      package Wax::Floor;
      use Class::Std;
      {
          sub feature_list :CUMULATIVE {
              return ('Long-lasting', 'Non-toxic', 'Polymer-based');
          }
      }
  
      package Topping::Dessert;
      use Class::Std;
      {
          sub feature_list :CUMULATIVE {
              return ('Low-carb', 'Non-dairy', 'Sugar-free');
          }
      }
  
      package Shimmer;
      use Class::Std;
      use base qw( Wax::Floor  Topping::Dessert );
      {
          sub feature_list :CUMULATIVE {
              return ('Multi-purpose', 'Time-saving', 'Easy-to-use');
          }
      }
  
  then calling feature_list() in a list context:
  
      my @features = Shimmer->feature_list();
      print "Shimmer is the @features alternative!\n";
  
  would produce a concatenated list of features, which could then be
  interpolated into a suitable sales-pitch:
  
      Shimmer is the Multi-purpose Time-saving Easy-to-use
      Long-lasting Non-toxic Polymer-based Low-carb Non-dairy
      Sugar-free alternative!
  
  It's also possible to specify a set of cumulative methods that
  start at the base class(es) of the hierarchy and work downwards, the way
  BUILD() does. To get that effect, you simply mark each method with
  :CUMULATIVE(BASE FIRST), instead of just :CUMULATIVE. For example:
  
      package Wax::Floor;
      use Class::Std;
      {
          sub active_ingredients :CUMULATIVE(BASE FIRST) {
              return "\tparadichlorobenzene, cyanoacrylate, peanuts\n";
          }
      }
  
      package Topping::Dessert;
      use Class::Std;
      {
          sub active_ingredients :CUMULATIVE(BASE FIRST) {
              return "\tsodium hypochlorite, isobutyl ketone, ethylene glycol\n";
          }
      }
  
      package Shimmer;
      use Class::Std;
      use base qw( Wax::Floor  Topping::Dessert );
  
      {
          sub active_ingredients :CUMULATIVE(BASE FIRST) {
              return "\taromatic hydrocarbons, xylene, methyl mercaptan\n";
          }
      }
  
  So a scalar-context call to active_ingredients():
  
      my $ingredients = Shimmer->active_ingredients();
      print "May contain trace amounts of:\n$ingredients";
  
  would start in the base classes and work downwards, concatenating base-
  class ingredients before those of the derived class, to produce:
  
      May contain trace amounts of:
          paradichlorobenzene, cyanoacrylate, peanuts
          sodium hypochlorite, isobutyl ketone, ethylene glycol
          aromatic hydrocarbons, xylene, methyl mercaptan
  
  Or, you could treat the return value as a hash:
  
      print Data::Dumper::Dumper \%{$ingredients};
  
  and see which ingredients came from where:
  
      $VAR1 = {
         'Shimmer'
              => 'aromatic hydrocarbons, xylene, methyl mercaptan',
  
         'Topping::Dessert'
              => 'sodium hypochlorite, isobutyl ketone, ethylene glycol',
  
          'Wax::Floor'
              => 'Wax: paradichlorobenzene,  hydrogen peroxide, cyanoacrylate',
      };
  
  Note that you can't specify both C<:CUMULATIVE> and C<:CUMULATIVE(BASE
  FIRST)> on methods of the same name in the same hierarchy. The resulting
  set of methods would have no well-defined invocation order, so
  Class::Std throws a compile-time exception instead.
  
  
  =item C<:STRINGIFY>
  
  If you define a method and add the C<:STRINGIFY> marker then that method
  is used whenever an object of the corresponding class needs to be
  coerced to a string. In other words, instead of:
  
      # Convert object to a string...
      sub as_str {
          ...
      }
  
      # Convert object to a string automatically in string contexts...
      use overload (
          q{""}    => 'as_str',
          fallback => 1,
      );
  
  you can just write:
  
      # Convert object to a string (automatically in string contexts)...
      sub as_str : STRINGIFY {
          ...
      }
  
  
  =item C<:NUMERIFY>
  
  If you define a method and add the C<:NUMERIFY> marker then that method
  is used whenever an object of the corresponding class needs to be
  coerced to a number. In other words, instead of:
  
      # Convert object to a number...
      sub as_num {
          ...
      }
  
      # Convert object to a string automatically in string contexts...
      use overload (
          q{0+}    => 'as_num',
          fallback => 1,
      );
  
  you can just write:
  
      # Convert object to a number (automatically in numeric contexts)...
      sub as_num : NUMERIFY {
          ...
      }
  
  
  =item C<:BOOLIFY>
  
  If you define a method and add the C<:BOOLIFY> marker then that method
  is used whenever an object of the corresponding class needs to be
  coerced to a boolean value. In other words, instead of:
  
      # Convert object to a boolean...
      sub as_bool {
          ...
      }
  
      # Convert object to a boolean automatically in boolean contexts...
      use overload (
          q{bool}    => 'as_bool',
          fallback => 1,
      );
  
  you can just write:
  
      # Convert object to a boolean (automatically in boolean contexts)...
      sub as_bool : BOOLIFY {
          ...
      }
  
  
  =item C<:SCALARIFY>
  
  =item C<:ARRAYIFY>
  
  =item C<:HASHIFY>
  
  =item C<:GLOBIFY>
  
  =item C<:CODIFY>
  
  If a method is defined with one of these markers, then it is automatically
  called whenever an object of that class is treated as a reference of the
  corresponding type.
  
  For example, instead of:
  
      sub as_hash {
          my ($self) = @_;
  
          return {
              age      => $age_of{ident $self},
              shoesize => $shoe_of{ident $self},
          };
      }
  
      use overload (
          '%{}'    => 'as_hash',
          fallback => 1,
      );
  
  you can just write:
  
      sub as_hash : HASHIFY {
          my ($self) = @_;
  
          return {
              age      => $age_of{ident $self},
              shoesize => $shoe_of{ident $self},
          };
      }
  
  Likewise for methods that allow an object to be treated as a scalar
  reference (C<:SCALARIFY>), a array reference (C<:ARRAYIFY>), a
  subroutine reference (C<:CODIFY>), or a typeglob reference
  (C<:GLOBIFY>).
  
  =back
  
  
  =head1 DIAGNOSTICS
  
  =over 
  
  =item Can't find class %s
  
  You tried to call the Class::Std::new() constructor on a class 
  that isn't built using Class::Std. Did you forget to write C<use Class::Std>
  after the package declaration?
  
  =item Argument to %s->new() must be hash reference
  
  The constructors created by Class::Std require all initializer values
  to be passed in a hash, but you passed something that wasn't a hash.
  Put your constructor arguments in a hash.
  
  =item Missing initializer label for %s: %s
  
  You specified that one or more attributes had initializer values (using the
  C<init> argument inside the attribute's C<ATTR> marker), but then failed
  to pass in the corresponding initialization value. Often this happens because
  the initialization value I<was> passed, but the key specifying the
  attribute name was misspelled.
  
  =item Can't make anonymous subroutine cumulative
  
  You attempted to use the C<:CUMULATIVE> marker on an anonymous subroutine.
  But that marker can only be applied to the named methods of a class. Convert
  the anonymous subroutine to a named subroutine, or find some other way to 
  make it interoperate with other methods.
  
  =item Conflicting definitions for cumulative method: %s
  
  You defined a C<:CUMULATIVE> and a C<:CUMULATIVE(BASE FIRST)> method of the
  same name in two classes within the same hierarchy. Since methods can only be
  called going strictly up through the hierarchy or going strictly down 
  through the hierarchy, specifying both directions is obviously a mistake.
  Either rename one of the methods, or decide whether they should accumulate
  upwards or downwards.
  
  =item Missing new value in call to 'set_%s' method
  
  You called an attribute setter method without providing a new value 
  for the attribute. Often this happens because you passed an array that
  happened to be empty. Make sure you pass an actual value.
  
  =item Can't locate %s method "%s" via package %s
  
  You attempted to call a method on an object but no such method is defined
  anywhere in the object's class hierarchy. Did you misspell the method name, or
  perhaps misunderstand which class the object belongs to?
  
  =item %s method %s declared but not defined
  
  A method was declared with a C<:RESTRICTED> or C<:PRIVATE>, like so:
  
      sub foo :RESTRICTED;
      sub bar :PRIVATE;
  
  But the actual subroutine was not defined by the end of the compilation
  phase, when the module needed it so it could be rewritten to restrict or
  privatize it.
  
  
  =item Can't call restricted method %s from class %s
  
  The specified method was declared with a C<:RESTRICTED> marker but
  subsequently called from outside its class hierarchy. Did you call the
  wrong method, or the right method from the wrong place?
  
  
  =item Can't call private method %s from class %s
  
  The specified method was declared with a C<:PRIVATE> marker but
  subsequently called from outside its own class. Did you call the wrong
  method, or the right method from the wrong place?
  
  
  =item Internal error: %s
  
  Your code is okay, but it uncovered a bug in the Class::Std module.
  L<BUGS AND LIMITATIONS> explains how to report the problem.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  Class::Std requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  Class::Std depends on the following modules:
  
  =over
  
  =item *
  
  version
  
  =item *
  
  Scalar::Util
  
  =item *
  
  Data::Dumper
  
  =back
  
  
  =head1 INCOMPATIBILITIES
  
  Incompatible with the Attribute::Handlers module, since both define
  meta-attributes named :ATTR.
  
  
  =head1 BUGS AND LIMITATIONS
  
  =over
  
  =item *
  
  Does not handle threading (including C<fork()> under Windows).
  
  =item *
  
  C<:ATTR> declarations must all be on the same line (due to a limitation in
  Perl itself).
  
  =item *
  
  C<:ATTR> declarations cannot include variables, since these are not
  interpolated into the declaration (a limitation in Perl itself).
  
  =back
  
  Please report any bugs or feature requests to
  C<bug-class-std@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 ALTERNATIVES
  
  Inside-out objects are gaining in popularity and there are now many other
  modules that implement frameworks for building inside-out classes. These
  include:
  
  =over
  
  =item Object::InsideOut
  
  Array-based objects, with support for threading. Many excellent features
  (especially thread-safety), but slightly less secure than Class::Std,
  due to non-encapsulation of attribute data addressing.
  
  =item Class::InsideOut
  
  A minimalist approach to building inside-out classes.
  
  =item Lexical::Attributes
  
  Uses source filters to provide a near-Perl 6 approach to declaring inside-out
  classes.
  
  =item Class::Std::Storable
  
  Adds serialization/deserialization to Class::Std.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  Portions of the documentation from "Perl Best Practices" copyright (c)
  2005 by O'Reilly Media, Inc. and reprinted with permission.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
  
CLASS_STD

$fatpacked{"Config/Std.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_STD';
  package Config::Std;
  
  our $VERSION = '0.901';
  
  require v5.7.3; # RT#21184
  
  my %global_def_sep;
  my %global_inter_gap;
  
  sub import {
      my ($package, $opt_ref) = @_;
      my $caller = caller();
      $global_def_sep{$caller} = $opt_ref->{def_sep};
      $global_inter_gap{$caller} = $opt_ref->{def_gap};
      for my $sub_name (qw( read_config write_config )) {
          $opt_ref->{$sub_name} ||= $sub_name;
      }
      *{$caller.'::'.$opt_ref->{read_config}}  = \&Config::Std::Hash::read_config;
      *{$caller.'::'.$opt_ref->{write_config}} = \&Config::Std::Hash::write_config;
  }
  
  package Config::Std::Gap;
  use Class::Std;
  {
      sub serialize { return "\n" }
      sub update  {}
      sub extend  {}
      sub copy_to {}
  }
  
  package Config::Std::Comment;
  use Class::Std;
  {
      my %text_of : ATTR( :init_arg<text> );
  
      sub serialize {
          my ($self) = @_;
          return $text_of{ident $self};
      }
  
      sub append_comment {
          my ($self, $new_text) = @_;
          $text_of{ident $self} .= $new_text;
      }
  
      sub update  {}
      sub extend  {}
      sub copy_to {}
  }
  
  package Config::Std::Keyval;
  use Class::Std;
  {
      my %key_of      : ATTR( :init_arg<key> :get<key> );
      my %vals_of     : ATTR;
      my %deleted_of  : ATTR;
  
      sub BUILD {
          my ($self, $ident, $arg_ref) = @_;
  
          $vals_of{$ident}     = [ { %{$arg_ref} } ];
      }
  
      my %SEPARATOR = ( ':' => ': ', '=' => ' = ' );
  
      use Carp;
  
      sub serialize {
          my ($self, $def_sep, $block_name) = @_;
          my $ident = ident $self;
  
          return "" if $deleted_of{$ident};
  
          my ($key, $vals) = ($key_of{$ident}, $vals_of{$ident});
  
          my $keyspace = q{ } x length($key);
  
          my $serialization = q{};
  
          for $n (0..$#{$vals}) {
              my ($val,$sep,$comm) = @{$vals->[$n]}{qw(val sep comm)};
  
              my $val_type = ref $val;
              croak qq{Can't save \L$val_type\E ref as value for key {'$block_name'}{'$key'} (only scalars or array refs)}
                  if $val_type && $val_type ne 'ARRAY';
  
              $sep = $SEPARATOR{$sep || $def_sep};
  
              my @vals = $val_type eq 'ARRAY' ? @{$val} : $val;
              s/ (?!\Z) \n /\n$keyspace$sep/gxms for @vals;
  
              $serialization .= $comm || q{};
  
              $serialization .= join q{}, map {"$key$sep$_\n"} @vals;
          }
  
          return $serialization;
      }
  
      sub update { 
          my ($self, $hash_ref, $updated_ref) = @_;
          my $ident = ident $self;
  
          my $key = $key_of{$ident};
  
          if (!exists $hash_ref->{$key}) {
              $deleted_of{$ident} = 1;
          }
          else {
              my $val = $hash_ref->{$key};
              @newvals = ref $val eq 'ARRAY' ? @{$val} : $val;
              for my $n (0..$#newvals) {
                  $vals_of{$ident}[$n]{val} = $newvals[$n];
              }
              splice @{$vals_of{$ident}}, scalar @newvals;
          }
  
          $updated_ref->{$key} = 1;
  
          return 1;
      }
  
      sub copy_to {
          my ($self, $hash_ref)  = @_;
          my $ident = ident $self;
          my @vals = map $_->{val}, @{$vals_of{$ident}};
          $hash_ref->{$key_of{$ident}} = @vals > 1 ? \@vals : $vals[0];
      }
  
      sub multivalue {
          my ($self, $sep, $val, $comm) = @_;
          push @{$vals_of{ident $self}}, {val=>$val, sep=>$sep, comm=>$comm};
      }
  }
  
  package Config::Std::Block;
  use Class::Std;
  {
      my %name_of         : ATTR( :init_arg<name> :get<name> default => '' );
      my %sep_count_of    : ATTR;
      my %precomm_of      : ATTR( :init_arg<precomm> default => '' );
      my %parcomm_of      : ATTR( :init_arg<parcomm> default => '' );
      my %components_of   : ATTR;
      my %deleted_of      : ATTR;
      my %seen            : ATTR;
      my %is_first        : ATTR( :init_arg<first> default => '' );
  
      sub BUILD {
          my ($self, $ident) = @_;
          @{$sep_count_of{$ident}}{':','='} = (0,0);
          $components_of{$ident} = [];
          $seen{$ident} = {};
      }
  
      sub copy_to {
          my ($self, $hash_ref) = @_;
          my $ident = ident $self;
  
          my $keyvals = $hash_ref->{$name_of{$ident}} ||= {};
  
          for my $comp ( @{$components_of{$ident}} ) {
              $comp->copy_to($keyvals);
          }
  
          $hash_ref->{$name_of{$ident}} = $keyvals;
      }
  
      sub serialize {
          my ($self, $first, $caller, $post_gap, $inter_gap) = @_;
          my $ident = ident $self;
  
          return q{} if $deleted_of{$ident};
  
          my $is_anon = $first && length($name_of{$ident}) == 0;
  
          my $serialization = q{};
          if (!$is_anon) {
              $serialization = ($precomm_of{$ident} || q{})
                             . "[$name_of{$ident}]"
                             . (defined $parcomm_of{$ident}?$parcomm_of{$ident}:q{})
                             . "\n";
          }
  
          my $gds = $global_def_sep{$caller};
          my $def_sep
              = defined $gds                                             ? $gds
              : $sep_count_of{$ident}{':'} >= $sep_count_of{$ident}{'='} ? ':'
              :                                                            '='
              ;
  
          $self->ensure_gap() if $inter_gap && !$is_anon;
  
          for my $comp ( @{$components_of{$ident}} ) {
              $serialization .= $comp->serialize($def_sep, $name_of{$ident});
          }
  
          return $serialization;
      }
  
      sub update {
          my ($self, $hash_ref, $updated_ref) = @_;
          my $ident = ident $self;
  
          if (!defined $hash_ref) {
              $deleted_of{$ident} = 1;
              return;
          }
  
          for my $comp ( @{$components_of{$ident}} ) {
              $comp->update($hash_ref, $updated_ref) or next;
          }
      }
  
      sub extend {
          my ($self, $hash_ref, $updated_ref, $post_gap, $inter_gap) = @_;
  
          # Only the first occurrence of a block has new keys added...
          return unless $is_first{ident $self};
  
          my $first = 1;
  	# RT 85956 
          for my $key ( sort grep {!$updated_ref->{$_}} keys %{$hash_ref}) {
              my $value = $hash_ref->{$key};
              my $separate = ref $value || $value =~ m/\n./xms;
              $self->ensure_gap() if ($first ? $post_gap : $inter_gap)
                                      || $separate;
              $self->add_keyval($key, undef, $hash_ref->{$key});
              $self->add_gap() if $separate;
              $first = 0;
          }
      }
  
      sub ensure_gap {
          my ($self) = @_;
          my $comp_ref = $components_of{ident $self};
          return if @{$comp_ref} && $comp_ref->[-1]->isa('Config::Std::Gap');
          push @{$comp_ref}, Config::Std::Gap->new();
      }
  
      sub add_gap {
          my ($self) = @_;
          push @{$components_of{ident $self}}, Config::Std::Gap->new();
      }
  
      sub add_comment {
          my ($self, $text) = @_;
          my $comp_ref = $components_of{ident $self};
          if ($comp_ref && @{$comp_ref} && $comp_ref->[-1]->isa('Config::Std::Comment') ) {
              $comp_ref->[-1]->append_comment($text);
          }
          else {
              push @{$comp_ref}, Config::Std::Comment->new({text=>$text});
          }
      }
  
      sub add_keyval {
          my ($self, $key, $sep, $val, $comm) = @_;
          my $ident = ident $self;
  
          $sep_count_of{$ident}{$sep}++ if $sep;
  
          my $seen = $seen{$ident};
  
          if ($seen->{$key}) {
              $seen->{$key}->multivalue($sep, $val, $comm);
              return;
          }
  
          my $keyval 
              = Config::Std::Keyval->new({key=>$key, sep=>$sep, val=>$val, comm=>$comm});
          push @{$components_of{$ident}}, $keyval;
          $seen->{$key} = $keyval;
      }
  }
  
  package Config::Std::Hash;
  use Class::Std;
  {
  
      use Carp;
      use Fcntl ':flock';     # import LOCK_* constants
  
      my %post_section_gap_for :ATTR;
      my %array_rep_for        :ATTR;
      my %filename_for         :ATTR;
  
      sub write_config (\[%$];$) {
          my ($hash_ref, $filename) = @_;
          $hash_ref = ${$hash_ref} if ref $hash_ref eq 'REF';
  
          $filename = $filename_for{$hash_ref} if @_<2;
  
          croak "Missing filename for call to write_config()"
              unless $filename;
  
          my $caller = caller;
  
          my $inter_gap
              = exists $global_inter_gap{$caller} ? $global_inter_gap{$caller}
              :                                      1;
          my $post_gap
              = $post_section_gap_for{$hash_ref}
              || (defined $global_inter_gap{$caller} ? $global_inter_gap{$caller}
                                                     : 1
                 );
  
          # Update existing keyvals in each block...
          my %updated;
          for my $block ( @{$array_rep_for{$hash_ref}} ) {
              my $block_name = $block->get_name();
              $block->update($hash_ref->{$block_name}, $updated{$block_name}||={});
          }
  
          # Add new keyvals to the first section of block...
          for my $block ( @{$array_rep_for{$hash_ref}} ) {
              my $block_name = $block->get_name();
              $block->extend($hash_ref->{$block_name}, $updated{$block_name},
                             $post_gap, inter_gap
                            );
          }
  
          # Add new blocks at the end...
          for my $block_name ( sort grep {!$updated{$_}} keys %{$hash_ref} ) {
              my $block = Config::Std::Block->new({name=>$block_name});
              my $subhash = $hash_ref->{$block_name};
              my $first = 1;
  	    # RT 85956
              for my $key ( sort keys %{$subhash} ) {
                  if (!defined $subhash->{$key}) {
                      croak "Can't save undefined value for key {'$block_name'}{'$key'} (only scalars or array refs)";
                  }
                  my $value = $subhash->{$key};
                  my $separate = ref $value || $value =~ m/\n./xms;
                  $block->ensure_gap() if ($first ? $post_gap : $inter_gap)
                                       || $separate;
                  $block->add_keyval($key, undef, $value);
                  $block->add_gap() if $separate;
                  $first = 0;
              }
              $block->ensure_gap();
              push @{$array_rep_for{$hash_ref}}, $block;
          }
  
          open my $fh, '>', $filename
              or croak "Can't open config file '$filename' for writing (\L$!\E)";
  
          flock($fh,LOCK_EX|LOCK_NB)
              || croak "Can't write to locked config file '$filename'"
                  if ! ref $filename;
  
          my $first = 1;
          for my $block ( @{$array_rep_for{$hash_ref}} ) {
              print {$fh} $block->serialize($first, scalar caller, $post_gap);
              $first = 0;
          }
  
          flock($fh,LOCK_UN) if ! ref $filename;
  
          return 1;
      }
  
      sub read_config ($\[%$]) {
          my ($filename, $var_ref, $opt_ref) = @_;
          my $var_type = ref($var_ref) || q{};
          my $hash_ref;
          if ($var_type eq 'SCALAR' && !defined ${$var_ref} ) {
              ${$var_ref} = $hash_ref = {};
          }
          elsif ($var_type eq 'HASH') {
              $hash_ref = $var_ref;
          }
          else {
              croak q{Scalar second argument to 'read_config' must be empty};
          }
  
          bless $hash_ref, 'Config::Std::Hash';
  
          my $blocks = $array_rep_for{$hash_ref}
                     = _load_config_for($filename, $hash_ref);
  
          for my $block ( @{$blocks} ) {
              $block->copy_to($hash_ref);
          }
  
          $filename_for{$hash_ref} = $filename;
  
          # Remove initial empty section if no data...
          if (!keys %{ $hash_ref->{q{}} }) {
              delete $hash_ref->{q{}};
          }
  
          return 1;
      }
  
      sub _load_config_for {
          my ($filename, $hash_ref) = @_;
  
          open my $fh, '<', $filename
              or croak "Can't open config file '$filename' (\L$!\E)";
          flock($fh,LOCK_SH|LOCK_NB)
              || croak "Can't read from locked config file '$filename'"
                  if !ref $filename;
          my $text = do{local $/; <$fh>};
          flock($fh,LOCK_UN) if !ref $filename;
  
          my @config_file = Config::Std::Block->new({ name=>q{}, first=>1 });
          my $comment = q{};
          my %seen;
  
          # Start tracking whether section markers have gaps after them...
          $post_section_gap_for{$hash_ref} = 0;
  
          for ($text) {
              pos = 0;
              while (pos() < length() ) {
                  # Gap...
                  if (m/\G (?: [^\S\n]* (?:\n|\z)+)/gcxms) {
                      ### Found gap
                      $config_file[-1]->add_comment($comment) if $comment;
                      $config_file[-1]->add_gap();
                      $comment = q{};
                  }
  
                  # Comment...
                  elsif (m/\G (\s* [#;] [^\n]* (?:\n|\z) )/gcxms) {
                      ### Found comment: $1
                      $comment .= $1;
                  }
  
                  # Block...
                  elsif (m/\G ([^\S\n]*) [[]  ( [^]\n]* ) []] ( ([^\S\n]*) [#;] [^\n]* )? [^\S\n]* (?:\n|\z)/gcxms) {
                      my ($pre, $name, $parcomm, $ws) = ($1, $2, $3, $4);
                      ### Found block: $name
                      if ($parcomm) {
                          $pre = 2 + length($pre) + length($name) + length($ws);
                          if (m/\G ( (?: \n? [ ]{$pre,} [#] [^\n]* )+ )/gcxms) {
                              $parcomm .= "\n$1";
                          }
                      }
                      push @config_file,
                              Config::Std::Block->new({
                                  name    => $name,
                                  precomm => $comment,
                                  parcomm => $parcomm,
                                  first   => !$seen{$name}++,
                              });
                      $comment = q{};
  
                      # Check for trailing gap...
                      $post_section_gap_for{$hash_ref}
                          += m/\G (?= [^\S\n]* (?:\n|\z) )/xms ? +1 : -1;
                  }
  
                  # Key/value...
                  elsif (m/\G [^\S\n]* ([^=:\n]+?) [^\S\n]* ([:=] [^\S\n]*) ([^\n]*) (?:\n|\z)/gcxms) {
                      my ($key, $sep, $val) = ($1, $2, $3);
  
                      my $pure_sep = $sep;
                      $pure_sep =~ s/\s*//g;
  
                      # Continuation lines...
                      my $continued = 0;
                      while (m/\G [^\S\n]* \Q$sep\E ([^\n]*) (?:\n|\z) /gcxms
                         ||  m/\G [^\S\n]* \Q$pure_sep\E ([^\n]*) (?:\n|\z) /gcxms
                      ) {
                          $val .= "\n$1";
                          $continued = 1;
                      }
  
                      $val =~ s/\A \s*|\s* \z//gxms if !$continued;
  
                      ### Found kv: $key, $val
  
                      $config_file[-1]->add_keyval($key, $pure_sep, $val,
                      $comment); $comment = q{}; }
  
                  # Mystery...
                  else {
                      my ($problem) = m/\G ([^\n]{10,40}|.{10}) /gcxms;
                      die "Error in config file '$filename' near:\n\n\t$problem\n";
                  }
              }
          }
  
          return \@config_file;
      }
  
  }
  
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  Config::Std - Load and save configuration files in a standard format
  
  
  =head1 VERSION
  
  This document describes Config::Std version 0.901
  
  
  =head1 SYNOPSIS
  
      use Config::Std;
  
      # Load named config file into specified hash...
      read_config 'demo2.cfg' => my %config;
  
      # Extract the value of a key/value pair from a specified section...
      $config_value = $config{Section_label}{key};
  
      # Change (or create) the value of a key/value pair...
      $config{Other_section_label}{other_key} = $new_val;
  
      # Update the config file from which this hash was loaded...
      write_config %config;
  
      # Write the config information to another file as well...
      write_config %config, $other_file_name;
  
    
  =head1 DESCRIPTION
  
  This module implements yet another damn configuration-file system.
  
  The configuration language is deliberately simple and limited, and the
  module works hard to preserve as much information (section order,
  comments, etc.) as possible when a configuration file is updated.
  
  The whole point of Config::Std is to encourage use of one standard layout
  and syntax in config files. Damian says "I could have gotten away with it, I would have
  only allowed one separator. But it proved impossible to choose between C<:> and C<=>
  (half the people I asked wanted one, half wanted the other)." 
  Providing round-trip file re-write is the spoonful of sugar to help the medicine go down.
  The supported syntax is within the general INI file family 
  
  See Chapter 19 of "Perl Best Practices" (O'Reilly, 2005) 
  for more detail on the
  rationale for this approach. 
  
  =head2 Configuration language
  
  The configuration language is a slight extension of the Windows INI format.
  
  =head3 Comments
  
  A comment starts with a C<#> character (Perl-style) or a C<;> character
  (INI-style), and runs to the end of the same line:
  
      # This is a comment
  
      ; Ywis, eke hight thilke
  
  Comments can be placed almost anywhere in a configuration file, except inside
  a section label, or in the key or value of a configuration variable:
  
      # Valid comment
      [ # Not a comment, just a weird section label ]
  
      ; Valid comment
      key: value  ; Not a comment, just part of the value
  
  NOTE BENE -- that last is a BAD EXAMPLE of what is NOT supported. 
  This module supports full-line comments only, not on same line with semantic content.
  
  =head3 Sections
  
  A configuration file consists of one or more I<sections>, each of which is
  introduced by a label in square brackets:
  
      [SECTION1]        # Almost anything is a valid section label
  
      [SECTION 2]       # Internal whitespace is allowed (except newlines)
  
      [%^$%^&!!!]       # The label doesn't have to be alphanumeric
  
      [ETC. ETC. AS MANY AS YOU WANT]
  
  The only restriction on section labels is that they must be by
  themselves on a single line (except for any surrounding whitespace or
  trailing comments), and they cannot contain the character C<]>.
  
  Every line after a given section label until the next section label (or
  the end of the config file) belongs to the given section label. If no
  section label is currently in effect, the current section has an empty
  label. In other words, there is an implicit:
  
      []                # Label is the empty string
  
  at the start of each config file.
  
  =head3 Configuration variables
  
  Each non-empty line within a section must consist of the specification of a
  I<configuration variable>. Each such variable consists of a key and a string
  value. For example:
  
      name: George
       age: 47
  
      his weight! : 185
  
  The key consists of every character (including internal whitespace) from
  the start of the line until the key/value separator. So, the previous
  example declares three keys: C<'name'>, C<'age'>, and C<'his weight!'>.
  
  Note that whitespace before and after the key is removed. This makes it easier
  to format keys cleanly:
  
             name : George
              age : 47
      his weight! : 185
  
  The key/value separator can be either a colon (as above) or an equals sign,
  like so:
  
             name= George
              age=  47
      his weight! = 185
  
  Both types of separators can be used in the same file, but neither can
  be used as part of a key. Newlines are not allowed in keys either.
  
  When writing out a config file, Config::Std tries to preserve whichever
  separator was used in the original data (if that data was read
  in). New data 
  (created by code not parsed by C<read_config>)
  is written back with a colon as its default separator,
  unless you specify the only other separator value C<'='> when the module is loaded:
  
      use Config::Std { def_sep => '=' };
  
  Note that this does not change read-in parsing, 
  does not change punctuation for values that were parsed, 
  and will not allow values other than C<'='> or C<':'>.
  
  Everything from the first non-whitespace character after the separator,
  up to the end of the line, is treated as the value for the config variable.
  So all of the above examples define the same three values: C<'George'>,
  C<'47'>, and C<'185'>.
  
  In other words, any whitespace immediately surrounding the separator
  character is part of the separator, not part of the key or value.
  
  Note that you can't put a comment on the same line as a configuration
  variable. The C<# etc.> is simply considered part of the value:
  
      [Delimiters]
  
      block delims:    { }
      string delims:   " "
      comment delims:  # \n
  
  You can comment a config var on the preceding or succeeding line:
  
      [Delimiters]
  
      # Use braces to delimit blocks...
      block delims:    { }
  
      # Use double quotes to delimit strings
  
      string delims:   " "
  
      # Use octothorpe/newline to delimit comments
      comment delims:  # \n
      
  
  =head3 Multi-line configuration values
  
  A single value can be continued over two or more lines. If the line
  immediately after a configuration variable starts with the separator
  character used in the variable's definition, then the value of the
  variable continues on that line. For example:
  
      address: 742 Evergreen Terrace
             : Springfield
             : USA
  
  The newlines then form part of the value, so the value specified in the
  previous example is: C<S<"742 Evergreen Terrace\nSpringfield\nUSA">>
  
  Note that the second and subsequent lines of a continued value are considered
  to start where the whitespace after the I<original> separator finished, not
  where the whitespace after their own separator finishes. For example, if the
  previous example had been:
  
      address: 742 Evergreen Terrace
             :   Springfield
             :     USA
  
  then the value would be:
  
      "742 Evergreen Terrace\n  Springfield\n    USA"
  
  If a continuation line has less leading whitespace that the first line:
  
      address:   742 Evergreen Terrace
             :  Springfield
             : USA
  
  it's treated as having no leading whitespace:
  
      "742 Evergreen Terrace\nSpringfield\nUSA"
  
  
  =head3 Multi-part configuration values
  
  If the particular key appears more than once in the same section, it is
  considered to be part of the same configuration variable. The value of
  that configuration value is then a list, containing all the individual
  values for each instance of the key. For example, given the definition:
  
      cast: Homer
      cast: Marge
      cast: Lisa
      cast: Bart
      cast: Maggie
  
  the corresponding value of the C<'cast'> configuration variable is:
  C<S<['Homer', 'Marge', 'Lisa', 'Bart', 'Maggie']>>
  
  Individual values in a multi-part list can also be multi-line (see
  above). For example, given:
  
      extras: Moe
            : (the bartender)
  
      extras: Smithers
            : (the dogsbody)
  
  the value for the C<'extras'> config variable is:
  C<S<["Moe\n(the bartender)", "Smithers\n(the dogsbody)"]>>
  
  
  =head2 Internal representation
  
  Each section label in a configuration file becomes a top-level hash key whe
  the configuration file is read in. The corresponding value is a nested hash
  reference.
  
  Each configuration variable's key becomes a key in that nested hash reference.
  Each configuration variable's value becomes the corresponding value in that nested hash reference.
  
  Single-line and multi-line values become strings. Multi-part values become
  references to arrays of strings.
  
  For example, the following configuration file:
  
      # A simple key (just an identifier)...
      simple : simple value
  
      # A more complex key (with whitespace)...
      more complex key : more complex value
  
      # A new section...
      [MULTI-WHATEVERS]
  
      # A value spread over several lines...
      multi-line : this is line 1
                 : this is line 2
                 : this is line 3
  
      # Several values for the same key...
      multi-value: this is value 1
      multi-value: this is value 2
      multi-value: this is value 3
  
  would be read into a hash whose internal structure looked like this:
  
      {
         # Default section...
         '' => {
            'simple'           => 'simple value',
            'more complex key' => 'more complex value',
         },
  
         # Named section...
         'MULTI-WHATEVERS' => {
              'multi-line'  => "this is line 1\nthis is line 2\nthis is line 3",
  
              'multi-value' => [ 'this is value 1',
                                 'this is value 2',
                                 'this is value 3'
                               ],
          }
      }
  
  
  =head1 INTERFACE 
  
  The following subroutines are exported automatically whenever the module is
  loaded...
  
  =over 
  
  =item C<< read_config($filename => %config_hash) >>
  
  =item C<< read_config($filename => $config_hash_ref) >>
  
  =item C<< read_config($string_ref => %config_hash_or_ref) >>
  
  The C<read_config()> subroutine takes two arguments: the filename of a
  configuration file, and a variable into which the contents of that
  configuration file are to be loaded.
  
  If the variable is a hash, then the configuration sections and their
  key/value pairs are loaded into nested subhashes of the hash.
  
  If the variable is a scalar with an undefined value, a reference to an
  anonymous hash is first assigned to that scalar, and that hash is then
  filled as described above.
  
  The subroutine returns true on success, and throws an exception on failure.
  
  If you pass a reference to the string as the first argument to
  C<read_config()> it uses that string as the source of the config info.
  For example:
  
  	use Config::Std;
  
  	# here we load the config text to a scalar
  	my $cfg = q{
  	[Section 1]
  	attr1 = at
  	attr2 = bat
  
  	[Section 2]
  	attr3 = cat
  	};
  
  	# here we parse the config from that scalar by passing a reference to it.
  	read_config( \$cfg, my %config );
  
  	use Data::Dumper 'Dumper';
  	warn Dumper [ \%config ];
  
  
  =item C<< write_config(%config_hash => $filename) >>
  
  =item C<< write_config($config_hash_ref => $filename) >>
  
  =item C<write_config(%config_hash)>
  
  =item C<write_config($config_hash_ref)>
  
  The C<write_config()> subroutine takes two arguments: the hash or hash
  reference containing the configuration data to be written out to disk,
  and an optional filename specifying which file it is to be written to.
  
  The data hash must conform to the two-level structure described earlier:
  with top-level keys naming sections and their values being references to
  second-level hashes that store the keys and values of the configuartion
  variables. If the structure of the hash differs from this, an exception is
  thrown.
  
  If a filename is also specified, the subroutine opens that file
  and writes to it. It no filename is specified, the subroutine uses the
  name of the file from which the hash was originally loaded using
  C<read_config()>. It no filename is specified and the hash I<wasn't>
  originally loaded using C<read_config()>, an exception is thrown.
  
  The subroutine returns true on success and throws and exception on failure.
  
  =back
  
  If necessary (typically to avoid conflicts with other modules), you can
  have the module export its two subroutines with different names by
  loading it with the appropriate options:
  
      use Config::Std { read_config => 'get_ini', write_config => 'update_ini' };
  
      # and later...
  
      get_ini($filename => %config_hash);
  
      # and later still...
  
      update_ini(%config_hash);
  
  You can also control how much spacing the module puts between single-
  line values when they are first written to a file, by using the
  C<def_gap> option:
  
      # No empty line between single-line config values...
      use Config::Std { def_gap => 0 }; 
  
      # An empty line between all single-line config values...
      use Config::Std { def_gap => 1 }; 
  
  Regardless of the value passed for C<def_gap>, new multi-line values are
  always written with an empty line above and below them. Likewise, values
  that were previously read in from a file are always written back with
  whatever spacing they originally had.
  
  =head1 DIAGNOSTICS
  
  =over 
  
  =item Can't open config file '%s' (%s)
  
  You tried to read in a configuration file, but the file you specified
  didn't exist. Perhaps the filepath you specified was wrong. Or maybe 
  your application didn't have permission to access the file you specified.
  
  =item Can't read from locked config file '$filename'
  
  You tried to read in a configuration file, but the file you specified
  was being written by someone else (they had a file lock active on it).
  Either try again later, or work out who else is using the file.
  
  =item Scalar second argument to 'read_config' must be empty
  
  You passed a scalar variable as the destination into C<read_config()>
  was supposed to load a configuration file, but that variable already had
  a defined value, so C<read_config()> couldn't autovivify a new hash for
  you. Did you mean to pass the subroutine a hash instead of a scalar?
  
  =item Can't save %s value for key '%s' (only scalars or array refs)
  
  You called C<write_config> and passed it a hash containing a
  configuration variable whose value wasn't a single string, or a list of
  strings. The configuration file format supported by this module only
  supports those two data types as values. If you really need to store
  other kinds of data in a configuration file, you should consider using
  C<Data::Dumper> or C<YAML> instead.
  
  =item Missing filename in call to write_config()
  
  You tried to calll C<write_config()> with only a configuration hash, but that
  hash wasn't originally loaded using C<read_config()>, so C<write_config()> has
  no idea where to write it to. Either make sure the hash you're trying to save
  was originally loaded using C<read_config()>, or else provide an explicit
  filename as the second argument to C<write_config()>.
  
  =item Can't open config file '%s' for writing (%s)
  
  You tried to update or create a configuration file, but the file you
  specified could not be opened for writing (for the reason given in the
  parentheses). This is often caused by incorrect filepaths or lack of
  write permissions on a directory.
  
  =item Can't write to locked config file '%s'
  
  You tried to update or create a configuration file, but the file you
  specified was being written at the time by someone else (they had a file
  lock active on it). Either try again later, or work out who else is
  using the file.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  Config::Std requires no configuration files or environment variables.
  (To do so would be disturbingly recursive.)
  
  
  =head1 DEPENDENCIES
  
  This module requires the Class::Std module (available from the CPAN)
  
  
  =head1 INCOMPATIBILITIES
  
  Those variants of INI file dialect supporting partial-line comment are incompatible. 
  (This is the price of keeping comments when re-writing.)
  
  
  =head1 BUGS AND LIMITATIONS
  
  =over
  
  =item Loading on demand
  
  If you attempt to load C<read_config()> and C<write_config()> 
  at runtime with C<require>, you can not rely upon the prototype
  to convert a regular hash to a reference. To work around this, 
  you must explicitly pass a reference to the config hash.
  
      require Config::Std;
      Config::Std->import;
  
      my %config;
      read_config($file, \%config);
      write_config(\%config, $file);
  
  =item Windows line endings on Unix/Linux (RT#21547/23550)
  
  If the config file being read contains carriage returns and line feeds
  at the end of each line rather than just line feeds (i.e. the standard
  Windows file format, when read on a machine expecting POSIX file format),
  Config::Std emits an error with embedded newline.
  
  Workaround is match file line-endings to locale.
  
  This will be fixed in 1.000.
  
  
  =item leading comment vanishes (RT#24597,)
  
  A comment before the first section is not always retained on write-back, if the '' default section is empty.
  
  =item 00write.t test 5 fails on perl5.8.1 (RT#17425)
  
  Due to an incompatible change in v5.8.1 partially reversed in v5.8.2, hash key randomisation can cause test to fail in that one version of Perl. Workaround is export environment variable PERL_HASH_SEED=0.
  
  =back
  
  Please report any bugs or feature requests to
  C<bug-config-std@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  Maintainers 
  Bill Ricker    C<< <BRICKER@cpan.org> >>
  Tom Metro      C<< <tmetro@cpan.org> >>
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005, Damian Conway C<< <DCONWAY@cpan.org> >>. 
  Copyright (c) 2011, D.Conway, W.Ricker C<< <BRICKER@cpan.org> >> All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
CONFIG_STD

$fatpacked{"Contextual/Return.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN';
  package Contextual::Return;
  
  my %attrs_of;
  
  # Fake out CORE::GLOBAL::caller, Carp::*, and Scalar::Util::blessed() very early...
  BEGIN {
      no warnings 'redefine';
  
      my $fallback_caller = *CORE::GLOBAL::caller{CODE};
      *CORE::GLOBAL::caller = sub {
          my ($uplevels) = shift || 0;
          if (CORE::caller eq 'DB') {
              package DB;
              if ($fallback_caller) {
                  return $fallback_caller->($uplevels + 2 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  return $fallback_caller->($uplevels + 1);
              }
              else {
                  return CORE::caller($uplevels + 2 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  return CORE::caller($uplevels + 1);
              }
          }
          else {
              if ($fallback_caller) {
                  return $fallback_caller->($uplevels + 2 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  return $fallback_caller->($uplevels + 1);
              }
              else {
                  return CORE::caller($uplevels + 2 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  return CORE::caller($uplevels + 1);
              }
          }
      };
  
      use Carp;
      my $real_carp  = *Carp::carp{CODE};
      my $real_croak = *Carp::croak{CODE};
  
      *Carp::carp = sub {
          goto &{$real_carp} if !$Contextual::Return::uplevel;
          warn _in_context(@_);
      };
  
      *Carp::croak = sub {
          goto &{$real_croak} if !$Contextual::Return::uplevel;
          die _in_context(@_);
      };
  
      # Scalar::Util::blessed()...
      use Scalar::Util 'refaddr';
  
      # Remember the current blessed()...
      my $original_blessing = *Scalar::Util::blessed{CODE};
  
      # ...and replace it...
      *Scalar::Util::blessed = sub($) {
          # Are we operating on a CRV???
          my $attrs = $attrs_of{refaddr $_[0] or q{}};
  
          # If not, use the original code...
          goto &{$original_blessing} if !$attrs;
  
          # Does this object have a BLESSED handler???
          if (exists $attrs->{BLESSED}) {
              return $attrs->{BLESSED}->(@{$attrs->{args}});
          }
  
          # Otherwise, find the appropriate scalar handler...
          handler:
          for my $context (qw( OBJREF LAZY REF SCALAR VALUE NONVOID DEFAULT )) {
              my $handler = $attrs->{$context}
                  or next handler;
  
              my $obj_ref = eval { $handler->(@{$attrs->{args}}) };
  
              my $was_blessed = $original_blessing->($obj_ref);
              return $was_blessed if $was_blessed;
          }
  
          # Otherwise, simulate unblessed status...
          return undef;
      };
  }
  
  
  our $VERSION = '0.004007';
  
  use warnings;
  use strict;
  
  sub _in_context {
      my $msg = join q{}, @_;
  
      # Start looking in caller...
      my $stack_frame = 1;
      my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
      my ($orig_package, $prev_package) = ($package) x 2;
      my $LOC = qq{at $file line $line}; 
  
      # Walk up stack...
      STACK_FRAME:
      while (1) {
          my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
          # Fall off the top of the stack...
          last STACK_FRAME if !defined $package;
  
          # Ignore this module (and any helpers)...
          next STACK_FRAME if $package =~ m{^Contextual::Return}xms;
  
          # Track the call up the stack...
          $LOC = qq{at $file line $line}; 
  
          # Ignore any @CARP_NOT'ed packages
          next STACK_FRAME
              if do { no strict 'refs'; *{$package.'::CARP_NOT'}{ARRAY}; };
  
          # Ignore transitions within original caller...
          next STACK_FRAME
              if $package eq $orig_package && $prev_package eq $orig_package;
  
          # If we get a transition out of the original package, we're there...
          last STACK_FRAME;
      }
  
      # Insert location details...
      $msg =~ s/<LOC>/$LOC/g or $msg =~ s/[^\S\n]*$/ $LOC/;
      $msg =~ s/$/\n/;
      return $msg;
  }
  
  # Indentation corresponds to inherited fall-back relationships...
  my @CONTEXTS = qw(
      DEFAULT
          VOID
          NONVOID
              LIST
              SCALAR
                  VALUE
                      STR
                      NUM
                      BOOL
                          PUREBOOL
                  REF
                      SCALARREF
                      ARRAYREF
                      CODEREF
                      HASHREF
                      GLOBREF
                      OBJREF
                          METHOD
                          BLESSED
  );
  
  my @ALL_EXPORTS = (
      @CONTEXTS,
      qw(
          LAZY       RESULT      RVALUE      METHOD     FAIL
          FIXED      RECOVER     LVALUE      RETOBJ     FAIL_WITH
          ACTIVE     CLEANUP     NVALUE      STRICT     BLESSED
      )
  );
  
  my %STD_NAME_FOR = map { $_ => $_ } @ALL_EXPORTS;
  
  sub import {
      # Load utility module for failure handlers...
      if (require Contextual::Return::Failure) {
          *FAIL      = \&Contextual::Return::Failure::_FAIL;
          *FAIL_WITH = \&Contextual::Return::Failure::_FAIL_WITH;
      }
  
      # Don't need the package name...
      shift @_;
  
      # If args, export nothing by default; otherwise export all...
      my %exports = @_ ? () : %STD_NAME_FOR;
  
      # All args are export either selectors and/or renamers...
      while (my $selector = shift @_) {
          my $next_arg = $_[0];
          my $renamer = (defined $next_arg
                      && !ref $next_arg
                      && !exists $STD_NAME_FOR{$next_arg})
                          ? shift(@_)
                          : undef;
          %exports = (%exports, _add_exports_for($selector, $renamer));
      }
  
      # Loop through possible exports, exporting anything requested...
      my $caller = CORE::caller;
      EXPORT:
      for my $subname (keys %exports) {
          no strict qw( refs );
          *{$caller.'::'.$exports{$subname}} = \&{$subname};
      }
  };
  
  sub _add_exports_for {
      my ($selector, $renamer) = @_;
  
      # If no renamer, use original name...
      $renamer ||= '%s';
  
      # Handle different types of selector...
      my $selector_type = ref($selector) || 'literal';
  
      # Array selector recursively export each element...
      if ($selector_type eq 'ARRAY') {
          return map { _add_exports_for($_,$renamer) } @{$selector};
      }
      elsif ($selector_type eq 'Regexp') {
          my @selected = grep {/$selector/} @ALL_EXPORTS;
          if (!@selected) {
              Carp::carp("use Contextual::Return $selector didn't export anything");
          }
          return map { $_ => sprintf($renamer, $_) } @selected;
      }
      elsif ($selector_type eq 'literal') {
          Carp::croak "Can't export $selector: no such handler"
              if !exists $STD_NAME_FOR{$selector};
          return ( $selector => sprintf($renamer, $selector) );
      }
      else {
          Carp::croak "Can't use $selector_type as export specifier";
      }
  }
  
  
  # Let handlers access the result object they're inside...
  
  sub RETOBJ() {
      our $__RETOBJ__;
      return $__RETOBJ__;
  }
  
  
  use Scalar::Util qw( refaddr );
  
  # Override return value in a C::R handler...
  sub RESULT(;&) {
      my ($block) = @_;
  
      # Determine call context and arg list...
      my $context;
      my $args = do { package DB; $context=(CORE::caller 1)[5]; \@DB::args };
  
      # No args -> return appropriate value...
      if (!@_) {
          return $context ? @{ $Contextual::Return::__RESULT__ || [] }
                          :    $Contextual::Return::__RESULT__->[0]
                          ;
      }
  
      # Hide from caller() and the enclosing eval{}...
      
      # Evaluate block in context and cache result...
      local $Contextual::Return::uplevel = $Contextual::Return::uplevel+1;
      $Contextual::Return::__RESULT__
          =         $context  ? [        $block->(@{$args})      ]
          : defined $context  ? [ scalar $block->(@{$args}) ]
          :                     do {     $block->(@{$args}); [] }
          ;
  
      return;
  }
  
  sub RVALUE(&;@) :lvalue;
  sub LVALUE(&;@) :lvalue;
  sub NVALUE(&;@) :lvalue;
  
  my %opposite_of = (
      'RVALUE' => 'LVALUE or NVALUE',
      'LVALUE' => 'RVALUE or NVALUE',
      'NVALUE' => 'LVALUE or RVALUE',
  );
  
  
  BEGIN {
      for my $subname (qw( RVALUE LVALUE NVALUE) ) {
          no strict 'refs';
          *{$subname} = sub(&;@) :lvalue {    # (handler, return_lvalue);
              my $handler = shift;
              my $impl;
              my $args = do{ package DB; ()=CORE::caller(1); \@DB::args };
              if (@_==0) {
                  $impl = tie $_[0], 'Contextual::Return::Lvalue',
                      $subname => $handler, args=>$args;
              }
              elsif (@_==1 and $impl = tied $_[0]) {
                  die _in_context "Can't install two $subname handlers"
                      if exists $impl->{$subname};
                  $impl->{$subname} = $handler;
              }
              else {
                  my $vals = join q{, }, map { tied $_    ? keys %{tied $_}
                                             : defined $_ ? $_
                                             :              'undef'
                                             } @_;
                  die _in_context "Expected a $opposite_of{$subname} block ",
                                  "after the $subname block <LOC> ",
                                  "but found instead: $vals\n";
              }
  
              # Handle void context calls...
              if (!defined wantarray && $impl->{NVALUE}) {
                  # Fake out caller() and Carp...
                  local $Contextual::Return::uplevel = 1;
  
                  # Call and clear handler...
                  local $Contextual::Return::__RETOBJ__ = $impl;
                  $impl->{NVALUE}( @{$impl->{args}} );
                  delete $impl->{NVALUE};
              }
              $_[0];
          }
      }
  }
  
  for my $modifier_name (qw< STRICT FIXED ACTIVE >) {
      no strict 'refs';
      *{$modifier_name} = sub ($) {
          my ($crv) = @_;
          my $attrs = $attrs_of{refaddr $crv or q{}};
  
          # Track context...
          my $wantarray = wantarray;
          use Want;
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Remember the modification...
          $attrs->{$modifier_name} = 1;
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context} 
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last handler if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, let someone else handle it...
          return $crv;
      }
  }
  
  sub LIST (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !!(CORE::caller 1)[5] if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); \@DB::args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare LIST {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two LIST handlers"
          if exists $attrs->{LIST};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
  
      # Handle list context directly...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
  
          my @rv = eval { $block->(@{$attrs->{args}}) };
          if ($recover) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [@rv];
              }
              () = $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return @rv if !$Contextual::Return::__RESULT__;
          return @{$Contextual::Return::__RESULT__};
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          handler:
          for my $context (qw< VOID DEFAULT >) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              eval { $attrs->{$context}->(@{$attrs->{args}}) };
              if ($recover) {
                  $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
              last handler;
          }
          if ($attrs->{STRICT}) {
              $@ = _in_context "Can't call $attrs->{sub} in a void context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{LIST} = $block;
      return $crv;
  }
  
  
  sub VOID (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !defined( (CORE::caller 1)[5] ) if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); \@DB::args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare VOID {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two VOID handlers"
          if exists $attrs->{VOID};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
  
      # Handle list context directly, if possible...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
          # List or ancestral handlers...
          handler:
          for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
              my $handler = $attrs->{$context} 
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              my @rv = eval { $handler->(@{$attrs->{args}}) };
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [@rv];
                  }
                  () = $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              return @rv if !$Contextual::Return::__RESULT__;
              return @{$Contextual::Return::__RESULT__};
          }
          # Convert to list from arrayref handler...
          if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
              my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [$array_ref];
                  }
                  scalar $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              # Array ref may be returned directly, or via RESULT{}...
              $array_ref = $Contextual::Return::__RESULT__->[0]
                  if $Contextual::Return::__RESULT__;
  
              return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
          }
          # Return scalar object as one-elem list, if possible...
          handler:
          for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
              last handler if $attrs->{STRICT};
              return $crv if exists $attrs->{$context};
          }
          $@ = _in_context "Can't call $attrs->{sub} in a list context";
          if ($recover) {
              () = $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          eval { $block->(@{$attrs->{args}}) };
  
          if ($recover) {
              $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{VOID} = $block;
      return $crv;
  }
  
  for my $context (qw( SCALAR NONVOID )) {
      no strict qw( refs );
      *{$context} = sub (;&$) {
          my ($block, $crv) = @_;
  
          # Handle simple context tests...
          if (!@_) {
              my $callers_context = (CORE::caller 1)[5];
              return defined $callers_context
                  && ($context eq 'NONVOID' || !$callers_context);
          }
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); \@DB::args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                      = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          die _in_context "Can't install two $context handlers"
              if exists $attrs->{$context};
          $attrs->{$context} = $block;
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context} 
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
  
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              die _in_context "Can't call $attrs->{sub} in a list context";
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  handler:
  for my $context_name (@CONTEXTS, qw< RECOVER _internal_LIST CLEANUP >) {
      next handler if $context_name eq 'LIST'       # These
                   || $context_name eq 'VOID'       #  four
                   || $context_name eq 'SCALAR'     #   handled
                   || $context_name eq 'NONVOID';   #    separately
  
      no strict qw( refs );
      *{$context_name} = sub (&;$) {
          my ($block, $crv) = @_;
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); \@DB::args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context_name {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                       = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          if ($context_name ne '_internal_LIST') {
              die _in_context "Can't install two $context_name handlers"
                  if exists $attrs->{$context_name};
              $attrs->{$context_name} = $block;
          }
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__
                  = $context_name eq 'RECOVER' ? $Contextual::Return::__RESULT__
                  :                              undef
                  ;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  local $Contextual::Return::uplevel = 2;
  
                  # Array ref may be returned directly, or via RESULT{}...
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw(VOID DEFAULT)) {
                  if (!$attrs->{$context}) {
                      last handler if $attrs->{STRICT};
                      next handler;
                  }
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  # Alias LAZY to SCALAR...
  *LAZY = *SCALAR;
  
  
  # Set $Data::Dumper::Freezer to 'Contextual::Return::FREEZE' to be able to
  # dump contextual return values...
  
  my %operator_impl;
  
  my $no_handler_message = qr{
      ^ Can't [ ] call [ ] .*? [ ] in [ ] [\w]+ [ ] context
    | ^ [\w:]+ [ ] can't [ ] return [ ] a [ ] \w+ [ ] reference
  }xms;
  
  sub _flag_self_ref_in {
      my ($data_ref, $obj_ref) = @_;
      my $type = ref $data_ref;
      return if !$type;
      for my $value ( $type eq 'SCALAR' ? ${$data_ref} : @{$data_ref} ) {
          no warnings 'numeric', 'uninitialized';
          if ($value == $obj_ref) {
              $value = '<<<self-reference>>>';
          }
      }
  }
  
  sub FREEZE {
      my ($self) = @_;
      my $attrs_ref = $attrs_of{refaddr $self};
      my $args_ref  = $attrs_ref->{args};
  
      my @no_handler;
  
      # Call appropriate operator handler, defusing and recording exceptions...
      my $overloaded = sub {
          my ($context, $op) = @_;
  
          # Try the operator...
          my $retval = eval { $operator_impl{$op}->($self,@{$args_ref}) };
  
          # Detect and report internal exceptions...
          if (my $exception = $@) {
              if ($exception =~ $no_handler_message) {
                  push @no_handler, $context;
                  return ();
              }
              return { $context => "<<<Throws exception: $exception>>>" };
          }
  
          # Detect self-referential overloadings (to avoid infinite recursion)...
          {
              no warnings 'numeric', 'uninitialized';
              if (ref $retval eq 'REF' && ${$retval} == ${$self}) {
                  return { $context => "<<<self-reference>>>" };
              }
          }
  
          # Normal return of contextual value labelled by context...
          return { $context => $retval };
      };
  
      my @values;
  
      # Where did this value originate?
      push @values, { ISA  => 'Contextual::Return::Value' };
      push @values, { FROM => $attrs_ref->{sub} };
  
      # Does it return a value in void context?
      if (exists $attrs_ref->{VOID} || exists $attrs_ref->{DEFAULT}) {
          push @values, { VOID => undef };
      }
      else {
          push @no_handler, 'VOID';
      }
  
      # Generate list context value by "pretend" LIST handler...
      push @values, { LIST => [ _internal_LIST(sub{}, $self) ] };
          _flag_self_ref_in($values[-1]{LIST}, $self);
  
      # Generate scalar context values by calling appropriate handler...
      push @values, $overloaded->( STR       => q{""}  );
      push @values, $overloaded->( NUM       => '0+'   );
      push @values, $overloaded->( BOOL      => 'bool' );
      push @values, $overloaded->( SCALARREF => '${}'  );
          _flag_self_ref_in($values[-1]{SCALARREF}, $self);
      push @values, $overloaded->( ARRAYREF  => '@{}'  );
          _flag_self_ref_in($values[-1]{ARRAYREF}, $self);
      push @values, $overloaded->( CODEREF   => '&{}'  );
      push @values, $overloaded->( HASHREF   => '%{}'  );
      push @values, $overloaded->( GLOBREF   => '*{}'  );
  
      # Are there handlers for various "generic" super-contexts...
      my @fallbacks = grep { $attrs_ref->{$_} }
                         qw< DEFAULT NONVOID SCALAR VALUE REF RECOVER >;
      
      push @values, { NO_HANDLER => \@no_handler };
      push @values, { FALLBACKS  => \@fallbacks  };
  
      # Temporarily replace object being dumped, by values found...
      $_[0] = \@values;
  }
  
  # Call this method on a contextual return value object to debug it...
  
  sub DUMP {
      if (require Data::Dumper) {
          my ($crv) = @_;
          FREEZE($crv);
          return Data::Dumper::Dumper($crv);
      }
      else {
          Carp::carp("Can't DUMP contextual return value (no Data::Dumper!)");
          return;
      }
  }
  
  
  package Contextual::Return::Value;
  BEGIN { *_in_context = *Contextual::Return::_in_context; }
  use Scalar::Util qw( refaddr );
  
  BEGIN {
      %operator_impl = (
          q{""} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(STR SCALAR LAZY VALUE NONVOID DEFAULT NUM)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a string";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{0+} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(NUM SCALAR LAZY VALUE NONVOID DEFAULT STR)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a number";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{bool} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              my $attrs = $attrs_of{refaddr $self};
  
              # Handle Calls in Pure Boolean context...
              my @PUREBOOL = $attrs->{want_pure_bool} ? ('PUREBOOL') : ();
              $attrs->{want_pure_bool} = 0;
  
              handler:
              for my $context (@PUREBOOL, qw(BOOL STR NUM SCALAR LAZY VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $context eq 'BOOL' and $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $outer_sig_warn = $SIG{__WARN__};
                  local $SIG{__WARN__}
                      = sub{ return if $_[0] =~ /^Exiting \S+ via next/;
                             goto &{$outer_sig_warn} if $outer_sig_warn;
                             warn @_;
                        };
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a boolean";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '${}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(SCALARREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the scalar dereference"
                          if ref($rv) ne 'SCALAR' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return a scalar reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              if ( $attrs->{FIXED} ) {
                  $_[0] = \$self;
              }
              return \$self;
          },
          '@{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              my $attrs = $attrs_of{refaddr $self};
              local $Contextual::Return::__RESULT__;
              handler:
              for my $context (qw(ARRAYREF REF)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the array dereference"
                          if ref($rv) ne 'ARRAY' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  last handler if $attrs->{STRICT};
                  my $handler = $attrs->{$context}
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      @rv = @{$Contextual::Return::__RESULT__->[0]};
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = \@rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { @rv };
                  }
                  return \@rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return an array reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              return [ $self ];
          },
          '%{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(HASHREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the hash dereference"
                          if ref($rv) ne 'HASH' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a hash reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '&{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(CODEREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the subroutine dereference"
                          if ref($rv) ne 'CODE' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a subroutine reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '*{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(GLOBREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the typeglob dereference"
                          if ref($rv) ne 'GLOB' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a typeglob reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
      );
  }
  
  use overload %operator_impl, fallback => 1;
  
  sub DESTROY {
      my ($id) = refaddr shift;
      my $attrs = $attrs_of{$id};
      if (my $handler = $attrs->{CLEANUP}) {
          $handler->(@{ $attrs->{args} });
      }
      delete $attrs_of{$id};
      return;
  }
  
  my $NO_SUCH_METHOD = qr/\ACan't (?:locate|call)(?: class| object)? method/ms;
  
  # Forward metainformation requests to actual class...
  sub can {
      my ($invocant) = @_;
      # Only forward requests on actual C::R::V objects...
      if (ref $invocant) {
          our $AUTOLOAD = 'can';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::can(@_[1..$#_]);
  }
  
  sub isa {
      # Only forward requests on actual C::R::V objects...
      my ($invocant) = @_;
      if (ref $invocant) {
          our $AUTOLOAD = 'isa';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::isa(@_[1..$#_]);
  }
  
  
  sub AUTOLOAD {
      my ($self) = @_;
      our $AUTOLOAD;
  
      my ($requested_method) = $AUTOLOAD =~ m{ .* :: (.*) }xms ? $1 : $AUTOLOAD;
  
      my $attrs = $attrs_of{refaddr $self} || {};
      local $Contextual::Return::__RETOBJ__ = $self;
  
      # First, see if there is a method call handler...
      if (my $context_handler = $attrs->{METHOD}) {
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my @method_handlers = eval { $context_handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [\@method_handlers];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              @method_handlers = @{$Contextual::Return::__RESULT__};
          }
  
          # Locate the correct method handler (if any)...
          MATCHER:
          while (my ($matcher, $method_handler) = splice @method_handlers, 0, 2) {
  
              if (ref($matcher) eq 'ARRAY') {
                  next MATCHER
                      if !grep { $requested_method =~ $_ } @{$matcher};
              }
              elsif ($requested_method !~ $matcher) {
                  next MATCHER;
              }
  
              shift;
              if (wantarray) {
                  my @result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return @result;
              }
              else {
                  my $result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return $result;
              }
          }
      }
  
      # Next, try to create an object on which to call the method...
      handler:
      for my $context (qw(OBJREF STR SCALAR LAZY VALUE NONVOID DEFAULT)) {
          my $handler = $attrs->{$context}
              or $attrs->{STRICT} and last handler
              or next handler;
  
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my $object = eval { $handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [$object];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              $object = $Contextual::Return::__RESULT__->[0];
          }
  
          if ( $attrs->{FIXED} ) {
              $_[0] = $object;
          }
          elsif ( !$attrs->{ACTIVE} ) {
              $attrs->{$context} = sub { $object };
          }
          shift;
  
          if (wantarray) {
              my @result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return @result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          else {
              my $result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return $result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          $@ = _in_context "Can't call method '$requested_method' on $context value returned by $attrs->{sub}";
          if (my $recover = $attrs->{RECOVER}) {
              scalar $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Otherwise, the method cannot be called, so react accordingly...
      $@ = _in_context "Can't call method '$requested_method' on value returned by $attrs->{sub}";
      if (my $recover = $attrs->{RECOVER}) {
          return scalar $recover->(@{$attrs->{args}});
      }
      else {
          die $@;
      }
  }
  
  package Contextual::Return::Lvalue;
  
  sub TIESCALAR {
      my ($package, @handler) = @_;
      return bless {@handler}, $package;
  }
  
  # Handle calls that are lvalues...
  sub STORE {
      local *CALLER::_ = \$_;
      local *_         = \$_[1];
      local $Contextual::Return::uplevel = 1;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{LVALUE}( @{$_[0]{args}} );
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  # Handle calls that are rvalues...
  sub FETCH {
      local $Contextual::Return::uplevel = 1;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{RVALUE} ? $_[0]{RVALUE}( @{$_[0]{args}} ) : undef;
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  sub DESTROY {};
  
  1; # Magic true value required at end of module
  
  __END__
  
  =head1 NAME
  
  Contextual::Return - Create context-sensitive return values
  
  
  =head1 VERSION
  
  This document describes Contextual::Return version 0.004007
  
  
  =head1 SYNOPSIS
  
      use Contextual::Return;
      use Carp;
  
      sub foo {
          return
              SCALAR { 'thirty-twelve' }
              LIST   { 1,2,3 }
  
              BOOL { 1 }
              NUM  { 7*6 }
              STR  { 'forty-two' }
  
              HASHREF  { {name => 'foo', value => 99} }
              ARRAYREF { [3,2,1] }
  
              GLOBREF  { \*STDOUT }
              CODEREF  { croak "Don't use this result as code!"; }
          ;
      }
  
      # and later...
  
      if (my $foo = foo()) {
          for my $count (1..$foo) {
              print "$count: $foo is:\n"
                  . "  array: @{$foo}\n"
                  . "  hash:  $foo->{name} => $foo->{value}\n"
                  ;
          }
          print {$foo} $foo->();
      }
  
  =head1 DESCRIPTION
  
  Usually, when you need to create a subroutine that returns different values in
  different contexts (list, scalar, or void), you write something like:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data,
          # depending on call context...
          if (wantarray()) {
              return @server_data{ qw(name uptime load users) };
          }
          if (defined wantarray()) {
              return $server_data{load};
          }
          if (!defined wantarray()) {
              carp 'Useless use of get_server_status() in void context';
              return;
          }
          else {
              croak q{Bad context! No biscuit!};
          }
      }
  
  That works okay, but the code could certainly be more readable. In
  its simplest usage, this module makes that code more readable by
  providing three subroutines--C<LIST()>, C<SCALAR()>, C<VOID()>--that
  are true only when the current subroutine is called in the
  corresponding context:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          if (LIST)   { return @server_data{ qw(name uptime load users) } }
          if (SCALAR) { return $server_data{load}                         }
          if (VOID)   { print "$server_data{load}\n"                      }
          else        { croak q{Bad context! No biscuit!}                 }
      }
  
  =head2 Contextual returns
  
  Those three subroutines can also be used in another way: as labels on a
  series of I<contextual return blocks> (collectively known as a I<contextual
  return sequence>). When a context sequence is returned, it automatically
  selects the appropriate contextual return block for the calling context.
  So the previous example could be written even more cleanly as:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
              LIST    { return @server_data{ qw(name uptime load users) } }
              SCALAR  { return $server_data{load}                         }
              VOID    { print "$server_data{load}\n"                      }
              DEFAULT { croak q{Bad context! No biscuit!}                 }
          );
      }
  
  The context sequence automatically selects the appropriate block for each call
  context.
  
  
  =head2 Lazy contextual return values
  
  C<LIST> and C<VOID> blocks are always executed during the C<return>
  statement. However, scalar return blocks (C<SCALAR>, C<STR>, C<NUM>,
  C<BOOL>, etc.) blocks are not. Instead, returning any of scalar block
  types causes the subroutine to return an object that lazily
  evaluates that block only when the return value is used.
  
  This means that returning a C<SCALAR> block is a convenient way to
  implement a subroutine with a lazy return value. For example:
  
      sub digest {
          return SCALAR {
              my ($text) = @_;
              md5($text);
          }
      }
  
      my $digest = digest($text);
  
      print $digest;   # md5() called only when $digest used as string
  
  To better document this usage, the C<SCALAR> block has a synonym: C<LAZY>.
  
      sub digest {
          return LAZY {
              my ($text) = @_;
              md5($text);
          }
      }
  
  
  =head2 Active contextual return values
  
  Once a return value has been lazily evaluated in a given context, 
  the resulting value is cached, and thereafter reused in that same context.
  
  However, you can specify that, rather than being cached, the value
  should be re-evaluated I<every> time the value is used:
  
       sub make_counter {
          my $counter = 0;
          return ACTIVE
              SCALAR   { ++$counter }
              ARRAYREF { [1..$counter] }
      } 
              
      my $idx = make_counter();
          
      print "$idx\n";      # 1
      print "$idx\n";      # 2
      print "[@$idx]\n";   # [1 2]
      print "$idx\n";      # 3
      print "[@$idx]\n";   # [1 2 3]
  
   
  =head2 Semi-lazy contextual return values
  
  Sometimes, single or repeated lazy evaluation of a scalar return value
  in different contexts isn't what you really want. Sometimes what you
  really want is for the return value to be lazily evaluated once only (the
  first time it's used in any context), and then for that first value to
  be reused whenever the return value is subsequently reevaluated in any
  other context.
  
  To get that behaviour, you can use the C<FIXED> modifier, which causes
  the return value to morph itself into the actual value the first time it
  is used. For example:
  
      sub lazy {
          return
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $lazy = lazy();
      print $lazy + 1;            # 43
      print "@{$lazy}";           # 1 2 3
  
  
      sub semilazy {
          return FIXED
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $semi = semilazy();
      print $semi + 1;            # 43
      print "@{$semi}";           # die q{Can't use string ("42") as an ARRAY ref}
  
  
  
  =head2 Finer distinctions of scalar context
  
  Because the scalar values returned from a context sequence are lazily
  evaluated, it becomes possible to be more specific about I<what kind> of
  scalar value should be returned: a boolean, a number, or a string. To support
  those distinctions, Contextual::Return provides four extra context blocks:
  C<NUM>, C<STR>, C<BOOL>, and C<PUREBOOL>:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }          }
             PUREBOOL { $_ = $server_data{uptime}; $server_data{uptime} > 0 }
                 BOOL { $server_data{uptime} > 0                            }
                 NUM  { $server_data{load}                                  }
                 STR  { "$server_data{name}: $server_data{uptime}"          }
                 VOID { print "$server_data{load}\n"                        }
              DEFAULT { croak q{Bad context! No biscuit!}                   }
          );
      }
  
  With these in place, the object returned from a scalar-context call to
  C<get_server_status()> now behaves differently, depending on how
  it's used. For example:
  
      if ( my $status = get_server_status() ) {  # BOOL: True if uptime > 0
          $load_distribution[$status]++;         # INT:  Evaluates to load value
          print "$status\n";                     # STR:  Prints "name: uptime"
      }
  
      if (get_server_status()) {                 # PUREBOOL: also sets $_;
          print;                                 # ...which is then used here
      }
  
  =head3 Boolean vs Pure Boolean contexts
  
  There is a special subset of boolean contexts where the return value is being
  used and immediately thrown away. For example, in the loop:
  
      while (get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is tested for truth and then discarded.
  This is known as "pure boolean context". In contrast, in the loop:
  
      while (my $data = get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is first assigned to C<$data>, then
  tested for truth. Because of the assignment, the return value is I<not>
  discarded after the boolean test. This is ordinary "boolean context".
  
  In Perl, pure boolean context is often associated with a special side-effect,
  that does not occur in regular boolean contexts. For example:
  
      while (<>) {...}         # $_ set as side-effect of pure boolean context
  
      while ($v = <>) {...}    # $_ NOT set in ordinary boolean context
  
  Contextual::Return supports this with a special subcase of C<BOOL> named
  <PUREBOOL>. In pure boolean contexts, Contextual::Return will call a
  C<PUREBOOL> handler if one has been defined, or fall back to a C<BOOL>
  or C<SCALAR> handler if no C<PUREBOOL> handler exists. In ordinary
  boolean contexts only the C<BOOL> or C<SCALAR> handlers are tried, even
  if a C<PUREBOOL> handler is also defined.
  
  Typically C<PUREBOOL> handlers are set up to have some side-effect (most
  commonly: setting C<$_> or <$@>), like so:
  
      sub get_data {
          my ($succeeded, @data) = _go_and_get_data();
  
          return
              PUREBOOL { $_ = $data[0]; $succeeded; }
                  BOOL {                $succeeded; }
                SCALAR {                $data[0];   }
                  LIST {                @data;      }
      }
  
  However, there is no requirement that they have side-effects. For example,
  they can also be used to implement "look-but-don't-retrieve-yet" checking:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  
  =head2 Self-reference within handlers
  
  Any handler can refer to the contextual return object it is part of, by
  calling the C<RETOBJ()> function. This is particularly useful for C<PUREBOOL>
  and C<LIST> handlers. For example:
  
      return 
          PUREBOOL { $_ = RETOBJ; next handler; }
              BOOL { !$failed;                  }
           DEFAULT { $data;                     };
  
  
  =head2 Referential contexts
  
  The other major kind of scalar return value is a reference.
  Contextual::Return provides contextual return blocks that allow you to
  specify what to (lazily) return when the return value of a subroutine is
  used as a reference to a scalar (C<SCALARREF {...}>), to an array
  (C<ARRAYREF {...}>), to a hash (C<HASHREF {...}>), to a subroutine
  (C<CODEREF {...}>), or to a typeglob (C<GLOBREF {...}>).
  
  For example, the server status subroutine shown earlier could be extended to
  allow it to return a hash reference, thereby supporting "named return values":
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }  }
                 BOOL { $server_data{uptime} > 0                    }
                  NUM { $server_data{load}                          }
                  STR { "$server_data{name}: $server_data{uptime}"  }
                 VOID { print "$server_data{load}\n"                }
              HASHREF { return \%server_data                        }
              DEFAULT { croak q{Bad context! No biscuit!}           }
          );
      }
  
      # and later...
  
      my $users = get_server_status->{users};
  
  
      # or, lazily...
  
      my $server = get_server_status();
  
      print "$server->{name} load = $server->{load}\n";
  
  
  =head2 Interpolative referential contexts
  
  The C<SCALARREF {...}> and C<ARRAYREF {...}> context blocks are
  especially useful when you need to interpolate a subroutine into
  strings. For example, if you have a subroutine like:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and later...
  
      print "There are ", scalar(get_todo_tasks()), " tasks:\n",
              get_todo_tasks();
  
  then you could make it much easier to interpolate calls to that
  subroutine by adding:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              SCALARREF { \scalar @todo_list }  # Ref to how many
              ARRAYREF  { \@todo_list        }  # Ref to them
          );
      }
  
      # and then...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  In fact, this behaviour is so useful that it's the default. If you
  don't provide an explicit C<SCALARREF {...}> block,
  Contextual::Return automatically provides an implicit one that simply
  returns a reference to whatever would have been returned in scalar context.
  Likewise, if no C<ARRAYREF {...}> block is specified, the module supplies one
  that returns the list-context return value wrapped up in an array reference.
  
  So you could just write:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and still do this...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  
  =head2 Fallback contexts
  
  As the previous sections imply, the C<BOOL {...}>, C<NUM {...}>, C<STR
  {...}>, and various C<*REF {...}> blocks, are special cases of the
  general C<SCALAR {...}> context block. If a subroutine is called in one
  of these specialized contexts but does not use the corresponding context
  block, then the more general C<SCALAR {...}> block is used instead (if
  it has been specified).
  
  So, for example:
  
      sub read_value_from {
          my ($fh) = @_;
  
          my $value = <$fh>;
          chomp $value;
  
          return (
              BOOL   { defined $value }
              SCALAR { $value         }
          );
      }
  
  ensures that the C<read_value_from()> subroutine returns true in boolean
  contexts if the read was successful. But, because no specific C<NUM {...}>
  or C<STR {...}> return behaviours were specified, the subroutine falls back on
  using its generic C<SCALAR {...}> block in all other scalar contexts.
  
  Another way to think about this behaviour is that the various kinds of
  scalar context blocks form a hierarchy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |
           `--< STR
  
  Contextual::Return uses this hierarchical relationship to choose the most
  specific context block available to handle any particular return context,
  working its way up the tree from the specific type it needs, to the more
  general type, if that's all that is available.
  
  There are two slight complications to this picture. The first is that Perl
  treats strings and numbers as interconvertable so the diagram (and the
  Contextual::Return module) also has to allow these interconversions as a
  fallback strategy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |    : ^
           |    v :
           `--< STR
  
  The dotted lines are meant to indicate that this intraconversion is secondary
  to the main hierarchical fallback. That is, in a numeric context, a C<STR
  {...}> block will only be used if there is no C<NUM {...}> block I<and> no
  C<SCALAR {...}> block. In other words, the generic context type is always
  used in preference to string<->number conversion.
  
  The second slight complication is that the above diagram only shows a
  small part of the complete hierarchy of contexts supported by
  Contextual::Return. The full fallback hierarchy (including dotted
  interconversions) is:
  
        DEFAULT
           ^
           |
           |--< VOID
           |
           `--< NONVOID
                   ^
                   |
                   |--< VALUE <...............
                   |      ^                   :
                   |      |                   :
                   |      |--< SCALAR <.......:...
                   |      |           ^           :
                   |      |           |           :
                   |      |           |--< BOOL   :
                   |      |           |     ^     :
                   |      |           |     |     :
                   |      |           |  PUREBOOL :
                   |      |           |           :
                   |      |           |--< NUM <..:.
                   |      |           |    : ^      :
                   |      |           |    v :      :
                   |      |           `--< STR <....:..
                   |      |                           :
                   |      |                          ::
                   |      `--< LIST ................: :
                   |            : ^                   :
                   |            : :                   :
                   `--- REF     : :                   :
                         ^      : :                   :
                         |      v :                   :
                         |--< ARRAYREF                :
                         |                            :
                         |--< SCALARREF .............:
                         |
                         |--< HASHREF
                         |
                         |--< CODEREF
                         |
                         |--< GLOBREF
                         |
                         `--< OBJREF <....... METHOD
                                 ^
                                 :........... BLESSED
  
  As before, each dashed arrow represents a fallback relationship. That
  is, if the required context specifier isn't available, the arrows are
  followed until a more generic one is found. The dotted arrows again
  represent the interconversion of return values, which is
  attempted only after the normal hierarchical fallback fails.
  
  For example, if a subroutine is called in a context that expects a
  scalar reference, but no C<SCALARREF {...}> block is provided, then
  Contextual::Return tries the following blocks in order:
  
          REF {...}
      NONVOID {...}
      DEFAULT {...}
          STR {...} (automatically taking a reference to the result)
          NUM {...} (automatically taking a reference to the result)
       SCALAR {...} (automatically taking a reference to the result)
        VALUE {...} (automatically taking a reference to the result)
  
  Likewise, in a list context, if there is no C<LIST {...}> context block, the
  module tries:
  
         VALUE {...}
       NONVOID {...}
       DEFAULT {...}
      ARRAYREF {...} (automatically dereferencing the result)
           STR {...} (treating it as a list of one element)
           NUM {...} (treating it as a list of one element)
        SCALAR {...} (treating it as a list of one element)
  
  The more generic context blocks are especially useful for intercepting
  unexpected and undesirable call contexts. For example, to turn I<off>
  the automatic scalar-ref and array-ref interpolative behaviour described
  in L<Interpolative referential contexts>, you could intercept I<all>
  referential contexts using a generic C<REF {...}> context block:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              REF { croak q{get_todo_task() can't be used as a reference} }
          );
      }
  
      print 'There are ', get_todo_tasks(), '...';    # Still okay
      print "There are ${get_todo_tasks()}...";       # Throws an exception
  
  
  =head2 Treating return values as objects
  
  Normally, when a return value is treated as an object (i.e. has a method
  called on it), Contextual::Return invokes any C<OBJREF> handler that was
  specified in the contextual return list, and delegates the method call to
  the object returned by that handler.
  
  However, you can also be more specific, by specifying a C<METHOD> context
  handler in the contextual return list. The block of this handler is expected
  to return one or more method-name/method-handler pairs, like so:
  
      return
          METHOD {
              get_count => sub { my $n = shift; $data[$n]{count} },
              get_items => sub { my $n = shift; $data[$n]{items} },
              clear     => sub { @data = (); },
              reset     => sub { @data = (); },
          }
  
  Then, whenever one of the specified methods is called on the return value,
  the corresponding subroutine will be called to implement it.
  
  The method handlers must always be subroutine references, but the method-name
  specifiers may be strings (as in the previous example) or they may be
  specified generically, as either regexes or array references. Generic method
  names are used to call the same handler for two or more distinct method names.
  For example, the previous example could be simplified to:
  
      return
          METHOD {
              qr/get_(\w+)/     => sub { my $n = shift; $data[$n]{$1} },
              ['clear','reset'] => sub { @data = (); },
          }
  
  A method name specified by regex will invoke the corresponding handler for any
  method call request that the regex matches. A method name specified by array
  ref will invoke the corresponding handler if the method requested matches any
  of the elements of the array (which may themselves be strings or regexes).
  
  When the method handler is invoked, the name of the method requested is
  passed to the handler in C<$_>, and the method's argument list is passed
  (as usual) via C<@_>.
  
  Note that any methods not explicitly handled by the C<METHOD> handlers
  will still be delegated to the object returned by the C<OBJREF> handler
  (if it is also specified).
  
  
  =head2 Not treating return values as objects
  
  The use of C<OBJREF> and C<METHOD> are slightly complicated by the fact
  that contextual return values are themselves objects.
  
  For example, prior to version 0.4.4 of the module, if you passed a
  contextual return value to C<Scalar::Util::blessed()>, it always
  returned a true value (namely, the string: 'Contextual::Return::Value'),
  even if the return value had not specified handlers for C<OBJREF> or
  C<METHOD>.
  
  In other words, the I<implementation> of contextual return values (as
  objects) was getting in the way of the I<use> of contextual return
  values (as non-objects).
  
  So the module now also provides a C<BLESSED> handler, which allows you
  to explicitly control how contextual return values interact with
  C<Scalar::Util::blessed()>.
  
  If C<$crv> is a contextual return value, by default
  C<Scalar::Util::blessed($crv)> will now only return true if that return
  value has a C<OBJREF>, C<LAZY>, C<REF>, C<SCALAR>, C<VALUE>, C<NONVOID>,
  or C<DEFAULT> handler that in turn returns a blessed object.
  
  However if C<$crv> also provides a C<BLESSED> handler, C<blessed()>
  will return whatever that handler returns.
  
  This means:
  
      sub simulate_non_object {
          return BOOL { 1 }
                  NUM { 42 }
      }
  
      sub simulate_real_object {
          return OBJREF { bless {}, 'My::Class' }
                   BOOL { 1 }
                    NUM { 42 }
      }
  
      sub simulate_faked_object {
          return BLESSED { 'Foo' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
      sub simulate_previous_behaviour {
          return BLESSED { 'Contextual::Return::Value' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
  
      say blessed( simulate_non_object()         );   # undef
      say blessed( simulate_real_object()        );   # My::Class
      say blessed( simulate_faked_object()       );   # Foo
      say blessed( simulate_previous_behaviour() );   # Contextual::Return::Value
  
  Typically, you either want no C<BLESSED> handler (in which case
  contextual return values pretend not to be blessed objects), or you want
  C<BLESSED { 'Contextual::Return::Value' }> for backwards compatibility
  with pre-v0.4.7 behaviour.
  
  
  =head3 Preventing fallbacks
  
  Sometimes fallbacks can be too helpful. Or sometimes you want to impose
  strict type checking on a return value.
  
  Contextual::Returns allows that via the C<STRICT> specifier. If you include
  C<STRICT> anywhere in your return statement, the module disables all 
  fallbacks and will therefore through an exception if the return value is
  used in any way not explicitly specified in the contextual return sequence.
  
  For example, to create a subroutine that returns only a string:
  
      sub get_name {
          return STRICT STR { 'Bruce' }
      }
  
  If the return value of the subroutine is used in any other way than as
  a string, an exception will be thrown.
  
  You can still specify handlers for more than a single kind of context
  when using C<STRICT>:
  
      sub get_name {
          return STRICT
              STR  { 'Bruce' }
              BOOL { 0 }
      }
  
  ...but these will still be the only contexts in which the return value
  can be used:
  
      my $n = get_name() ? 1 : 2;  # Okay because BOOL handler specified
  
      my $n = 'Dr' . get_name();   # Okay because STR handler specified
  
      my $n = 1 + get_name();      # Exception thrown because no NUM handler
  
  In other words, C<STRICT> allows you to impose strict type checking on
  your contextual return value.
  
  
  =head2 Deferring handlers
  
  Because the various handlers form a hierarchy, it's possible to
  implement more specific handlers by falling back on ("deferring to")
  more general ones. For example, L<a C<PUREBOOL> handler|"Boolean vs Pure
  Boolean contexts"> is almost always identical in its basic behaviour to
  the corresponding C<BOOL> handler, except that it adds some side-effect.
  For example:
  
      return
          PUREBOOL { $_ = $return_val; defined $return_val && $return_val > 0 }
              BOOL {                   defined $return_val && $return_val > 0 }
            SCALAR {                   $return_val;                           }
  
  So Contextual::Return allows you to have a handler perform some action
  and then defer to a more general handler to supply the actual return
  value. To fall back to a more general case in this way, you simply write:
  
      next handler;
  
  at the end of the handler in question, after which Contextual::Return
  will find the next-most-specific handler and execute it as well. So the
  previous example, could be re-written:
  
      return
          PUREBOOL { $_ = $return_val; next handler;        }
              BOOL { defined $return_val && $return_val > 0 }
            SCALAR { $return_val;                           }
      
  Note that I<any> specific handler can defer to a more general one in
  this same way. For example, you could provide consistent and
  maintainable type-checking for a subroutine that returns references by
  providing C<ARRAYREF>, C<HASHREF>, and C<SCALARREF> handlers that all
  defer to a generic C<REF> handler, like so:
  
      my $retval = _get_ref();
  
      return
         SCALARREF { croak 'Type mismatch' if ref($retval) ne 'SCALAR';
                     next handler;
                   }
          ARRAYREF { croak 'Type mismatch' if ref($retval) ne 'ARRAY';
                     next handler;
                   }
           HASHREF { croak 'Type mismatch' if ref($retval) ne 'HASH';
                     next handler;
                   }
               REF { $retval }
          
  If, at a later time, the process of returning a reference became more complex,
  only the C<REF> handler would have to be updated.
  
  
  =head2 Nested handlers
  
  Another way of factoring out return behaviour is to nest more specific
  handlers inside more general ones. For instance, in the final example given in
  L<"Boolean vs Pure Boolean contexts">:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  you could factor out the repeated calls to C<_go_and_get_data()> like so:
  
      sub get_data {
          return
              PUREBOOL { _check_for_but_dont_get_data(); }
               DEFAULT {
                  my $data = _go_and_get_data();
  
                  BOOL { defined $data; }
                   REF {         $data; }
               }
      }
  
  Here, the C<DEFAULT> handler deals with every return context except pure
  boolean. Within that C<DEFAULT> handler, the data is first retrieved,
  and then two "sub-handlers" deal with the ordinary boolean and
  referential contexts.
  
  Typically nested handlers are used in precisely this way: to optimize
  for inexpensive special cases (such as pure boolean or integer or void
  return contexts) and only do extra work for those other cases that
  require it.
  
  
  =head2 Failure contexts
  
  Two of the most common ways to specify that a subroutine has failed
  are to return a false value, or to throw an exception. The
  Contextual::Return module provides a mechanism that allows the
  subroutine writer to support I<both> of these mechanisms at the
  same time, by using the C<FAIL> specifier.
  
  A return statement of the form:
  
      return FAIL;
  
  causes the surrounding subroutine to return C<undef> (i.e. false) in
  boolean contexts, and to throw an exception in any other context. For example:
  
      use Contextual::Return;
  
      sub get_next_val {
          my $next_val = <>;
          return FAIL if !defined $next_val;
          chomp $next_val;
          return $next_val;
      }
  
  If the C<return FAIL> statement is executed, it will either return false in a
  boolean context:
  
      if (my $val = get_next_val()) {      # returns undef if no next val
          print "[$val]\n";
      }
  
  or else throw an exception if the return value is used in any
  other context:
  
      print get_next_val();       # throws exception if no next val
  
      my $next_val = get_next_val();
      print "[$next_val]\n";      # throws exception if no next val
  
  
  The exception that is thrown is of the form:
  
      Call to main::get_next_val() failed at demo.pl line 42
  
  but you can change that message by providing a block to the C<FAIL>, like so:
  
      return FAIL { "No more data" } if !defined $next_val;
  
  in which case, the final value of the block becomes the exception message:
  
      No more data at demo.pl line 42
  
  A failure value can be interrogated for its error message, by calling its
  C<error()> method, like so:
  
      my $val = get_next_val();
      if ($val) {
          print "[$val]\n";
      }
      else {
          print $val->error, "\n";
      }
  
  
  =head2 Configurable failure contexts
  
  The default C<FAIL> behaviour--false in boolean context, fatal in all
  others--works well in most situations, but violates the Platinum Rule ("Do
  unto others as I<they> would have done unto them").
  
  So it may be user-friendlier if the user of a module is allowed decide how
  the module's subroutines should behave on failure. For example, one user
  might prefer that failing subs always return undef; another might prefer
  that they always throw an exception; a third might prefer that they
  always log the problem and return a special Failure object; whilst a
  fourth user might want to get back C<0> in scalar contexts, an empty list
  in list contexts, and an exception everywhere else.
  
  You could create a module that allows the user to specify all these
  alternatives, like so:
  
      package MyModule;
      use Contextual::Return;
      use Log::StdLog;
  
      sub import {
          my ($package, @args) = @_;
  
          Contextual::Return::FAIL_WITH {
              ':false' => sub { return undef },
              ':fatal' => sub { croak @_       },
              ':filed' => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              ':fussy' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @args;
      }
  
  This configures Contextual::Return so that, instead of the usual
  false-or-fatal semantics, every C<return FAIL> within MyModule's namespace is
  implemented by one of the four subroutines specified in the hash that was
  passed to C<FAIL_WITH>.
  
  Which of those four subs implements the C<FAIL> is determined by the
  arguments passed after the hash (i.e. by the contents of C<@args>).
  C<FAIL_WITH> walks through that list of arguments and compares
  them against the keys of the hash. If a key matches an argument, the
  corresponding value is used as the implementation of C<FAIL>. Note that,
  if subsequent arguments also match a key, their subroutine overrides the
  previously installed implementation, so only the final override has any
  effect. Contextual::Return generates warnings when multiple overrides are
  specified.
  
  All of which mean that, if a user loaded the MyModule module like this:
  
      use MyModule qw( :fatal other args here );
  
  then every C<FAIL> within MyModule would be reconfigured to throw an exception
  in all circumstances, since the presence of the C<':fatal'> in the argument
  list will cause C<FAIL_WITH> to select the hash entry whose key is C<':fatal'>.
  
  On the other hand, if they loaded the module:
  
      use MyModule qw( :fussy other args here );
  
  then each C<FAIL> within MyModule would return undef or empty list or throw an
  exception, depending on context, since that's what the subroutine whose key is
  C<':fussy'> does.
  
  Many people prefer module interfaces with a C<< I<flag> => I<value> >>
  format, and C<FAIL_WITH> supports this too. For example, if you
  wanted your module to take a C<-fail> flag, whose associated value could
  be any of C<"undefined">, C<"exception">, C<"logged">, or C<"context">,
  then you could implement that simply by specifying the flag as the first
  argument (i.e. I<before> the hash) like so:
  
      sub import {
          my $package = shift;
  
          Contextual::Return::FAIL_WITH -fail => {
              'undefined' => sub { return undef },
              'exception' => sub { croak @_ },
              'logged'    => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              'context' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @_;
  
  and then load the module:
  
      use MyModule qw( other args here ), -fail=>'undefined';
  
  or:
  
      use MyModule qw( other args here ), -fail=>'exception';
  
  In this case, C<FAIL_WITH> scans the argument list for a pair of values: its
  flag string, followed by some other selector value. Then it looks up the
  selector value in the hash, and installs the corresponding subroutine as its
  local C<FAIL> handler.
  
  If this "flagged" interface is used, the user of the module can also
  specify their own handler directly, by passing a subroutine reference as
  the selector value instead of a string:
  
      use MyModule qw( other args here ), -fail=>sub{ die 'horribly'};
  
  If this last example were used, any call to C<FAIL> within MyModule
  would invoke the specified anonymous subroutine (and hence throw a
  'horribly' exception).
  
  Note that, any overriding of a C<FAIL> handler is specific to the
  namespace and file from which the subroutine that calls C<FAIL_WITH> is
  itself called. Since C<FAIL_WITH> is designed to be called from within a
  module's C<import()> subroutine, that generally means that the C<FAIL>s
  within a given module X are only overridden for the current namespace
  within the particular file from module X is loaded. This means that two
  separate pieces of code (in separate files or separate namespaces) can
  each independently overide a module's C<FAIL> behaviour, without
  interfering with each other.
  
  =head2 Lvalue contexts
  
  Recent versions of Perl offer (limited) support for lvalue subroutines:
  subroutines that return a modifiable variable, rather than a simple constant 
  value.
  
  Contextual::Return can make it easier to create such subroutines, within the
  limitations imposed by Perl itself. The limitations that Perl places on lvalue
  subs are:
  
  =over
  
  =item 1.
  
  The subroutine must be declared with an C<:lvalue> attribute:
  
      sub foo :lvalue {...}
  
  =item 2.
  
  The subroutine must not return via an explicit C<return>. Instead, the
  last statement must evaluate to a variable, or must be a call to another
  lvalue subroutine call.
  
      my ($foo, $baz);
  
      sub foo :lvalue {
          $foo;               # last statement evals to a var
      }
  
      sub bar :lvalue {
          foo();              # last statement is lvalue sub call
      }
  
      sub baz :lvalue {
          my ($arg) = @_;
  
          $arg > 0            # last statement evals...
              ? $baz          # ...to a var
              : bar();        # ...or to an lvalue sub call
      }
  
  =back
  
  Thereafter, any call to the lvalue subroutine produces a result that can be
  assigned to:
  
      baz(0) = 42;            # same as: $baz = 42
  
      baz(1) = 84;            # same as:                  bar() = 84 
                              #  which is the same as:    foo() = 84
                              #   which is the same as:   $foo  = 84
  
  Ultimately, every lvalue subroutine must return a scalar variable, which
  is then used as the lvalue of the assignment (or whatever other lvalue
  operation is applied to the subroutine call). Unfortunately, because the
  subroutine has to return this variable I<before> the assignment
  can take place, there is no way that a normal lvalue subroutine can
  get access to the value that will eventually be assigned to its
  return value.
  
  This is occasionally annoying, so the Contextual::Return module offers
  a solution: in addition to all the context blocks described above, it
  provides three special contextual return blocks specifically for use in
  lvalue subroutines: C<LVALUE>, C<RVALUE>, and C<NVALUE>.
  
  Using these blocks you can specify what happens when an lvalue
  subroutine is used in lvalue and non-lvalue (rvalue) context. For
  example:
  
      my $verbosity_level = 1;
  
      # Verbosity values must be between 0 and 5...
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = max(0, min($_, 5)) }
          RVALUE { $verbosity_level                      }
      }
  
  The C<LVALUE> block is executed whenever C<verbosity> is called as an lvalue:
  
      verbosity() = 7;
  
  The block has access to the value being assigned, which is passed to it
  as C<$_>. So, in the above example, the assigned value of 7 would be
  aliased to C<$_> within the C<LVALUE> block, would be reduced to 5 by the
  "min-of-max" expression, and then assigned to C<$verbosity_level>.
  
  (If you need to access the caller's C<$_>, it's also still available:
  as C<$CALLER::_>.)
  
  When the subroutine isn't used as an lvalue:
  
      print verbosity();
      
  the C<RVALUE> block is executed instead and its final value returned.
  Within an C<RVALUE> block you can use any of the other features of
  Contextual::Return. For example:
  
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  but the context sequence must be nested inside an C<RVALUE> block.
  
  You can also specify what an lvalue subroutine should do when it is used
  neither as an lvalue nor as an rvalue (i.e. in void context), by using an
  C<NVALUE> block:
  
      sub verbosity :lvalue {
          my ($level) = @_;
  
          NVALUE { $verbosity_level = int max(0, min($level, 5)) }
          LVALUE { $verbosity_level = int max(0, min($_,     5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  In this example, a call to C<verbosity()> in void context sets the verbosity
  level to whatever argument is passed to the subroutine:
  
      verbosity(1);
  
  Note that you I<cannot> get the same effect by nesting a C<VOID> block
  within an C<RVALUE> block:
  
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
              VOID { $verbosity_level = $level      }  # Wrong!
          }
  
  That's because, in a void context the return value is never evaluated,
  so it is never treated as an rvalue, which means the C<RVALUE> block
  never executes.
  
  
  =head2 Result blocks
  
  Occasionally, it's convenient to calculate a return value I<before> the
  end of a contextual return block. For example, you may need to clean up
  external resources involved in the calculation after it's complete.
  Typically, this requirement produces a slightly awkward code sequence
  like this:
  
      return 
          VALUE {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  Such code sequences become considerably more awkward when you want
  the return value to be context sensitive, in which case you have to
  write either:
  
      return 
          LIST {
              $db->start_work();
              my @result = $db->retrieve_query($query);
              $db->commit();
              @result;
          }
          SCALAR {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  or, worse:
  
      return 
          VALUE {
              $db->start_work();
              my $result = LIST ? [$db->retrieve_query($query)]
                                :  $db->retrieve_query($query);
              $db->commit();
              LIST ? @{$result} : $result;
          }
  
  To avoid these infelicities, Contextual::Return provides a second way of
  setting the result of a context block; a way that doesn't require that the
  result be the last statement in the block:
  
      return 
          LIST {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
          SCALAR {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  The presence of a C<RESULT> block inside a contextual return block causes
  that block to return the value of the final statement of the C<RESULT>
  block as the handler's return value, rather than returning the value of
  the handler's own final statement. In other words, the presence of a C<RESULT>
  block overrides the normal return value of a context handler.
  
  Better still, the C<RESULT> block always evaluates its final statement
  in the same context as the surrounding C<return>, so you can just write:
  
      return 
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  and the C<retrieve_query()> method will be called in the appropriate context
  in all cases.
  
  A C<RESULT> block can appear anywhere inside any contextual return
  block, but may not be used outside a context block. That is, this
  is an error:
  
      if ($db->closed) {
          RESULT { undef }; # Error: not in a context block
      }
      return 
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  
  =head2 Post-handler clean-up
  
  If a subroutine uses an external resource, it's often necessary to close
  or clean-up that resource after the subroutine ends...regardless of
  whether the subroutine exits normally or via an exception.
  
  Typically, this is done by encapsulating the resource in a lexically
  scoped object whose destructor does the clean-up. However, if the clean-up
  doesn't involve deallocation of an object (as in the C<< $db->commit() >>
  example in the previous section), it can be annoying to have to create a
  class and allocate a container object, merely to mediate the clean-up.
  
  To make it easier to manage such resources, Contextual::Return supplies
  a special labelled block: the C<RECOVER> block. If a C<RECOVER> block is
  specified as part of a contextual return sequence, that block is
  executed after any context handler, even if the context handler exits
  via an exception.
  
  So, for example, you could implement a simple commit-or-revert
  policy like so:
  
      return 
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          RECOVER {
              if ($@) {
                  $db->revert();
              }
              else {
                  $db->commit();
              }
          }
  
  The presence of a C<RECOVER> block also intercepts all exceptions thrown
  in any other context block in the same contextual return sequence. Any
  such exception is passed into the C<RECOVER> block in the usual manner:
  via the C<$@> variable. The exception may be rethrown out of the
  C<RECOVER> block by calling C<die>:
  
      return 
          LIST    { $db->retrieve_all($query) }
          DEFAULT { croak "Invalid call (not in list context)" }
          RECOVER {
              die $@ if $@;    # Propagate any exception
              $db->commit();   # Otherwise commit the changes
          }
  
  A C<RECOVER> block can also access or replace the returned value, by
  invoking a C<RESULT> block. For example:
  
      return 
          LIST    { attempt_to_generate_list_for(@_)  }
          SCALAR  { attempt_to_generate_count_for(@_) }
          RECOVER {
              if ($@) {                # On any exception...
                  warn "Replacing return value. Previously: ", RESULT;
                  RESULT { undef }     # ...return undef
              }
          }
  
  
  =head2 Post-return clean-up
  
  Occasionally it's necessary to defer the clean-up of resources until
  after the return value has been used. Once again, this is usually
  done by returning an object with a suitable destructor.
  
  Using Contextual::Return you can get the same effect, by providing a
  C<CLEANUP> block in the contextual return sequence:
  
      return 
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          CLEANUP { $db->commit()              }
  
  In this example, the C<commit> method call is only performed after the
  return value has been used by the caller. Note that this is quite
  different from using a C<RECOVER> block, which is called as the
  subroutine returns its value; a C<CLEANUP> is called when the returned
  value is garbage collected.
  
  A C<CLEANUP> block is useful for controlling resources allocated to support an
  C<ACTIVE> return value. For example:
  
      my %file;
  
      # Return an active value that is always the next line from a file...
      sub readline_from {
          my ($file_name) = @_;
  
          # Open the file, if not already open...
          if (!$file{$file_name}) {
              open $file{$file_name}{handle}, '<', $file_name;
          }
  
          # Track how many active return values are using this file...
          $file{$file_name}{count}++;
  
          return ACTIVE
              # Evaluating the return value returns the next line...
              VALUE   { readline $file{$file_name}{handle} }
  
              # Once the active value is finished with, clean up the filehandle...
              CLEANUP {
                  delete $file{$file_name}
                      if --$file{$file_name}{count} == 0;
              }
      }
  
  
  =head2 Debugging contextual return values
  
  Contextual return values are implemented as opaque objects (using the
  "inside-out" technique). This means that passing such values to
  Data::Dumper produces an uninformative output like:
  
      $VAR1 = bless( do{\(my $o = undef)}, 'Contextual::Return::Value' );
  
  So the module provides two methods that allow contextual return values
  to be correctly reported: either directly, or when dumped by
  Data::Dumper.
  
  To dump a contextual return value directly, call the module's C<DUMP()>
  method explicitly and print the result:
  
      print $crv->Contextual::Return::DUMP();
  
  This produces an output something like:
  
      [
       { FROM       => 'main::foo'                                       },
       { NO_HANDLER => [ 'VOID', 'CODEREF', 'HASHREF', 'GLOBREF' ]       },
       { FALLBACKS  => [ 'VALUE' ]                                       },
       { LIST       => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
       { STR        => '<<<Throws exception: Died at demo.pl line 7.>>>' },
       { NUM        => 42                                                },
       { BOOL       => -1                                                },
       { SCALARREF  => '<<<self-reference>>>'                            },
       { ARRAYREF   => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
      ];
  
  The C<FROM> hash entry names the subroutine that produced the return
  value. The C<NO_HANDLER> hash entry lists those contexts for which no
  handler was defined (and which would therefore normally produce "can't
  call" exceptions such as: C<"Can't call main::foo in VOID context">).
  The C<FALLBACKS> hash entry lists any "generic" contexts such as
  C<VALUE>, C<NONVOID>, C<REF>, C<DEFAULT>, etc. that the contextual
  return value can also handle. After these, all the remaining hash
  entries are actual contexts in which the return value could successfully
  be evaluated, and the value it would produce in each of those contexts.
  
  The Data::Dumper module also has a mechanism by which you can tell it
  how to produce a similar listing automatically whenever a contextual
  return value is passed to its C<Dumper> method. Data::Dumper allows you
  to register a "freezer" method, that is called prior to dumping, and
  which can be used to adapt an opaque object to make it dumpable.
  Contextual::Return provides just such a method
  (C<Contextual::Return::FREEZE()>) for you to register, like so:
  
      use Data::Dumper 'Dumper';
      
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
      print Dumper $foo;
  
  The output is then precisely the same as C<Contextual::Return::DUMP()>
  would produce.
  
  Note that, with both of the above dumping mechanisms, it is essential to use
  the full name of the method. That is:
  
      print $crv->Contextual::Return::DUMP();
  
  rather than:
  
      print $crv->DUMP();
  
  This is because the shorter version is interpreted as calling the
  C<DUMP()> method on the object returned by the return value's C<OBJREF>
  context block (see L<"Scalar reference contexts">)
  
  For the same reason, you must write:
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
  not:
  
      local $Data::Dumper::Freezer = 'FREEZE';
  
  
  =head2 Namespace controls
  
  By default the module exports a large number of return context markers:
  
      DEFAULT    REF          LAZY    
      VOID       SCALARREF    FIXED   
      NONVOID    ARRAYREF     ACTIVE  
      LIST       CODEREF      RESULT 
      SCALAR     HASHREF      RECOVER
      VALUE      GLOBREF      CLEANUP
      STR        OBJREF       RVALUE 
      NUM        METHOD       LVALUE 
      BOOL                    NVALUE 
      PUREBOOL
  
  These are exported as subroutines, and so can conflict with existing
  subroutines in your namespace, or with subroutines imported from other
  modules.
  
  Contextual::Return allows you to control which contextual return blocks are
  exported into any namespace that uses the module. It also allows you to rename
  blocks to avoid namespace conflicts with existing subroutines.
  
  Both these features are controlled by passing arguments to the C<use>
  statement that loads the module as follows:
  
  =over
          
  =item *
  
  Any string passed as an argument to C<use Contextual::Return>,
  exports only the block name it specifies;
  
  =item *
  
  Any regex passed as an argument to C<use Contextual::Return>
  exports every block name it matches;
  
  =item *
  
  Any array ref (recursively) exports each of its elements
  
  =item *
  
  Any string that appears immediately after one of the above three specifiers,
  and which is not itself a block name, renames the handlers exported by that
  preceding specifier by filtering each handler name through C<sprintf()>
  
  =back
  
  That is, you can specify handlers to be exported by exact name (as a string),
  by general pattern (as a regex), or collectively (in an array). And after any
  of these export specifications, you can append a template in which any C<'%s'>
  will be replaced by the original name of the handler. For example:
  
      # Selectively export specific sets of handlers...
      use Contextual::Return  qr/[NLR]VALUE/;
      use Contextual::Return  qr/.*REF/;
  
      # Selective export specific sets and add a suffix to each...
      use Contextual::Return  qr/[NLR]VALUE/ => '%s_CONTEXT';
  
      # Selective export specific sets and add a prefix to each...
      use Contextual::Return  qr/.*REF/ => 'CR_%s';
  
      # Export a list of handlers...
      use Contextual::Return    'NUM', 'STR', 'BOOL' ;
      use Contextual::Return qw< NUM    STR    BOOL >;
      use Contextual::Return   ['NUM', 'STR', 'BOOL'];
  
      # Export a list of handlers, renaming them individually...
      use Contextual::Return  NUM => 'NUMERIC', STR => 'TEXT', BOOL => 'CR_%s';
              
      # Export a list of handlers, renaming them collectively...
      use Contextual::Return  ['NUM', 'STR', 'BOOL'] => '%s_CONTEXT';
  
      # Mixed exports and renames...
      use Contextual::Return (
          STR => 'TEXT',
          ['NUM', 'BOOL'] => 'CR_%s',
          ['LIST', 'SCALAR', 'VOID', qr/^[NLR]VALUE/] => '%s_CONTEXT',
      );
  
  
  
  =head1 INTERFACE 
  
  =head2 Context tests
  
  =over 
  
  =item C<< LIST() >>
  
  Returns true if the current subroutine was called in list context.
  A cleaner way of writing: C<< wantarray() >>
  
  =item C<< SCALAR() >>
  
  Returns true if the current subroutine was called in scalar context.
  A cleaner way of writing: C<< defined wantarray() && ! wantarray() >>
  
  
  =item C<< VOID() >>
  
  Returns true if the current subroutine was called in void context.
  A cleaner way of writing: C<< !defined wantarray() >>
  
  =item C<< NONVOID() >>
  
  Returns true if the current subroutine was called in list or scalar context.
  A cleaner way of writing: C<< defined wantarray() >>
  
  =back
  
  =head2 Standard contexts
  
  =over 
  
  =item C<< LIST {...} >>
  
  The block specifies what the context sequence should evaluate to when
  called in list context.
  
  =item C<< SCALAR {...} >>
  
  The block specifies what the context sequence should evaluate to in
  scalar contexts, unless some more-specific specifier scalar context specifier
  (see below) also occurs in the same context sequence.
  
  =item C<< VOID {...} >>
  
  The block specifies what the context sequence should do when
  called in void context.
  
  =back
  
  =head2 Scalar value contexts
  
  =over
  
  =item C<< BOOL {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a boolean value.
  
  =item C<< NUM {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a numeric value.
  
  =item C<< STR {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a string value.
  
  =item C<< LAZY {...} >>
  
  Another name for C<SCALAR {...}>. Usefully self-documenting when the primary
  purpose of the contextual return is to defer evaluation of the return value
  until it's actually required.
  
  =back
  
  =head2 Scalar reference contexts
  
  =over
  
  =item C<< SCALARREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a scalar.
  
  =item C<< ARRAYREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an array.
  
  =item C<< HASHREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a hash.
  
  Note that a common error here is to write:
  
  HASHREF { a=>1, b=>2, c=>3 }
  
  The curly braces there are a block, not a hash constructor, so the block
  doesn't return a hash reference and the interpreter throws an exception.
  What's needed is:
  
  HASHREF { {a=>1, b=>2, c=>3} }
  
  in which the inner braces I<are> a hash constructor.
  
  =item C<< CODEREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a subroutine.
  
  =item C<< GLOBREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a typeglob.
  
  =item C<< OBJREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an object.
  
  =item C<< METHOD {...} >>
  
  The block can be used to specify particular handlers for specific method calls
  when the return value is treated as an object reference.
  It should return a list of methodname/methodbody pairs. Each method name can
  be specified as a string, a regex, or an array of strings or regexes. The
  method bodies must be specified as subroutine references (usually anonymous
  subs). The first method name that matches the actual method call selects the
  corresponding handler, which is then called.
  
  =back
  
  =head2 Generic contexts
  
  =over
  
  =item C<< VALUE {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a non-referential value (as a boolean, numeric, string,
  scalar, or list). Only used if there is no more-specific value context
  specifier in the context sequence.
  
  =item C<< REF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference of any kind. Only used if there is no
  more-specific referential context specifier in the context sequence.
  
  =item C<< NONVOID {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =item C<< DEFAULT {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a void or non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =back
  
  =head2 Failure context
  
  =over
  
  =item C<< FAIL >>
  
  This block is executed unconditionally and is used to indicate failure. In a
  Boolean context it return false. In all other contexts it throws an exception
  consisting of the final evaluated value of the block.
  
  That is, using C<FAIL>:
  
  return
  FAIL { "Could not defenestrate the widget" }
  
  is exactly equivalent to writing:
  
  return
  BOOL { 0 }
  DEFAULT { croak "Could not defenestrate the widget" }
  
  except that the reporting of errors is a little smarter under C<FAIL>.
  
  If C<FAIL> is called without specifying a block:
  
  return FAIL;
  
  it is equivalent to:
  
  return FAIL { croak "Call to <subname> failed" }
  
  (where C<< <subname> >> is replaced with the name of the surrounding
  subroutine).
  
  Note that, because C<FAIL> implicitly covers every possible return
  context, it cannot be chained with other context specifiers.
  
  =item C<< Contextual::Return::FAIL_WITH >>
  
  This subroutine is not exported, but may be called directly to reconfigure
  C<FAIL> behaviour in the caller's namespace. 
  
  The subroutine is called with an optional string (the I<flag>), followed
  by a mandatory hash reference (the I<configurations hash>), followed by a
  list of zero-or-more strings (the I<selector list>). The values of the
  configurations hash must all be subroutine references.
  
  If the optional flag is specified, C<FAIL_WITH> searches the selector
  list looking for that string, then uses the I<following> item in the
  selector list as its I<selector value>. If that selector value is a
  string, C<FAIL_WITH> looks up that key in the hash, and installs the
  corresponding subroutine as the namespace's C<FAIL> handler (an
  exception is thrown if the selector string is not a valid key of the
  configurations hash). If the selector value is a subroutine reference,
  C<FAIL_WITH> installs that subroutine as the C<FAIL> handler.
  
  If the optional flag is I<not> specified, C<FAIL_WITH> searches the
  entire selector list looking for the last element that matches any
  key in the configurations hash. It then looks up that key in the
  hash, and installs the corresponding subroutine as the namespace's
  C<FAIL> handler.
  
  See L<Configurable failure contexts> for examples of using this feature.
  
  =back
  
  =head2 Lvalue contexts
  
  =over
  
  =item C<< LVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is assigned
  to. The assigned value is passed to the block as C<$_>. To access the caller's
  C<$_> value, use C<$CALLER::_>.
  
  =item C<< RVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is used
  as an rvalue. The final value that is evaluated in the block becomes the
  rvalue.
  
  =item C<< NVALUE >>
  
  This block is executed when an C<:lvalue> subroutine is evaluated in void
  context.
  
  =back
  
  =head2 Explicit result blocks
  
  =over 
  
  =item C<< RESULT >> 
  
  This block may only appear inside a context handler block. It causes the
  surrounding handler to return the final value of the C<RESULT>'s block,
  rather than the final value of the handler's own block. This override occurs
  regardless of the location to the C<RESULT> block within the handler.
  
  If called without a trailing C<{...}>, it simply returns the current result
  value in scalar contexts, or the list of result values in list context.
  
  =back
  
  =head2 Recovery blocks
  
  =over 
  
  =item C<< RECOVER >> 
  
  If present in a context return sequence, this block grabs control after
  any context handler returns or exits via an exception. If an exception
  was thrown it is passed to the C<RECOVER> block via the C<$@> variable.
  
  =back
  
  =head2 Clean-up blocks
  
  =over 
  
  =item C<< CLEANUP >> 
  
  If present in a context return sequence, this block grabs control when
  a return value is garbage collected.
  
  =back
  
  
  =head2 Modifiers
  
  =over
  
  =item C<< FIXED >>
  
  This specifies that the scalar value will only be evaluated once, the
  first time it is used, and that the value will then morph into that
  evaluated value.
  
  =item C<< ACTIVE >>
  
  This specifies that the scalar value's originating block will be re-
  evaluated every time the return value is used.
  
  =back
  
  =head2 Debugging support
  
  =over
  
  =item C<< $crv->Contextual::Return::DUMP() >>
  
  Dump a representation of the return value in all viable contexts
  
  =item C<< local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE' >>
  
  Configure Data::Dumper to correctly dump a representation of the
  return value.
  
  =back
  
  
  =head1 DIAGNOSTICS
  
  =over 
  
  =item C<Can't use %s as export specifier>
  
  In your C<use Contextual::Return> statement you specified something (such as a
  hash or coderef) that can't be used to select what the module exports. Make
  sure the list of selectors includes only strings, regexes, or references to
  arrays of strings or regexes.
  
  
  =item C<use Contextual::Return qr{%s} didn't export anything>
  
  In your C<use Contextual::Return> statement you specified a regex to select
  which handlers to support, but the regex didn't select any handlers. Check
  that the regex you're using actually does match at least one of the names of
  the modules many handlers.
  
  
  =item C<Can't export %s: no such handler>
  
  In your C<use Contextual::Return> statement you specified a string as the
  name of a context handler to be exported, but the module doesn't export a
  handler of that name. Check the spelling for the requested export.
  
  
  =item C<Can't call %s in a %s context>
  
  =item C<Can't use return value of %s in a %s context>
  
  The subroutine you called uses a contextual return, but doesn't specify what
  to return in the particular context in which you called it. You either need to
  change the context in which you're calling the subroutine, or else add a
  context block corresponding to the offending context (or perhaps a
  C<DEFAULT {...}> block).
  
  
  =item C<Can't call bare %s {...} in %s context>
  
  You specified a handler (such as C<VOID {...}> or C<LIST {...}>)
  outside any subroutine, and in a context that it
  can't handle. Did you mean to place the handler outside of a subroutine?
  If so, then you need to put it in a context it can actually handle.
  Otherwise, perhaps you need to replace the trailing block with parens
  (that is: C<VOID()> or C<LIST()>).
  
  
  =item C<Call to %s at %s didn't return a %s reference">
  
  You called the subroutine in a context that expected to get back a
  reference of some kind but the subroutine didn't specify the
  corresponding C<SCALARREF>, C<ARRAYREF>, C<HASHREF>, C<CODEREF>,
  C<GLOBREF>, or generic C<REF>, C<NONVOID>, or C<DEFAULT> handlers.
  You need to specify the appropriate one of these handlers in the subroutine.
  
  
  =item C<Can't call method '%s' on %s value returned by %s">
  
  You called the subroutine and then tried to call a method on the return
  value, but the subroutine returned a classname or object that doesn't
  have that method. This probably means that the subroutine didn't return
  the classname or object you expected. Or perhaps you need to specify
  an C<OBJREF {...}> context block.
  
  
  =item C<Can't install two %s handlers>
  
  You attempted to specify two context blocks of the same name in the same
  return context, which is ambiguous. For example:
  
      sub foo: lvalue {
          LVALUE { $foo = $_ }
          RVALUE { $foo }
          LVALUE { $foo = substr($_,1,10) }
      }
  
  or:
  
      sub bar {
          return
              BOOL { 0 }
              NUM  { 1 }
              STR  { "two" }
              BOOL { 1 };
      }
  
  Did you cut-and-paste wrongly, or mislabel one of the blocks?
  
  
  =item C<Expected a %s block after the %s block but found instead: %s>
  
  If you specify any of C<LVALUE>, C<RVALUE>, or C<NVALUE>, then you can only
  specify C<LVALUE>, C<RVALUE>, or C<NVALUE> blocks in the same return context.
  If you need to specify other contexts (like C<BOOL>, or C<STR>, or C<REF>,
  etc.), put them inside an C<RVALUE> block. See L<Lvalue contexts> for an
  example.
  
  
  =item C<Call to %s failed at %s>
  
  This is the default exception that a C<FAIL> throws in a non-scalar
  context. Which means that the subroutine you called has signalled
  failure by throwing an exception, and you didn't catch that exception.
  You should either put the call in an C<eval {...}> block or else call the
  subroutine in boolean context instead.
  
  
  =item C<Call to %s failed at %s. Attempted to use failure value at %s>
  
  This is the default exception that a C<FAIL> throws when a failure value
  is captured in a scalar variable and later used in a non-boolean
  context. That means that the subroutine you called must have failed, and
  you didn't check the return value for that failure, so when you tried to
  use that invalid value it killed your program. You should either put the
  original call in an C<eval {...}> or else test the return value in a
  boolean context and avoid using it if it's false.
  
  
  =item C<Usage: FAIL_WITH $flag_opt, \%selector, @args>
  
  The C<FAIL_WITH> subroutine expects an optional flag, followed by a reference
  to a configuration hash, followed by a list or selector arguments. You gave it
  something else. See L<Configurable Failure Contexts>.
  
  
  =item C<Selector values must be sub refs>
  
  You passed a configuration hash to C<FAIL_WITH> that specified non-
  subroutines as possible C<FAIL> handlers. Since non-subroutines can't
  possibly be handlers, maybe you forgot the C<sub> keyword somewhere?
  
  
  =item C<Invalid option: %s => %s>
  
  The C<FAIL_WITH> subroutine was passed a flag/selector pair, but the selector
  was not one of those allowed by the configuration hash.
  
  
  =item C<FAIL handler for package %s redefined>
  
  A warning that the C<FAIL> handler for a particular package was
  reconfigured more than once. Typically that's because the module was
  loaded in two places with difference configurations specified. You can't
  reasonably expect two different sets of behaviours from the one module within
  the one namespace.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  Contextual::Return requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  Requires version.pm and Want.pm.
  
  
  =head1 INCOMPATIBILITIES
  
  C<LVALUE>, C<RVALUE>, and C<NVALUE> do not work correctly under the Perl
  debugger. This seems to be because the debugger injects code to capture
  the return values from subroutines, which interferes destructively with 
  the optional final arguments that allow C<LVALUE>, C<RVALUE>, and C<NVALUE>
  to cascade within a single return.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005-2011, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
CONTEXTUAL_RETURN

$fatpacked{"Contextual/Return/Failure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN_FAILURE';
  package Contextual::Return::Failure;
  our $VERSION = 0.000_003;
  
  use Contextual::Return;
  BEGIN { *_in_context = *Contextual::Return::_in_context }
  
  use warnings;
  use strict;
  
  my %handler_for;
  
  sub _FAIL_WITH {
      # Unpack and vet args...
      my $flag = shift;
      my $selector_ref;
      if (ref $flag eq 'HASH') {
          $selector_ref = $flag;
          $flag = undef;
      }
      else {
          $selector_ref = shift;
          die _in_context 'Usage: FAIL_WITH $flag_opt, \%selector, @args'
              if ref $selector_ref ne 'HASH';
      }
      die _in_context "Selector values must be sub refs"
          if grep {ref ne 'CODE'} values %{$selector_ref};
  
      # Search for handler sub;
      my $handler;
      if (defined $flag) {
          ARG:
          while (@_) {
              last ARG if shift(@_) eq $flag;
          }
          my $selector = shift @_;
          if (ref $selector eq 'CODE') {
              $handler = $selector;
              @_ = ();
          }
          else {
              @_ = $selector;
          }
      }
  
      SELECTION:
      for my $selection (reverse @_) {
          if (exists $selector_ref->{$selection}) {
              $handler = $selector_ref->{$selection};
              last SELECTION;
          }
          elsif ($flag) {
              die _in_context "Invalid option: $flag => $selection";
          }
      }
  
      # (Re)set handler...
      if ($handler) {
          my $caller_loc = join '|', (CORE::caller 1)[0,1];
          if (exists $handler_for{$caller_loc}) {
              warn _in_context "FAIL handler for package ", scalar CORE::caller, " redefined";
          }
          $handler_for{$caller_loc} = $handler;
      }
  };
  
  sub _FAIL (;&) {
      # Generate args...
      my $arg_generator_ref = shift;
      my @args;
      if ($arg_generator_ref) {
          package DB;
          ()=CORE::caller(1);
          @args = $arg_generator_ref->(@DB::args);
      }
  
      # Handle user-defined failure semantics...
      my $caller_loc = join '|', (CORE::caller 1)[0,1];
      if (exists $handler_for{$caller_loc} ) {
          # Fake out caller() and Carp...
          local $Contextual::Return::uplevel = 1;
  
          return $handler_for{$caller_loc}->(@args);
      }
  
      my $exception = @args == 1 ? $args[0]
                    : @args > 0  ? join(q{}, @args)
                    :              "Call to " . (CORE::caller 1)[3] . "() failed"
                    ;
  
      # Join message with croak() semantics, if string...
      if (!ref $exception) {
          $exception .= _in_context @_;
      }
  
  #    # Check for immediate failure...
  #    use Want qw( want );
  #    return 0 if want 'BOOL';
  #    die $exception if !want 'SCALAR';
  
      # Return a delayed failure object...
      return
          BOOL    { 0 }
          DEFAULT {
              if (ref $exception) {
                  my $message = "$exception";
                  $message =~ s/$/\n/;
                  die _in_context $message, "Attempted to use failure value";
              }
              else {
                  die _in_context $exception, "Attempted to use failure value";
              }
          }
          METHOD {
              error => sub { _in_context $exception }
          }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Contextual::Return::Failure - Utility module for Contextual::Return
  
  =head1 NOTE
  
  Contains no user serviceable parts. See L<Contextual::Return> instead.
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2006, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
CONTEXTUAL_RETURN_FAILURE

$fatpacked{"File/Find/Rule.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_FIND_RULE';
  #       $Id$
  
  package File::Find::Rule;
  use strict;
  use File::Spec;
  use Text::Glob 'glob_to_regex';
  use Number::Compare;
  use Carp qw/croak/;
  use File::Find (); # we're only wrapping for now
  
  our $VERSION = '0.33';
  
  # we'd just inherit from Exporter, but I want the colon
  sub import {
      my $pkg = shift;
      my $to  = caller;
      for my $sym ( qw( find rule ) ) {
          no strict 'refs';
          *{"$to\::$sym"} = \&{$sym};
      }
      for (grep /^:/, @_) {
          my ($extension) = /^:(.*)/;
          eval "require File::Find::Rule::$extension";
          croak "couldn't bootstrap File::Find::Rule::$extension: $@" if $@;
      }
  }
  
  =head1 NAME
  
  File::Find::Rule - Alternative interface to File::Find
  
  =head1 SYNOPSIS
  
    use File::Find::Rule;
    # find all the subdirectories of a given directory
    my @subdirs = File::Find::Rule->directory->in( $directory );
  
    # find all the .pm files in @INC
    my @files = File::Find::Rule->file()
                                ->name( '*.pm' )
                                ->in( @INC );
  
    # as above, but without method chaining
    my $rule =  File::Find::Rule->new;
    $rule->file;
    $rule->name( '*.pm' );
    my @files = $rule->in( @INC );
  
  =head1 DESCRIPTION
  
  File::Find::Rule is a friendlier interface to File::Find.  It allows
  you to build rules which specify the desired files and directories.
  
  =cut
  
  # the procedural shim
  
  *rule = \&find;
  sub find {
      my $object = __PACKAGE__->new();
      my $not = 0;
  
      while (@_) {
          my $method = shift;
          my @args;
  
          if ($method =~ s/^\!//) {
              # jinkies, we're really negating this
              unshift @_, $method;
              $not = 1;
              next;
          }
          unless (defined prototype $method) {
              my $args = shift;
              @args = ref $args eq 'ARRAY' ? @$args : $args;
          }
          if ($not) {
              $not = 0;
              @args = $object->new->$method(@args);
              $method = "not";
          }
  
          my @return = $object->$method(@args);
          return @return if $method eq 'in';
      }
      $object;
  }
  
  
  =head1 METHODS
  
  =over
  
  =item C<new>
  
  A constructor.  You need not invoke C<new> manually unless you wish
  to, as each of the rule-making methods will auto-create a suitable
  object if called as class methods.
  
  =cut
  
  sub new {
      my $referent = shift;
      my $class = ref $referent || $referent;
      bless {
          rules    => [],
          subs     => {},
          iterator => [],
          extras   => {},
          maxdepth => undef,
          mindepth => undef,
      }, $class;
  }
  
  sub _force_object {
      my $object = shift;
      $object = $object->new()
        unless ref $object;
      $object;
  }
  
  =back
  
  =head2 Matching Rules
  
  =over
  
  =item C<name( @patterns )>
  
  Specifies names that should match.  May be globs or regular
  expressions.
  
   $set->name( '*.mp3', '*.ogg' ); # mp3s or oggs
   $set->name( qr/\.(mp3|ogg)$/ ); # the same as a regex
   $set->name( 'foo.bar' );        # just things named foo.bar
  
  =cut
  
  sub _flatten {
      my @flat;
      while (@_) {
          my $item = shift;
          ref $item eq 'ARRAY' ? push @_, @{ $item } : push @flat, $item;
      }
      return @flat;
  }
  
  sub name {
      my $self = _force_object shift;
      my @names = map { ref $_ eq "Regexp" ? $_ : glob_to_regex $_ } _flatten( @_ );
  
      push @{ $self->{rules} }, {
          rule => 'name',
          code => join( ' || ', map { "m{$_}" } @names ),
          args => \@_,
      };
  
      $self;
  }
  
  =item -X tests
  
  Synonyms are provided for each of the -X tests. See L<perlfunc/-X> for
  details.  None of these methods take arguments.
  
    Test | Method               Test |  Method
   ------|-------------        ------|----------------
     -r  |  readable             -R  |  r_readable
     -w  |  writeable            -W  |  r_writeable
     -w  |  writable             -W  |  r_writable
     -x  |  executable           -X  |  r_executable
     -o  |  owned                -O  |  r_owned
         |                           |
     -e  |  exists               -f  |  file
     -z  |  empty                -d  |  directory
     -s  |  nonempty             -l  |  symlink
         |                       -p  |  fifo
     -u  |  setuid               -S  |  socket
     -g  |  setgid               -b  |  block
     -k  |  sticky               -c  |  character
         |                       -t  |  tty
     -M  |  modified                 |
     -A  |  accessed             -T  |  ascii
     -C  |  changed              -B  |  binary
  
  Though some tests are fairly meaningless as binary flags (C<modified>,
  C<accessed>, C<changed>), they have been included for completeness.
  
   # find nonempty files
   $rule->file,
        ->nonempty;
  
  =cut
  
  use vars qw( %X_tests );
  %X_tests = (
      -r  =>  readable           =>  -R  =>  r_readable      =>
      -w  =>  writeable          =>  -W  =>  r_writeable     =>
      -w  =>  writable           =>  -W  =>  r_writable      =>
      -x  =>  executable         =>  -X  =>  r_executable    =>
      -o  =>  owned              =>  -O  =>  r_owned         =>
  
      -e  =>  exists             =>  -f  =>  file            =>
      -z  =>  empty              =>  -d  =>  directory       =>
      -s  =>  nonempty           =>  -l  =>  symlink         =>
                                 =>  -p  =>  fifo            =>
      -u  =>  setuid             =>  -S  =>  socket          =>
      -g  =>  setgid             =>  -b  =>  block           =>
      -k  =>  sticky             =>  -c  =>  character       =>
                                 =>  -t  =>  tty             =>
      -M  =>  modified                                       =>
      -A  =>  accessed           =>  -T  =>  ascii           =>
      -C  =>  changed            =>  -B  =>  binary          =>
     );
  
  for my $test (keys %X_tests) {
      my $sub = eval 'sub () {
          my $self = _force_object shift;
          push @{ $self->{rules} }, {
              code => "' . $test . ' \$_",
              rule => "'.$X_tests{$test}.'",
          };
          $self;
      } ';
      no strict 'refs';
      *{ $X_tests{$test} } = $sub;
  }
  
  
  =item stat tests
  
  The following C<stat> based methods are provided: C<dev>, C<ino>,
  C<mode>, C<nlink>, C<uid>, C<gid>, C<rdev>, C<size>, C<atime>,
  C<mtime>, C<ctime>, C<blksize>, and C<blocks>.  See L<perlfunc/stat>
  for details.
  
  Each of these can take a number of targets, which will follow
  L<Number::Compare> semantics.
  
   $rule->size( 7 );         # exactly 7
   $rule->size( ">7Ki" );    # larger than 7 * 1024 * 1024 bytes
   $rule->size( ">=7" )
        ->size( "<=90" );    # between 7 and 90, inclusive
   $rule->size( 7, 9, 42 );  # 7, 9 or 42
  
  =cut
  
  use vars qw( @stat_tests );
  @stat_tests = qw( dev ino mode nlink uid gid rdev
                    size atime mtime ctime blksize blocks );
  {
      my $i = 0;
      for my $test (@stat_tests) {
          my $index = $i++; # to close over
          my $sub = sub {
              my $self = _force_object shift;
  
              my @tests = map { Number::Compare->parse_to_perl($_) } @_;
  
              push @{ $self->{rules} }, {
                  rule => $test,
                  args => \@_,
                  code => 'do { my $val = (stat $_)['.$index.'] || 0;'.
                    join ('||', map { "(\$val $_)" } @tests ).' }',
              };
              $self;
          };
          no strict 'refs';
          *$test = $sub;
      }
  }
  
  =item C<any( @rules )>
  
  =item C<or( @rules )>
  
  Allows shortcircuiting boolean evaluation as an alternative to the
  default and-like nature of combined rules.  C<any> and C<or> are
  interchangeable.
  
   # find avis, movs, things over 200M and empty files
   $rule->any( File::Find::Rule->name( '*.avi', '*.mov' ),
               File::Find::Rule->size( '>200M' ),
               File::Find::Rule->file->empty,
             );
  
  =cut
  
  sub any {
      my $self = _force_object shift;
      # compile all the subrules to code fragments
      push @{ $self->{rules} }, {
          rule => "any",
          code => '(' . join( ' || ', map '( ' . $_->_compile . ' )', @_ ). ')',
          args => \@_,
      };
      
      # merge all the subs hashes of the kids into ourself
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *or = \&any;
  
  =item C<none( @rules )>
  
  =item C<not( @rules )>
  
  Negates a rule.  (The inverse of C<any>.)  C<none> and C<not> are
  interchangeable.
  
    # files that aren't 8.3 safe
    $rule->file
         ->not( $rule->new->name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );
  
  =cut
  
  sub not {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'not',
          args => \@_,
          code => '(' . join ( ' && ', map { "!(". $_->_compile . ")" } @_ ) . ")",
      };
      
      # merge all the subs hashes into us
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *none = \&not;
  
  =item C<prune>
  
  Traverse no further.  This rule always matches.
  
  =cut
  
  sub prune () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} },
        {
         rule => 'prune',
         code => '$File::Find::prune = 1'
        };
      $self;
  }
  
  =item C<discard>
  
  Don't keep this file.  This rule always matches.
  
  =cut
  
  sub discard () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'discard',
          code => '$discarded = 1',
      };
      $self;
  }
  
  =item C<exec( \&subroutine( $shortname, $path, $fullname ) )>
  
  Allows user-defined rules.  Your subroutine will be invoked with C<$_>
  set to the current short name, and with parameters of the name, the
  path you're in, and the full relative filename.
  
  Return a true value if your rule matched.
  
   # get things with long names
   $rules->exec( sub { length > 20 } );
  
  =cut
  
  sub exec {
      my $self = _force_object shift;
      my $code = shift;
  
      push @{ $self->{rules} }, {
          rule => 'exec',
          code => $code,
      };
      $self;
  }
  
  =item C<grep( @specifiers )>
  
  Opens a file and tests it each line at a time.
  
  For each line it evaluates each of the specifiers, stopping at the
  first successful match.  A specifier may be a regular expression or a
  subroutine.  The subroutine will be invoked with the same parameters
  as an ->exec subroutine.
  
  It is possible to provide a set of negative specifiers by enclosing
  them in anonymous arrays.  Should a negative specifier match the
  iteration is aborted and the clause is failed.  For example:
  
   $rule->grep( qr/^#!.*\bperl/, [ sub { 1 } ] );
  
  Is a passing clause if the first line of a file looks like a perl
  shebang line.
  
  =cut
  
  sub grep {
      my $self = _force_object shift;
      my @pattern = map {
          ref $_
            ? ref $_ eq 'ARRAY'
              ? map { [ ( ref $_ ? $_ : qr/$_/ ) => 0 ] } @$_
              : [ $_ => 1 ]
            : [ qr/$_/ => 1 ]
        } @_;
  
      $self->exec( sub {
          local *FILE;
          open FILE, $_ or return;
          local ($_, $.);
          while (<FILE>) {
              for my $p (@pattern) {
                  my ($rule, $ret) = @$p;
                  return $ret
                    if ref $rule eq 'Regexp'
                      ? /$rule/
                        : $rule->(@_);
              }
          }
          return;
      } );
  }
  
  =item C<maxdepth( $level )>
  
  Descend at most C<$level> (a non-negative integer) levels of directories
  below the starting point.
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =item C<mindepth( $level )>
  
  Do not apply any tests at levels less than C<$level> (a non-negative
  integer).
  
  =item C<extras( \%extras )>
  
  Specifies extra values to pass through to C<File::File::find> as part
  of the options hash.
  
  For example this allows you to specify following of symlinks like so:
  
   my $rule = File::Find::Rule->extras({ follow => 1 });
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =cut
  
  for my $setter (qw( maxdepth mindepth extras )) {
      my $sub = sub {
          my $self = _force_object shift;
          $self->{$setter} = shift;
          $self;
      };
      no strict 'refs';
      *$setter = $sub;
  }
  
  
  =item C<relative>
  
  Trim the leading portion of any path found
  
  =cut
  
  sub relative () {
      my $self = _force_object shift;
      $self->{relative} = 1;
      $self;
  }
  
  =item C<not_*>
  
  Negated version of the rule.  An effective shortand related to ! in
  the procedural interface.
  
   $foo->not_name('*.pl');
  
   $foo->not( $foo->new->name('*.pl' ) );
  
  =cut
  
  sub DESTROY {}
  sub AUTOLOAD {
      our $AUTOLOAD;
      $AUTOLOAD =~ /::not_([^:]*)$/
        or croak "Can't locate method $AUTOLOAD";
      my $method = $1;
  
      my $sub = sub {
          my $self = _force_object shift;
          $self->not( $self->new->$method(@_) );
      };
      {
          no strict 'refs';
          *$AUTOLOAD = $sub;
      }
      &$sub;
  }
  
  =back
  
  =head2 Query Methods
  
  =over
  
  =item C<in( @directories )>
  
  Evaluates the rule, returns a list of paths to matching files and
  directories.
  
  =cut
  
  sub in {
      my $self = _force_object shift;
  
      my @found;
      my $fragment = $self->_compile;
      my %subs = %{ $self->{subs} };
  
      warn "relative mode handed multiple paths - that's a bit silly\n"
        if $self->{relative} && @_ > 1;
  
      my $topdir;
      my $code = 'sub {
          (my $path = $File::Find::name)  =~ s#^(?:\./+)+##;
          my @args = ($_, $File::Find::dir, $path);
          my $maxdepth = $self->{maxdepth};
          my $mindepth = $self->{mindepth};
          my $relative = $self->{relative};
  
          # figure out the relative path and depth
          my $relpath = $File::Find::name;
          $relpath =~ s{^\Q$topdir\E/?}{};
          my $depth = scalar File::Spec->splitdir($relpath);
          #print "name: \'$File::Find::name\' ";
          #print "relpath: \'$relpath\' depth: $depth relative: $relative\n";
  
          defined $maxdepth && $depth >= $maxdepth
             and $File::Find::prune = 1;
  
          defined $mindepth && $depth < $mindepth
             and return;
  
          #print "Testing \'$_\'\n";
  
          my $discarded;
          return unless ' . $fragment . ';
          return if $discarded;
          if ($relative) {
              push @found, $relpath if $relpath ne "";
          }
          else {
              push @found, $path;
          }
      }';
  
      #use Data::Dumper;
      #print Dumper \%subs;
      #warn "Compiled sub: '$code'\n";
  
      my $sub = eval "$code" or die "compile error '$code' $@";
      for my $path (@_) {
          # $topdir is used for relative and maxdepth
          $topdir = $path;
          # slice off the trailing slash if there is one (the
          # maxdepth/mindepth code is fussy)
          $topdir =~ s{/?$}{}
            unless $topdir eq '/';
          $self->_call_find( { %{ $self->{extras} }, wanted => $sub }, $path );
      }
  
      return @found;
  }
  
  sub _call_find {
      my $self = shift;
      File::Find::find( @_ );
  }
  
  sub _compile {
      my $self = shift;
  
      return '1' unless @{ $self->{rules} };
      my $code = join " && ", map {
          if (ref $_->{code}) {
              my $key = "$_->{code}";
              $self->{subs}{$key} = $_->{code};
              "\$subs{'$key'}->(\@args) # $_->{rule}\n";
          }
          else {
              "( $_->{code} ) # $_->{rule}\n";
          }
      } @{ $self->{rules} };
  
      #warn $code;
      return $code;
  }
  
  =item C<start( @directories )>
  
  Starts a find across the specified directories.  Matching items may
  then be queried using L</match>.  This allows you to use a rule as an
  iterator.
  
   my $rule = File::Find::Rule->file->name("*.jpeg")->start( "/web" );
   while ( defined ( my $image = $rule->match ) ) {
       ...
   }
  
  =cut
  
  sub start {
      my $self = _force_object shift;
  
      $self->{iterator} = [ $self->in( @_ ) ];
      $self;
  }
  
  =item C<match>
  
  Returns the next file which matches, false if there are no more.
  
  =cut
  
  sub match {
      my $self = _force_object shift;
  
      return shift @{ $self->{iterator} };
  }
  
  1;
  
  __END__
  
  =back
  
  =head2 Extensions
  
  Extension modules are available from CPAN in the File::Find::Rule
  namespace.  In order to use these extensions either use them directly:
  
   use File::Find::Rule::ImageSize;
   use File::Find::Rule::MMagic;
  
   # now your rules can use the clauses supplied by the ImageSize and
   # MMagic extension
  
  or, specify that File::Find::Rule should load them for you:
  
   use File::Find::Rule qw( :ImageSize :MMagic );
  
  For notes on implementing your own extensions, consult
  L<File::Find::Rule::Extending>
  
  =head2 Further examples
  
  =over
  
  =item Finding perl scripts
  
   my $finder = File::Find::Rule->or
    (
     File::Find::Rule->name( '*.pl' ),
     File::Find::Rule->exec(
                            sub {
                                if (open my $fh, $_) {
                                    my $shebang = <$fh>;
                                    close $fh;
                                    return $shebang =~ /^#!.*\bperl/;
                                }
                                return 0;
                            } ),
    );
  
  Based upon this message http://use.perl.org/comments.pl?sid=7052&cid=10842
  
  =item ignore CVS directories
  
   my $rule = File::Find::Rule->new;
   $rule->or($rule->new
                  ->directory
                  ->name('CVS')
                  ->prune
                  ->discard,
             $rule->new);
  
  Note here the use of a null rule.  Null rules match anything they see,
  so the effect is to match (and discard) directories called 'CVS' or to
  match anything.
  
  =back
  
  =head1 TWO FOR THE PRICE OF ONE
  
  File::Find::Rule also gives you a procedural interface.  This is
  documented in L<File::Find::Rule::Procedural>
  
  =head1 EXPORTS
  
  L</find>, L</rule>
  
  =head1 TAINT MODE INTERACTION
  
  As of 0.32 File::Find::Rule doesn't capture the current working directory in
  a taint-unsafe manner.  File::Find itself still does operations that the taint
  system will flag as insecure but you can use the L</extras> feature to ask
  L<File::Find> to internally C<untaint> file paths with a regex like so:
  
      my $rule = File::Find::Rule->extras({ untaint => 1 });
      
  Please consult L<File::Find>'s documentation for C<untaint>,
  C<untaint_pattern>, and C<untaint_skip> for more information.
  
  =head1 BUGS
  
  The code makes use of the C<our> keyword and as such requires perl version
  5.6.0 or newer.
  
  Currently it isn't possible to remove a clause from a rule object.  If
  this becomes a significant issue it will be addressed.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net> with input gained from this
  use.perl discussion: http://use.perl.org/~richardc/journal/6467
  
  Additional proofreading and input provided by Kake, Greg McCarroll,
  and Andy Lester andy@petdance.com.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Find>, L<Text::Glob>, L<Number::Compare>, find(1)
  
  If you want to know about the procedural interface, see
  L<File::Find::Rule::Procedural>, and if you have an idea for a neat
  extension L<File::Find::Rule::Extending>
  
  =cut
  
  Implementation notes:
  
  $self->rules is an array of hashrefs.  it may be a code fragment or a call
  to a subroutine.
  
  Anonymous subroutines are stored in the $self->subs hashref keyed on the
  stringfied version of the coderef.
  
  When one File::Find::Rule object is combined with another, such as in the any
  and not operations, this entire hash is merged.
  
  The _compile method walks the rules element and simply glues the code
  fragments together so they can be compiled into an anyonymous File::Find
  match sub for speed
  
  
  [*] There's probably a win to be made with the current model in making
  stat calls use C<_>.  For
  
    find( file => size => "> 20M" => size => "< 400M" );
  
  up to 3 stats will happen for each candidate.  Adding a priming _
  would be a bit blind if the first operation was C< name => 'foo' >,
  since that can be tested by a single regex.  Simply checking what the
  next type of operation doesn't work since any arbritary exec sub may
  or may not stat.  Potentially worse, they could stat something else
  like so:
  
    # extract from the worlds stupidest make(1)
    find( exec => sub { my $f = $_; $f =~ s/\.c$/.o/ && !-e $f } );
  
  Maybe the best way is to treat C<_> as invalid after calling an exec,
  and doc that C<_> will only be meaningful after stat and -X tests if
  they're wanted in exec blocks.
FILE_FIND_RULE

$fatpacked{"IO/Prompter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_PROMPTER';
  use 5.010;
  package IO::Prompter;
  
  use warnings;
  no if $] >= 5.018000, warnings => 'experimental';
  use strict;
  use Carp;
  use Contextual::Return qw< PUREBOOL BOOL SCALAR METHOD VOID LIST RETOBJ >;
  use Scalar::Util qw< openhandle looks_like_number >;
  use Symbol       qw< qualify_to_ref >;
  
  our $VERSION = '0.004013';
  
  my $fake_input;     # Flag that we're faking input from the source
  
  my $DEFAULT_TERM_WIDTH   = 80;
  my $DEFAULT_VERBATIM_KEY = "\cV";
  
  # Completion control...
  my $COMPLETE_DISPLAY_FIELDS = 4;  #...per line
  my $COMPLETE_DISPLAY_GAP    = 3;  #...spaces
  
  my $COMPLETE_KEY  = $ENV{IO_PROMPTER_COMPLETE_KEY} // qq{\t};
  my $COMPLETE_HIST = $ENV{IO_PROMPTER_HISTORY_KEY}  // qq{\cR};
  my $COMPLETE_NEXT = qq{\cN};
  my $COMPLETE_PREV = qq{\cP};
  
  my $COMPLETE_INIT  = qr{ [$COMPLETE_KEY$COMPLETE_HIST] }xms;
  my $COMPLETE_CYCLE = qr{ [$COMPLETE_NEXT$COMPLETE_PREV] }xms;
  
  my %COMPLETE_MODE = (
      $COMPLETE_KEY
          => [split /\s+/, $ENV{IO_PROMPTER_COMPLETE_MODES}//q{list+longest  full}],
      $COMPLETE_HIST
          => [split /\s+/, $ENV{IO_PROMPTER_HISTORY_MODES} // q{full}],
  );
  
  my $FAKE_ESC    = "\e";
  my $FAKE_INSERT = "\cF";
  my $MENU_ESC    = "\e";
  my $MENU_MK     = '__M_E_N_U__';
  
  my %EDIT = (
      BACK    => qq{\cB},
      FORWARD => qq{\cF},
      START   => qq{\cA},
      END     => qq{\cE},
  );
  my $EDIT_KEY = '['.join(q{},values %EDIT).']';
  
  # Extracting key letters...
  my $KL_EXTRACT = qr{ (?| \[  ( [[:alnum:]]++ )  \]
                         | \(  ( [[:alnum:]]++ )  \)
                         | \<  ( [[:alnum:]]++ )  \>
                         | \{  ( [[:alnum:]]++ )  \}
                       )
                     }xms;
  my $KL_DEF_EXTRACT = qr{ \[  ( [[:alnum:]]++ )  \] }xms;
  
  
  # Auxiliary prompts for -Yes => N construct...
  my @YESNO_PROMPTS = (
      q{Really?},
      q{You're quite certain?},
      q{Definitely?},
      q{You mean it?},
      q{You truly mean it?},
      q{You're sure?},
      q{Have you thought this through?},
      q{You understand the consequences?},
  );
  
  
  # Remember returned values for history completion...
  my %history_cache;
  
  # Track lexically-scoped default options and wrapper subs...
  my @lexical_options  = [];
  my @lexical_wrappers = [];
  
  # Export the prompt() sub...
  sub import {
      my (undef, $config_data, @other_args) = @_;
  
      # Handle -argv requests...
      if (defined $config_data && $config_data eq '-argv') {
          scalar prompt(-argv, @other_args);
      }
  
      # Handle lexical options...
      elsif (ref $config_data eq 'ARRAY') {
          push @lexical_options, $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
      }
  
      # Handle lexical wrappers...
      elsif (ref $config_data eq 'HASH') {
          push @lexical_options, [];
          $lexical_wrappers[ $#lexical_options ] = $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
          for my $subname (keys %{$config_data}) {
              my @args = @{$config_data->{$subname}};
              no strict 'refs';
              no warnings 'redefine';
              *{caller().'::'.$subname} = sub {
                  my $scope_number = (caller 0)[10]{'IO::Prompter::scope_number'};
                  return prompt(@{$lexical_wrappers[$scope_number]{$subname}//[]}, @_);
              };
          }
      }
  
      # Handler faked input specifications...
      elsif (defined $config_data) {
          $fake_input = $config_data;
      }
  
      no strict 'refs';
      *{caller().'::prompt'} = \&prompt;
  }
  
  # Prompt for, read, vet, and return input...
  sub prompt {
      # Reclaim full control of print statements while prompting...
      local $\ = '';
  
      # Locate any lexical default options...
      my $hints_hash = (caller 0)[10] // {};
      my $scope_num = $hints_hash->{'IO::Prompter::scope_number'} // 0;
  
      # Extract and sanitize configuration arguments...
      my $opt_ref = _decode_args(@{$lexical_options[$scope_num]}, @_);
  
      _warn( void => 'Useless use of prompt() in void context' )
          if VOID && !$opt_ref->{-void};
  
      # Set up yesno prompts if required...
      my @yesno_prompts
          = ($opt_ref->{-yesno}{count}//0) > 1 ? @YESNO_PROMPTS : ();
  
      # Work out where the prompts go, and where the input comes from...
      my $in_filehandle  = $opt_ref->{-in}  // _open_ARGV();
      my $out_filehandle = $opt_ref->{-out} // qualify_to_ref(select);
      if (!openhandle $in_filehandle) {
          open my $fh, '<', $in_filehandle
              or _opt_err('Unacceptable', '-in', 'valid filehandle or filename');
          $in_filehandle = $fh;
      }
      if (!openhandle $out_filehandle) {
          open my $fh, '>', $out_filehandle
              or _opt_err('Unacceptable', '-out', 'valid filehandle or filename');
          $out_filehandle = $fh;
      }
  
      # Track timeouts...
      my $in_pos = do { no warnings;  tell $in_filehandle } // 0;
  
      # Short-circuit if not valid handles...
      return if !openhandle($in_filehandle) || !openhandle($out_filehandle);
  
      # Work out how they're arriving and departing...
      my $outputter_ref = -t $in_filehandle && -t $out_filehandle
                              ? _std_printer_to($out_filehandle, $opt_ref)
                              : _null_printer()
                              ;
      my $inputter_ref = _generate_unbuffered_reader_from(
                              $in_filehandle, $outputter_ref, $opt_ref
                         );
  
      # Clear the screen if requested to...
      if ($opt_ref->{-wipe}) {
          $outputter_ref->(-nostyle => "\n" x 1000);
      }
  
      # Handle menu structures...
      my $input;
      REPROMPT_YESNO:
      if ($opt_ref->{-menu}) {
          # Remember top of (possibly nested) menu...
          my @menu = ( $opt_ref->{-menu} );
          my $top_prompt = $opt_ref->{-prompt};
          $top_prompt =~ s{$MENU_MK}{$opt_ref->{-menu}{prompt}}xms;
          $menu[-1]{prompt} = $top_prompt;
  
          MENU:
          while (1) {
              # Track the current level...
              $opt_ref->{-menu_curr_level} = $menu[-1]{value_for};
  
              # Show menu and retreive choice...
              $outputter_ref->(-style => $menu[-1]{prompt});
              my $tag = $inputter_ref->($menu[-1]{constraint});
  
              # Handle a failure by exiting the loop...
              last MENU if !defined $tag;
              $tag =~ s{\A\s*(\S*).*}{$1}xms;
  
              # Handle <ESC> by moving up menu stack...
              if ($tag eq $MENU_ESC) {
                  $input = undef;
                  last MENU if @menu <= 1;
                  pop @menu;
                  next MENU;
              }
  
              # Handle defaults by selecting and ejecting...
              if ($tag =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
                  $input = $tag;
                  last MENU;
              }
  
              # Otherwise, retrieve value for selected tag and exit if not a nested menu...
              $input = $menu[-1]{value_for}{$tag};
              last MENU if !ref $input;
  
              # Otherwise, go down the menu one level...
              push @menu,
                  _build_menu($input,
                               "Select from $menu[-1]{key_for}{$tag}: ",
                               $opt_ref->{-number} || $opt_ref->{-integer}
                  );
              $menu[-1]{prompt} .= '> ';
          }
      }
  
      # Otherwise, simply ask and ye shall receive...
      else {
          $outputter_ref->(-style => $opt_ref->{-prompt});
          $input = $inputter_ref->();
      }
  
      # Provide default value if available and necessary...
      my $defaulted = 0;
      if (defined $input && $input =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # The input line is usually chomped before being returned...
      if (defined $input && !$opt_ref->{-line}) {
          chomp $input;
      }
  
      # Check for a value indicating failure...
      if (exists $opt_ref->{-fail} && $input ~~ $opt_ref->{-fail}) {
          $input = undef;
      }
  
      # Setting @ARGV is a special case; process it like a command-line...
      if ($opt_ref->{-argv}) {
          @ARGV = map { _shell_expand($_) }
                      grep {defined}
                              $input =~ m{
                                      ( '  [^'\\]* (?: \\. [^'\\]* )* ' )
                                  |   ( "  [^"\\]* (?: \\. [^"\\]* )* " )
                                  |   (?: ^ | \s)  ( [^\s"'] \S*        )
                              }gxms;
          return 1;
      }
  
      # "Those who remember history are enabled to repeat it"...
      if (defined $input and $opt_ref->{-history} ne 'NONE') {
          my $history_set = $history_cache{ $opt_ref->{-history} } //= [] ;
          @{ $history_set } = ($input, grep { $_ ne $input } @{ $history_set });
      }
  
      # If input timed out insert the default, if any...
      my $timedout = $in_pos == do{ no warnings; tell $in_filehandle } // 0;
      if ($timedout && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # A defined input is a successful input...
      my $succeeded = defined $input;
  
      # The -yesno variants also need a 'y' to be successful...
      if ($opt_ref->{-yesno}{count}) {
          $succeeded &&= $input =~ m{\A \s* y}ixms;
          if ($succeeded && $opt_ref->{-yesno}{count} > 1) {
              my $count = --$opt_ref->{-yesno}{count};
              $opt_ref->{-prompt}
                  = @yesno_prompts ? shift(@yesno_prompts) . q{ }
                  : $count > 1     ? qq{Please confirm $count more times }
                  :                   q{Please confirm one last time }
                  ;
              goto REPROMPT_YESNO;    # Gasp, yes goto is the cleanest way!
          }
      }
  
      # Verbatim return doesn't do fancy tricks...
      if ($opt_ref->{-verbatim}) {
          return $input // ();
      }
  
      # Failure in a list context returns nothing...
      return if LIST && !$succeeded;
  
      # Otherwise, be context sensitive...
      return
          PUREBOOL { $_ = RETOBJ; next handler;      }
              BOOL { $succeeded;                     }
            SCALAR { $input;                         }
            METHOD {
                      defaulted => sub { $defaulted  },
                      timedout  => sub {
                          return q{} if !$timedout;
                          return "timed out after $opt_ref->{-timeout} second"
                               . ($opt_ref->{-timeout} == 1 ? q{} : q{s});
                      },
                   };
  }
  
  
  # Simulate a command line expansion for the -argv option...
  sub _shell_expand {
      my ($text) = @_;
  
      # Single-quoted text is literal...
      if ($text =~ m{\A ' (.*) ' \z}xms) {
          return $1;
      }
  
      # Everything else has shell variables expanded...
      my $ENV_PAT = join '|', reverse sort keys %ENV;
      $text =~ s{\$ ($ENV_PAT)}{$ENV{$1}}gxms;
  
      # Double-quoted text isn't globbed...
      if ($text =~ m{\A " (.*) " \z}xms) {
          return $1;
      }
  
      # Everything else is...
      return glob($text);
  }
  
  # No completion is the default...
  my $DEFAULT_COMPLETER = sub { q{} };
  
  # Translate std constraints...
  my %STD_CONSTRAINT = (
      positive  => sub { $_ > 0      },
      negative  => sub { $_ < 0      },
      zero      => sub { $_ == 0     },
      even      => sub { $_ % 2 == 0 },
      odd       => sub { $_ % 2 != 0 },
  );
  
  # Create abbreviations...
  $STD_CONSTRAINT{pos} = $STD_CONSTRAINT{positive};
  $STD_CONSTRAINT{neg} = $STD_CONSTRAINT{negative};
  
  # Create antitheses...
  for my $constraint (keys %STD_CONSTRAINT) {
      my $implementation = $STD_CONSTRAINT{$constraint};
      $STD_CONSTRAINT{"non$constraint"}
          = sub { ! $implementation->(@_) };
  }
  
  # Special style specifications require decoding...
  
  sub _decode_echo {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no echoes...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_echostyle {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no styles...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_style {
      # No special prompt styles (yet)...
      return shift;
  }
  
  # Generate safe closure around active sub...
  sub _gen_wrapper_for {
      my ($arg) = @_;
      return ref $arg ne 'CODE'
             ? sub { $arg }
             : sub { eval { for (shift) { no warnings; return $arg->($_) // $_ } } };
  }
  
  # Create recognizer...
  my $STD_CONSTRAINT
      = '^(?:' . join('|', reverse sort keys %STD_CONSTRAINT) . ')';
  
  # Translate name constraints to implementations...
  sub _standardize_constraint {
      my ($option_type, $constraint_spec) = @_;
  
      return ("be an acceptable $option_type", $constraint_spec)
          if ref $constraint_spec;
  
      my @constraint_names = split /\s+/, $constraint_spec;
      my @constraints =
          map { $STD_CONSTRAINT{$_}
                // _opt_err('invalid',-$option_type,'"pos", "neg", "even", etc.')
              } @constraint_names;
  
      return (
          'be ' . join(' and ', @constraint_names),
          sub {
              my ($compare_val) = @_;
              for my $constraint (@constraints) {
                  return 0 if !$constraint->($compare_val);
              }
              return 1;
          }
      );
  }
  
  
  # Convert args to prompt + options hash...
  sub _decode_args {
      my %option = (
          -prompt    => undef,
          -complete  => $DEFAULT_COMPLETER,
          -must      => {},
          -history   => 'DEFAULT',
          -style     => sub{ q{} },
          -nostyle   => sub{ q{} },
          -echostyle => sub{ q{} },
          -echo      => sub { shift },
          -return    => sub { "\n" },
      );
  
      DECODING:
      while (defined(my $arg = shift @_)) {
          if (my $type = ref $arg) {
              _warn( reserved =>
                  'prompt(): Unexpected argument (' . lc($type) . ' ref) ignored'
              );
          }
          else {
              my $redo;
              given ($arg) {
                  # The sound of one hand clapping...
                  when (/^-_/) {
                      $redo = 1;
                  }
  
                  # Non-chomping option...
                  when (/^-line$/) {
                      $option{-line}++;
                  }
                  when (/^-l/) {
                      $option{-line}++;
                      $redo = 1;
                  }
  
                  # The -yesno variants...
                  when (/^-YesNo$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[YN]' => qr{\A \s* [YN] }xms },
                          count  => $count,
                      };
                  }
                  when (/^-YN/) {
                      $option{-yesno} = {
                          must => { '[YN]' => qr{\A \s* [YN] }xms },
                          count  => 1,
                      };
                      $redo = 2;
                  }
                  when (/^-yesno$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[yn]' => qr{\A \s* [YN] }ixms },
                          count  => $count,
                      };
                  }
                  when (/^-yn/) {
                      $option{-yesno} = {
                          must => { '[yn]' => qr{\A \s* [YN] }ixms },
                          count  => 1,
                      };
                      $redo = 2;
                  }
                  when (/^-Yes$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                          count  => $count,
                      };
                  }
                  when (/^-Y/) {
                      $option{-yesno} = {
                          must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                          count  => 1,
                      };
                      $redo = 1;
                  }
                  when (/^-yes$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = { count  => $count };
                  }
                  when (/^-y/) {
                      $option{-yesno} = { count  => 1 };
                      $redo = 1;
                  }
  
                  # Load @ARGV...
                  when (/^-argv$/) {
                      $option{-argv} = 1;
                  }
  
                  when (/^-a/) {
                      $option{-argv} = 1;
                      $redo = 1;
                  }
  
                  # Clear screen before prompt...
                  state $already_wiped;
                  when (/^-wipe(first)?$/) {
                      $option{-wipe} = $1 ? !$already_wiped : 1;
                      $already_wiped = 1;
                  }
                  when (/^-w/) {
                      $option{-wipe} = 1;
                      $already_wiped = 1;
                      $redo = 1;
                  }
  
                  # Specify a failure condition...
                  when (/^-fail$/) {
                      _opt_err('Missing', -fail, 'failure condition') if !@_;
                      $option{-fail} = shift @_;
                  }
  
                  # Specify a file request...
                  when (/^-f(?:ilenames?)?$/) {
                      $option{-must}{'0: be an existing file'} = sub { -e $_[0] };
                      $option{-must}{'1: be readable'}         = sub { -r $_[0] };
                      $option{-complete}                       = 'filenames';
                  }
  
                  # Specify prompt echoing colour/style...
                  when (/^-style/) {
                      _opt_err('Missing -style specification') if !@_;
                      my $style = _decode_style(shift @_);
                      $option{-style} = _gen_wrapper_for($style);
                  }
  
                  # Specify input colour/style...
                  when (/^-echostyle/) {
                      _opt_err('Missing -echostyle specification') if !@_;
                      my $style = _decode_echostyle(shift @_);
                      $option{-echostyle} = _gen_wrapper_for($style);
                  }
  
  
                  # Specify input and output filehandles...
                  when (/^-stdio$/) { $option{-in}  = *STDIN;
                                     $option{-out} = *STDOUT;
                                    }
                  when (/^-in$/)    { $option{-in}  = shift @_; }
                  when (/^-out$/)   { $option{-out} = shift @_; }
  
                  # Specify integer and number return value...
                  when (/^-integer$/)       {
                      $option{-integer} = 1;
                      if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                          my ($errmsg, $constraint)
                              = _standardize_constraint('integer',shift);
                          $option{-must}{$errmsg} = $constraint;
                      }
                  }
                  when (/^-num(?:ber)?$/)   {
                      $option{-number}  = 1;
                      if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                          my ($errmsg, $constraint)
                              = _standardize_constraint('number',shift);
                          $option{-must}{$errmsg} = $constraint;
                      }
                  }
                  when (/^-i/)              { $option{-integer} = 1; $redo = 1; }
                  when (/^-n/)              { $option{-number}  = 1; $redo = 1; }
  
                  # Specify void context is okay...
                  when (/^-void$/)          { $option{-void} = 1;               }
  
                  # Specify verbatim return value...
                  when (/^-verb(?:atim)?$/) { $option{-verbatim} = 1;           }
                  when (/^-v/)              { $option{-verbatim} = 1; $redo = 1;}
  
                  # Specify single character return...
                  when (/^-sing(?:le)?$/)   { $option{-single} = 1;             }
                  when (/^-[s1]/)           { $option{-single} = 1; $redo = 1;  }
  
                  # Specify a default...
                  when (/^-DEF(?:AULT)?/) {
                      _opt_err('Missing', '-DEFAULT', 'string') if !@_;
                      $option{-def} = shift @_;
                      $option{-def_nocheck} = 1;
                      _opt_err('Invalid', '-DEFAULT', 'string')
                          if ref($option{-def});
                  }
                  when (/^-def(?:ault)?/) {
                      _opt_err('Missing', '-default', 'string') if !@_;
                      $option{-def} = shift @_;
                      _opt_err('Invalid', '-default', 'string')
                          if ref($option{-def});
                  }
                  when (/^-d(.+)$/)   { $option{-def} = $1; }
  
                  # Specify a timeout...
                  when (/^-t(\d+)/)   {
                      $option{-timeout} = $1;
                      $arg =~ s{\d+}{}xms;
                      $redo = 1;
                  }
                  when (/^-timeout$/) {
                      _opt_err('Missing', -timeout, 'number of seconds') if !@_;
                      $option{-timeout} = shift @_;
                      _opt_err('Invalid', -timeout,'number of seconds')
                          if !looks_like_number($option{-timeout});
                  }
  
                  # Specify a set of input constraints...
                  when (/^-g.*/) {
                      _opt_err('Missing', -guarantee, 'input restriction') if !@_;
                      my $restriction = shift @_;
                      my $restriction_type = ref $restriction;
  
                      $option{-must}{'be a valid input'} = $restriction;
  
                      # Hashes restrict input to their keys...
                      if ($restriction_type eq 'HASH') {
                          $restriction_type = 'ARRAY';
                          $restriction = [ keys %{$restriction} ];
                      }
                      # Arrays of strings matched (and completed) char-by-char...
                      if ($restriction_type eq 'ARRAY') {
                          my @restrictions = @{$restriction};
                          $option{-guarantee}
                              = '\A(?:'
                              . join('|', map {
                                    join(q{}, map { "(?:\Q$_\E" } split(q{}, $_))
                                  . ')?' x length($_)
                                } @restrictions)
                              . ')\z'
                              ;
                          if ($option{-complete} == $DEFAULT_COMPLETER) {
                              $option{-complete} = \@restrictions;
                          }
                      }
                      # Regexes matched as-is...
                      elsif ($restriction_type eq 'Regexp') {
                          $option{-guarantee} = $restriction;
                      }
                      else {
                          _opt_err( 'Invalid', -guarantee,
                                    'array or hash reference, or regex'
                          );
                      }
                  }
  
                  # Specify a set of key letters...
                  when ('-keyletters_implement') {
                      # Extract all keys and default keys...
                      my @keys  = ($option{-prompt} =~ m{$KL_EXTRACT}gxms);
  
                      # Convert default to a -default...
                      my @defaults = ($option{-prompt} =~ m{$KL_DEF_EXTRACT}gxms);
                      if (@defaults > 1) {
                          _warn( ambiguous =>
                              "prompt(): -keyletters found too many defaults"
                          )
                      }
                      elsif (@defaults) {
                          push @_, -default => $defaults[0];
                      }
  
                      # Convert key letters to a -guarantee...
                      @keys = ( map({uc} @keys), map({lc} @keys) );
                      if (@defaults == 1) {
                          push @keys, q{};
                      }
                      push @_, -guarantee => \@keys;
  
                  }
                  when (/^-key(?:let(?:ter)?)(?:s)?/) {
                      push @_, '-keyletters_implement';
                  }
                  when (/^-k/) {
                      push @_, '-keyletters_implement';
                      $redo = 1;
                  }
  
                  # Specify a set of return constraints...
                  when (/^-must$/) {
                      _opt_err('Missing', -must, 'constraint hash') if !@_;
                      my $must = shift @_;
                      _opt_err('Invalid', -must, 'hash reference')
                          if ref($must) ne 'HASH';
                      for my $errmsg (keys %{$must}) {
                          $option{-must}{$errmsg} = $must->{$errmsg};
                      }
                  }
  
                  # Specify a history set...
                  when (/^-history/) {
                      $option{-history}
                          = @_ && $_[0] !~ /^-/ ? shift @_
                          :                       undef;
                      _opt_err('Invalid', -history, 'history set name')
                          if ref($option{-history});
                  }
                  when (/^-h(.*)/)   { $option{-history} = length($1) ? $1 : undef; }
  
                  # Specify completions...
                  when (/^-comp(?:lete)?/) {
                      _opt_err('Missing', -complete, 'completions') if !@_;
                      my $comp_spec = shift @_;
                      my $comp_type = ref($comp_spec) || $comp_spec || '???';
                      if ($comp_type =~ m{\A(?: file\w* | dir\w* | ARRAY | HASH | CODE )\Z}xms) {
                          $option{-complete} = $comp_spec;
                      }
                      else {
                          _opt_err( 'Invalid', -complete,
                                      '"filenames", "dirnames", or reference to array, hash, or subroutine');
                      }
                  }
  
                  # Specify what to echo when a character is keyed...
                  when (/^-(echo|ret(?:urn)?)$/) {
                      my $flag = $1 eq 'echo' ? '-echo' : '-return';
                      if ($flag eq '-echo' && !eval { no warnings 'deprecated'; require Term::ReadKey }) {
                          _warn( bareword => "Warning: next input will be in plaintext\n");
                      }
                      my $arg = @_ && $_[0] !~ /^-/ ? shift(@_)
                              : $flag eq '-echo'    ? q{}
                              :                       qq{\n};
                      $option{$flag} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-e(.*)/) {
                      if (!eval { no warnings 'deprecated'; require Term::ReadKey }) {
                          _warn( bareword => "Warning: next input will be in plaintext\n");
                      }
                      my $arg = $1;
                      $option{-echo} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-r(.+)/) {
                      my $arg = $1;
                      $option{-return} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-r/) {
                      $option{-return} = sub{ "\n" };
                  }
  
                  # Explicit prompt replaces implicit prompts...
                  when (/^-prompt$/) {
                      _opt_err('Missing', '-prompt', 'prompt string') if !@_;
                      $option{-prompt} = shift @_;
                      _opt_err('Invalid', '-prompt', 'string')
                          if ref($option{-prompt});
                  }
                  when (/^-p(\S*)$/) {
                      $option{-prompt} = $1;
                  }
  
                  # Menus inject a placeholder in the prompt string...
                  when (/^-menu$/) {
                      _opt_err('Missing', '-menu', 'menu specification') if !@_;
                      $option{-menu}         = ref $_[0] ? shift(@_) : \shift(@_);
                      $option{-prompt}      .= $MENU_MK;
                      $option{-def_nocheck}  = 1;
                  }
  
                  # Anything else of the form '-...' is a misspelt option...
                  when (/^-\w+$/) { _warn(misc => "prompt(): Unknown option $arg ignored"); }
  
                  # Anything else is part fo the prompt...
                  default       { $option{-prompt} .= $arg; }
              }
  
              # Handle option bundling...
              redo DECODING if $redo && $arg =~ s{\A -.{$redo} (?=.)}{-}xms;
          }
      }
  
      # Precompute top-level menu, if menuing...
      if (exists $option{-menu}) {
          $option{-menu} = _build_menu($option{-menu},
                                       undef,
                                       $option{-number}||$option{-integer}
                           );
      }
  
      # Handle return magic on -single...
      if (defined $option{-single} && length($option{-echo}('X')//'echoself')) {
          $option{-return} //= sub{ "\n" };
      }
  
      # Adjust prompt as necessary...
      if ($option{-argv}) {
          my $progname = $option{-prompt} // $0;
          $progname =~ s{^.*/}{}xms;
  
          my $HINT = '[enter command line args here]';
          $option{-prompt} = "> $progname  $HINT\r> $progname ";
  
          $option{-complete} = 'filenames';
  
          my $not_first;
          $option{-echo}   = sub{
              my $char = shift;
              $option{-prompt} = "> $progname ";  # Sneaky resetting to handle completions
              return $char if $not_first++;
              return "\r> $progname  " . (q{ } x length $HINT) . "\r> $progname $char";
          }
      }
      elsif (!defined $option{-prompt}) {
          $option{-prompt} = '> ';
      }
      elsif ($option{-prompt} =~ m{ \S \z}xms) {
          # If prompt doesn't end in whitespace, make it so...
          $option{-prompt} .= ' ';
      }
      elsif ($option{-prompt} =~ m{ (.*) \n \z}xms) {
          # If prompt ends in a newline, remove it...
          $option{-prompt} = $1;
      }
  
      # Steal history set name if -h given without a specification...
      $option{-history} //= $option{-prompt};
  
      # Verify any default satisfies any constraints...
      if (exists $option{-def} && !$option{-def_nocheck}) {
          if (!_verify_input_constraints(\q{},undef,undef,\%option)) {
              _warn( misc =>
                  'prompt(): -default value does not satisfy -must constraints'
              );
          }
      }
  
      return \%option;
  }
  
  #====[ Error Handlers ]=========================================
  
  sub _opt_err {
      my ($problem, $option, $expectation) = @_;
      Carp::croak "prompt(): $problem value for $option (expected $expectation)";
  }
  
  sub _warn {
      my ($category, @message) = @_;
  
      return if !warnings::enabled($category);
  
      my $message = join(q{},@message);
      warn $message =~ /\n$/ ? $message : Carp::shortmess($message);
  }
  
  
  #====[ Utility subroutines ]====================================
  
  # Return the *ARGV filehandle, "magic-opening" it if necessary...
  sub _open_ARGV {
      if (!openhandle \*ARGV) {
          $ARGV = shift @ARGV // '-';
          open *ARGV or Carp::croak(qq{prompt(): Can't open *ARGV: $!});
      }
      return \*ARGV;
  }
  
  my $INTEGER_PAT = qr{ \A \s*+ [+-]?+ \d++ (?: [Ee] \+? \d+ )? \s*+ \Z }xms;
  
  my $NUMBER_PAT  = qr{
      \A \s*+ [+-]?+
      (?:
          \d++ (?: [.,] \d*+ )?
      |   [.,] \d++
      )
      (?: [eE] [+-]?+ \d++ )?
      \s*+ \Z
  }xms;
  
  # Verify interactive constraints...
  sub _verify_input_constraints {
      my ($input_ref, $local_fake_input_ref, $outputter_ref, $opt_ref, $extras)
          = @_;
  
      # Use default if appropriate (but short-circuit checks if -DEFAULT set)...
      my $input = ${$input_ref};
      if (${$input_ref} =~ m{^\R?$}xms && exists $opt_ref->{-def}) {
          return 1 if $opt_ref->{-def_nocheck};
          $input = $opt_ref->{-def}
      }
      chomp $input;
  
      my $failed;
      # Integer constraint is hard-coded...
      if ($opt_ref->{-integer} && $input !~ $INTEGER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be an integer) ";
      }
  
      # Numeric constraint is hard-coded...
      if (!$failed && $opt_ref->{-number} && $input !~ $NUMBER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be a number) ";
      }
  
      # Sort and clean up -must list...
      my $must_ref = $opt_ref->{-must} // {};
      my @must_keys     = sort keys %{$must_ref};
      my %clean_key_for = map { $_ => (/^\d+[.:]?\s*(.*)/s ? $1 : $_) } @must_keys;
      my @must_kv_list  = map { $clean_key_for{$_} => $must_ref->{$_} } @must_keys;
  
      # Combine -yesno and -must constraints...
      my %constraint_for = (
          %{ $extras // {} },
          %{ $opt_ref->{-yesno}{must} // {} },
          @must_kv_list,
      );
      my @constraints = (
          keys %{ $extras // {} },
          keys %{ $opt_ref->{-yesno}{must} // {} },
          @clean_key_for{@must_keys},
      );
  
      # User-specified constraints...
      if (!$failed && keys %constraint_for) {
          CONSTRAINT:
          for my $msg (@constraints) {
              my $constraint = $constraint_for{$msg};
              next CONSTRAINT if eval { no warnings; local $_ = $input; $input ~~ $constraint; };
              $failed = $msg =~ m{\A [[:upper:]] }xms ? "$msg "
                      : $msg =~ m{\A \W }xms          ? $opt_ref->{-prompt}
                                                      . "$msg "
                      :                                 $opt_ref->{-prompt}
                                                      . "(must $msg) "
                      ;
              last CONSTRAINT;
          }
      }
  
      # If any constraint not satisfied...
      if ($failed) {
          # Return failure if not actually prompting at the moment...
          return 0 if !$outputter_ref;
  
          # Redraw post-menu prompt with failure message appended...
          $failed =~ s{.*$MENU_MK}{}xms;
          $outputter_ref->(-style => _wipe_line(), $failed);
  
          # Reset input collector...
          ${$input_ref}  = q{};
  
          # Reset faked input, if any...
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              ${$local_fake_input_ref} = $1;
          }
  
          no warnings 'exiting';
          next INPUT;
      }
  
      # Otherwise succeed...
      return 1;
  }
  
  # Build a sub to read from specified filehandle, with or without timeout...
  sub _generate_buffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      # Set-up for timeouts...
      my $fileno      = fileno($in_fh) // -1;
      my $has_timeout = exists $opt_ref->{-timeout} && $fileno >= 0;
      my $timeout     = $opt_ref->{-timeout};
      my $readbits    = q{};
      if ($has_timeout && $fileno >= 0) {
          vec($readbits,$fileno,1) = 1;
      }
  
      # Set up local faked input, if any...
      my $local_fake_input;
      my $orig_fake_input;
      if (defined $fake_input && length($fake_input) > 0) {
          $fake_input =~ s{ \A (.*) \R? }{}xm;
          $orig_fake_input = $local_fake_input = $1;
      }
  
      return sub {
          my ($extra_constraints) = @_;
  
          INPUT:
          while (1) {
              if (!$has_timeout || select $readbits, undef, undef, $timeout) {
                  my $input;
  
                  # Real input comes from real filehandles...
                  if (!defined $local_fake_input) {
                      $input = readline $in_fh;
                  }
                  # Fake input has to be typed...
                  else {
                      $input = $local_fake_input;
                      sleep 1;
                      for (split q{}, $local_fake_input) {
                          _simulate_typing();
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                      }
                      readline $in_fh;
  
                      # Check for simulated EOF...
                      if ($input =~ m{^ \s* (?: \cD | \cZ ) }xms) {
                          $input = undef;
                      }
                  }
  
                  if (defined $input) {
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref, $opt_ref, $extra_constraints
                      );
                  }
  
                  return defined $input && $opt_ref->{-single}
                              ? substr($input, 0, 1)
                              : $input;
              }
              else {
                  return;
              }
          }
      }
  }
  
  sub _autoflush {
      my ($fh) = @_;
      my $prev_selected = select $fh;
      $| = 1;
      select $prev_selected;
      return;
  }
  
  sub _simulate_typing {
      state $TYPING_SPEED = 0.07; # seconds per character
      select undef, undef, undef, rand $TYPING_SPEED;
  }
  
  sub _term_width {
      my ($term_width) = eval { no warnings 'deprecated'; Term::ReadKey::GetTerminalSize(\*STDERR) };
      return $term_width // $DEFAULT_TERM_WIDTH;
  }
  
  sub _wipe_line {
      return qq{\r} . q{ } x (_term_width()-1) . qq{\r};
  }
  
  # Convert a specification into a list of possible completions...
  sub _current_completions_for {
      my ($input_text, $opt_ref) = @_;
      my $completer = $opt_ref->{-complete};
  
      # Isolate the final whitespace-separated word...
      my ($prefix, $lastword)
          = $input_text =~ m{
              (?| ^ (.*\s+) (.*)
                | ^ ()      (.*)
              )
            }xms;
  
      # Find candidates...
      my @candidates;
      given (ref($completer) || $completer // q{}) {
          # If completer is sub, recursively call it with input words...
          when ('CODE') {
              ($prefix, @candidates)
                  = _current_completions_for(
                      $input_text,
                      { %{$opt_ref},
                        -complete => $completer->(split /\s+/, $input_text, -1)
                      }
                    );
          }
  
          # If completer is array, grep the appropriate elements...
          when ('ARRAY') {
              @candidates = grep { /\A\Q$lastword\E/ } @{$completer};
          }
  
          # If completer is hash, grep the appropriate keys...
          when ('HASH') {
              @candidates = grep { /\A\Q$lastword\E/ } keys %{$completer};
          }
  
          # If completer is 'file...', glob up the appropriate filenames...
          when (/^file\w*$/) {
              @candidates = glob($lastword.'*');
          }
  
          # If completer is 'dir...', glob up the appropriate directories...
          when (/^dir\w*$/) {
              @candidates = grep {-d} glob($lastword.'*');
          }
      }
  
      chomp @candidates;
      return ($prefix, @candidates);
  }
  
  
  sub _current_history_for {
      my ($prefix, $opt_ref) = @_;
  
      my $prefix_len = length($prefix);
      return q{}, map { /\A (.*?) \R \Z/x ? $1 : $_ }
                 grep { substr($_,0,$prefix_len) eq $prefix }
                      @{ $history_cache{$opt_ref->{-history}} };
  }
  
  sub _longest_common_prefix_for {
      my $prefix = shift @_;
      for my $comparison (@_) {
          ($comparison ^ $prefix) =~ m{ \A (\0*) }xms;
          my $common_length = length($1);
          return q{} if !$common_length;
          $prefix = substr($prefix, 0, $common_length);
      }
      return $prefix;
  }
  
  sub _display_completions {
      my ($input, @candidates) = @_;
  
      return q{} if @candidates <= 1;
  
      # How big is each field in the table?
      my $field_width
          = _term_width() / $COMPLETE_DISPLAY_FIELDS - $COMPLETE_DISPLAY_GAP;
  
      # Crop the possibilities intelligently to that width...
      for my $candidate (@candidates) {
          substr($candidate, 0, length($input)) =~ s{ \A .* [/\\] }{}xms;
          $candidate
              = sprintf "%-*s", $field_width, substr($candidate,0,$field_width);
      }
  
      # Collect them into rows...
      my $display = "\n";
      my $gap     = q{ } x $COMPLETE_DISPLAY_GAP;
      while (@candidates) {
          $display .= $gap
                    . join($gap, splice(@candidates, 0, $COMPLETE_DISPLAY_FIELDS))
                    . "\n";
      }
  
      return $display;
  }
  
  sub _generate_unbuffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      my $has_readkey = eval { no warnings 'deprecated'; require Term::ReadKey };
  
      # If no per-character reads, fall back on buffered input...
      if (!-t $in_fh || !$has_readkey) {
          return _generate_buffered_reader_from($in_fh, $outputter_ref, $opt_ref);
      }
  
      # Adapt to local control characters...
      my %ctrl = eval { Term::ReadKey::GetControlChars($in_fh) };
      delete $ctrl{$_} for grep { $ctrl{$_} eq "\cA" } keys %ctrl;
  
      $ctrl{EOF}       //= "\4";
      $ctrl{INTERRUPT} //= "\3";
      $ctrl{ERASE}     //= $^O eq 'MSWin32' ? "\10" : "0177";
  
      my $ctrl           = join '|', values %ctrl;
  
      my $VERBATIM_KEY = $ctrl{QUOTENEXT} // $DEFAULT_VERBATIM_KEY;
  
      # Translate timeout for ReadKey (with 32-bit MAXINT workaround for Windows)...
      my $timeout = !defined $opt_ref->{-timeout} ? 0x7FFFFFFF    # 68 years
                  : $opt_ref->{-timeout} == 0     ? -1
                  :                                 $opt_ref->{-timeout}
                  ;
  
      return sub {
          my ($extra_constraints) = @_;
  
          # Short-circuit on unreadable filehandle...
          return if !openhandle($in_fh);
  
          # Set up direct reading, and prepare to clean up on abnormal exit...
          Term::ReadKey::ReadMode('raw', $in_fh);
          my $prev_SIGINT = $SIG{INT};
          local $SIG{INT} = sub { given ($prev_SIGINT) {
                                      when ('IGNORE')  { }
                                      Term::ReadKey::ReadMode('restore', $in_fh);
                                      when ('DEFAULT') { exit(1) }
                                      when (undef)     { exit(1) }
                                      default {
                                          package main;
                                          no strict 'refs';
                                          $prev_SIGINT->()
                                      }
                                  }
                            };
  
          # Set up local faked input, if any...
          my $local_fake_input;
          my $orig_fake_input;
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              $orig_fake_input = $local_fake_input = $1;
          }
  
          my $input = q{};
          my $insert_offset = 0;
          INPUT:
          while (1) {
              state $prev_was_verbatim = 0;
              state $completion_level  = 0;
              state $completion_type   = q{};
  
              # Get next character entered...
              my $next = Term::ReadKey::ReadKey($timeout, $in_fh);
  
              # Finished with completion mode?
              if (($next//q{}) !~ m{ $COMPLETE_INIT | $COMPLETE_CYCLE }xms) {
                  $completion_level = 0;
                  $completion_type = q{};
              }
  
              # Are we faking input?
              my $faking = defined $local_fake_input;
  
              # If not EOF...
              if (defined $next) {
                  # Remember where we were parked...
                  my $prev_insert_offset = $insert_offset;
  
                  # Handle interrupts...
                  if ($next eq $ctrl{INTERRUPT}) {
                      $SIG{INT}();
                      next INPUT;
                  }
  
                  # Handle verbatim quoter...
                  elsif (!$prev_was_verbatim && $next eq $VERBATIM_KEY) {
                      $prev_was_verbatim = 1;
                      next INPUT;
                  }
  
                  # Handle completions...
                  elsif (!$prev_was_verbatim
                         && ( $next =~ $COMPLETE_INIT
                           || $completion_level > 0 && $next =~ $COMPLETE_CYCLE
                         )
                  ) {
                      state @completion_list;  # ...all candidates for completion
                      state @completion_ring;  # ..."next" candidate cycle
                      state $completion_ring_first;  # ...special case first time
                      state $completion_prefix;      # ...skipped before completing
  
                      # Track completion type and level (switch if necessary)...
                      if ($next =~ $COMPLETE_INIT && $next ne $completion_type) {
                          $completion_type = $next;
                          $completion_level = 1;
                      }
                      else {
                          $completion_level++;
                      }
  
                      # If starting completion, cache completions...
                      if ($completion_level == 1) {
                          ($completion_prefix, @completion_list)
                              = $next eq $COMPLETE_KEY
                                  ? _current_completions_for($input, $opt_ref)
                                  : _current_history_for($input, $opt_ref);
                          @completion_ring = (@completion_list, q{});
                          $completion_ring_first = 1;
                      }
  
                      # Can only complete if there are completions to be had...
                      if (@completion_list) {
                          # Select the appropriate mode...
                          my $mode = $COMPLETE_MODE{$completion_type}[$completion_level-1]
                                  // $COMPLETE_MODE{$completion_type}[-1];
  
                          # 'longest mode' finds longest consistent prefix...
                          if ($mode =~ /longest/) {
                              $input
                                  = $completion_prefix
                                  . _longest_common_prefix_for(@completion_list);
                          }
                          # 'full mode' suggests next full match...
                          elsif ($mode =~ /full/) {
                              if (!$completion_ring_first) {
                                  if ($next eq $COMPLETE_PREV) {
                                      unshift @completion_ring,
                                              pop @completion_ring;
                                  }
                                  else {
                                      push @completion_ring,
                                           shift @completion_ring;
                                  }
                              }
                              $input = $completion_prefix . $completion_ring[0];
                              $completion_ring_first = 0;
                          }
                          # 'list mode' lists all possibilities...
                          my $list_display = $mode =~ /list/
                              ? _display_completions($input, @completion_list)
                              : q{};
  
                          # Update prompt with selected completion...
                          $outputter_ref->( -style =>
                              $list_display,
                              _wipe_line(),
                              $opt_ref->{-prompt}, $input
                          );
  
                          # If last completion was unique choice, completed...
                          if (@completion_list <= 1) {
                              $completion_level = 0;
                          }
                      }
                      next INPUT;
                  }
  
                  # Handle erasures (including pushbacks if faking)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{ERASE}) {
                      if (!length $input) {
                          # Do nothing...
                      }
                      elsif ($insert_offset) {
                          # Can't erase past start of input...
                          next INPUT if $insert_offset >= length($input);
  
                          # Erase character just before cursor...
                          substr($input, -$insert_offset-1, 1, q{});
  
                          # Redraw...
                          my $input_pre  = substr($input.' ',0,length($input)-$insert_offset+1);
                          my $input_post = substr($input.' ',length($input)-$insert_offset);
                          my $display_pre  = join q{}, map { $opt_ref->{-echo}($_) } split //, $input_pre;
                          my $display_post = join q{}, map { $opt_ref->{-echo}($_) } split //, $input_post;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } split //, $input)
                              . q{ } x length($opt_ref->{-echo}(q{ }))
                              . "\b" x length($display_post)
                          );
                      }
                      else {
                          my $erased = substr($input, -1, 1, q{});
                          if ($faking) {
                              substr($local_fake_input,0,0,$erased);
                          }
                          $outputter_ref->( -nostyle =>
                              map { $_ x (length($opt_ref->{-echo}($_)//'X')) }
                                  "\b", ' ', "\b"
                          );
                      }
                      next INPUT;
                  }
  
                  # Handle EOF (including cancelling any remaining fake input)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{EOF}) {
                      Term::ReadKey::ReadMode('restore', $in_fh);
                      close $in_fh;
                      undef $fake_input;
                      return length($input) ? $input : undef;
                  }
  
                  # Handle escape from faking...
                  elsif (!$prev_was_verbatim && $faking && $next eq $FAKE_ESC) {
                      my $lookahead = Term::ReadKey::ReadKey(0, $in_fh);
  
                      # Two <ESC> implies the current faked line is deferred...
                      if ($lookahead eq $FAKE_ESC) {
                          $fake_input =~ s{ \A }{$orig_fake_input\n}xm;
                      }
                      # Only one <ESC> implies the current faked line is replaced...
                      else {
                          $in_fh->ungetc(ord($lookahead));
                      }
                      undef $local_fake_input;
                      $faking = 0;
                      next INPUT;
                  }
  
                  # Handle returns...
                  elsif (!$prev_was_verbatim && $next =~ /\A\R\z/) {
                      # Complete faked line, if faked input incomplete...
                      if ($faking && length($local_fake_input)) {
                          for (split q{}, $local_fake_input) {
                              _simulate_typing();
                              $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                          }
                          $input .= $local_fake_input;
                      }
  
                      # Add newline to the accumulated input string...
                      $input .= $next;
  
                      # Check that input satisfied any constraints...
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref,
                          $opt_ref, $extra_constraints,
                      );
  
                      # Echo a default value if appropriate...
                      if ($input =~ m{\A\R?\Z}xms && defined $opt_ref->{-def}) {
                          my $def_val = $opt_ref->{-def};
  
                          # Try to find the key, for a menu...
                          if (exists $opt_ref->{-menu_curr_level}) {
                              for my $key ( keys %{$opt_ref->{-menu_curr_level}}) {
                                  if ($def_val ~~ $opt_ref->{-menu_curr_level}{$key}) {
                                      $def_val = $key;
                                      last;
                                  }
                              }
                          }
  
                          # Echo it as if it had been typed...
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($def_val));
                      }
  
                      # Echo the return (or otherwise, as specified)...
                      $outputter_ref->(-echostyle => $opt_ref->{-return}($next));
  
                      # Clean up, and return the input...
                      Term::ReadKey::ReadMode('restore', $in_fh);
  
                      # Handle fake EOF...
                      if ($faking && $input =~ m{^ (?: \cD | \cZ) }xms) {
                          return undef;
                      }
  
                      return $input;
                  }
  
                  # Handle anything else...
                  elsif ($prev_was_verbatim || $next !~ /$ctrl/) {
                      # If so, get the next fake character...
                      if ($faking) {
                          $next = length($local_fake_input)
                                      ? substr($local_fake_input,0,1,q{})
                                      : q{};
                      }
  
                      # Handle editing...
                      if ($next eq $EDIT{BACK}) {
                          $insert_offset += ($insert_offset < length $input) ? 1 : 0;
                      }
                      elsif ($next eq $EDIT{FORWARD}) {
                          $insert_offset += ($insert_offset > 0) ? -1 : 0;
                      }
                      elsif ($next eq $EDIT{START}) {
                          $insert_offset = length($input);
                      }
                      elsif ($next eq $EDIT{END}) {
                          $insert_offset = 0;
                      }
  
                      # Handle non-editing...
                      else {
                          # Check for input restrictions...
                          if (exists $opt_ref->{-guarantee}) {
                              next INPUT if ($input.$next) !~ $opt_ref->{-guarantee};
                          }
  
                          # Add the new input char to the accumulated input string...
                          if ($insert_offset) {
                              substr($input, -$insert_offset, 0) = $next;
                              $prev_insert_offset++;
                          }
                          else {
                              $input .= $next;
                          }
                      }
  
                      # Display the character (or whatever was specified)...
  
                      if ($insert_offset || $prev_insert_offset) {
                          my $input_pre  = substr($input,0,length($input)-$prev_insert_offset);
                          my $input_post = substr($input,length($input)-$insert_offset);
                          my $display_pre  = join q{}, map { $opt_ref->{-echo}($_) } split //, $input_pre;
                          my $display_post = join q{}, map { $opt_ref->{-echo}($_) } split //, $input_post;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } split //, $input)
                              . "\b" x length($display_post)
                          );
                      }
                      elsif ($next !~ $EDIT_KEY) {
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($next));
                      }
  
                      # Not verbatim after this...
                      $prev_was_verbatim = 0;
                  }
                  else {
                      # Not verbatim after mysterious ctrl input...
                      $prev_was_verbatim = 0;
  
                      say grep { $ctrl{$_} eq $next } keys %ctrl;
  
                      next INPUT;
                  }
              }
              if ($opt_ref->{-single} || !defined $next || $input =~ m{\Q$/\E$}) {
                  # Did we get an acceptable value?
                  if (defined $next) {
                      _verify_input_constraints(
                         \$input, \$local_fake_input, $outputter_ref,
                         $opt_ref, $extra_constraints,
                      );
                  }
  
                  # Reset terminal...
                  Term::ReadKey::ReadMode('restore', $in_fh);
  
                  # Return failure if failed before input...
                  return undef if !defined $next && length($input) == 0;
  
                  # Otherwise supply a final newline if necessary...
                  if ( $opt_ref->{-single}
                  &&   exists $opt_ref->{-return}
                  &&   $input !~ /\A\R\z/ ) {
                      $outputter_ref->(-echostyle => $opt_ref->{-return}(q{}));
                  }
  
                  return $input;
              }
          }
      }
  }
  
  # Build a menu...
  sub _build_menu {
      my ($source_ref, $initial_prompt, $is_numeric) = @_;
      my $prompt = ($initial_prompt//q{}) . qq{\n};
      my $final = q{};
      my %value_for;
      my %key_for;
      my @selectors;
  
      given (ref $source_ref) {
          when ('HASH') {
              my @sorted_keys = sort(keys(%{$source_ref}));
              @selectors = $is_numeric ? (1..@sorted_keys) : ('a'..'z','A'..'Z');
              @key_for{@selectors}   = @sorted_keys;
              @value_for{@selectors} = @{$source_ref}{@sorted_keys};
              $source_ref = \@sorted_keys;
              $_ = 'ARRAY';
              continue;
          }
          when ('SCALAR') {
              $source_ref = [ split "\n", ${$source_ref} ];
              $_ = 'ARRAY';
              continue;
          }
          when ('ARRAY') {
              my @source = @{$source_ref};
              @selectors = $is_numeric ? (1..@source) : ('a'..'z','A'..'Z');
              if (!keys %value_for) {
                  @value_for{@selectors} = @source;
              }
              ITEM:
              for my $tag (@selectors) {
                  my $item = shift(@source) // last ITEM;
                  chomp $item;
                  $prompt .= sprintf("%4s. $item\n", $tag);
                  $final = $tag;
              }
              if (@source) {
                  _warn( misc =>
                      "prompt(): Too many menu items. Ignoring the final " . @source
                  );
              }
          }
      }
  
      my $constraint = $is_numeric       ? '(?:' . join('|',@selectors) .')'
                     : $final =~ /[A-Z]/ ? "[a-zA-$final]"
                     :                     "[a-$final]";
      my $constraint_desc = $is_numeric  ? "[1-$selectors[-1]]" : $constraint;
      $constraint = '\A\s*' . $constraint . '\s*\Z';
  
      return {
          data       => $source_ref,
          key_for    => \%key_for,
          value_for  => \%value_for,
          prompt     => "$prompt\n",
          is_numeric => $is_numeric,
          constraint => { "Enter $constraint_desc: " => qr/$constraint|$MENU_ESC/ },
      };
  }
  
  # Vocabulary that _stylize understands...
  my %synonyms = (
      bold      => [qw<boldly strong heavy emphasis emphatic highlight highlighted fort forte>],
      dark      => [qw<darkly dim deep>],
      faint     => [qw<faintly light soft>],
      underline => [qw<underlined underscore underscored italic italics>],
      blink     => [qw<blinking flicker flickering flash flashing>],
      reverse   => [qw<reversed inverse inverted>],
      concealed => [qw<hidden blank invisible>],
      reset     => [qw<normal default standard usual ordinary regular>],
      bright_   => [qw< bright\s+ vivid\s+ >],
      red       => [qw< scarlet vermilion crimson ruby cherry cerise cardinal carmine
                        burgundy claret chestnut copper garnet geranium russet
                        salmon titian coral cochineal rose cinnamon ginger gules >],
      yellow    => [qw< gold golden lemon cadmium daffodil mustard primrose tawny
                        amber aureate canary champagne citrine citron cream goldenrod honey straw >],
      green     => [qw< olive jade pea emerald lime chartreuse forest sage vert >],
      cyan      => [qw< aqua aquamarine teal turquoise ultramarine >],
      blue      => [qw< azure cerulean cobalt indigo navy sapphire >],
      magenta   => [qw< amaranthine amethyst lavender lilac mauve mulberry orchid periwinkle
                        plum pomegranate violet purple aubergine cyclamen fuchsia modena puce
                        purpure >],
      black     => [qw< charcoal ebon ebony jet obsidian onyx raven sable slate >],
      white     => [qw< alabaster ash chalk ivory milk pearl silver argent >],
  );
  
  # Back-mapping to standard terms...
  my %normalize
      = map { join('|', map { "$_\\b" } reverse sort @{$synonyms{$_}}) => $_ }
            keys %synonyms;
  
  my $BACKGROUND = qr{
       (\S+) \s+ (?: behind | beneath | below | under(?:neath)? )\b
     | \b (?:upon|over|on) \s+ (?:an?)? \s+ (.*?) \s+ (?:background|bg|field) \b
     | \b (?:upon\s+ | over\s+ | (?:(on|upon|over)\s+a\s+)?  (?:background|bg|field) \s+ (?:of\s+|in\s+)? | on\s+) (\S+)
  }ixms;
  
  # Convert a description to ANSI colour codes...
  sub _stylize {
      my $spec = shift // q{};
  
      # Handle arrays and hashes as args...
      if (ref($spec) eq 'ARRAY') {
          $spec = join q{ }, @{$spec};
      }
      elsif (ref($spec) eq 'HASH') {
          $spec = join q{ }, keys %{$spec};
      }
  
      # Ignore punctuation...
      $spec =~ s/[^\w\s]//g;
  
      # Handle backgrounds...
      $spec =~ s/$BACKGROUND/on_$+/g;
  
      # Apply standard translations...
      for my $pattern (keys %normalize) {
          $spec =~ s{\b(on_|\b) $pattern}{($1//q{}).$normalize{$pattern}}geixms;
      }
  
      # Ignore anything unknown...
      $spec =~ s{((?:on_)?(\S+))}{ exists $synonyms{$2} ? $1 : q{} }gxmse;
  
      # Build ANSI terminal codes around text...
      my $raw_text = join q{}, @_;
      my ($prews, $text, $postws) = $raw_text =~ m{\A (\s*) (.*?) (\s*) \Z}xms;
      my @style = split /\s+/, $spec;
      return $prews
           . ( @style ? Term::ANSIColor::colored(\@style, $text) : $text )
           . $postws;
  }
  
  # Build a subroutine that prints printable chars to the specified filehandle...
  sub _std_printer_to {
      my ($out_filehandle, $opt_ref) = @_;
      no strict 'refs';
      _autoflush($out_filehandle);
      if (eval { require Term::ANSIColor}) {
          return sub {
              my $style = shift;
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} _stylize($opt_ref->{$style}(@loc), @loc);
          };
      }
      else {
          return sub {
              shift; # ...ignore style
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} @loc;
          };
      }
  }
  
  # Build a subroutine that prints to nowhere...
  sub _null_printer {
      return sub {};
  }
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  IO::Prompter - Prompt for input, read it, clean it, return it.
  
  
  =head1 VERSION
  
  This document describes IO::Prompter version 0.004013
  
  
  =head1 SYNOPSIS
  
      use IO::Prompter;
  
      while (prompt -num, 'Enter a number') {
          say "You entered: $_";
      }
  
      my $passwd
          = prompt 'Enter your password', -echo=>'*';
  
      my $selection
          = prompt 'Choose wisely...', -menu => {
                  wealth => [ 'moderate', 'vast', 'incalculable' ],
                  health => [ 'hale', 'hearty', 'rude' ],
                  wisdom => [ 'cosmic', 'folk' ],
            }, '>';
  
  
  =head1 DESCRIPTION
  
  IO::Prompter exports a single subroutine, C<prompt>, that prints a
  prompt (but only if the program's selected input and output streams are
  connected to a terminal), then reads some input, then chomps it, and
  finally returns an object representing that text.
  
  The C<prompt()> subroutine expects zero-or-more arguments.
  
  Any argument that starts with a hyphen (C<->) is treated as a named
  option (many of which require an associated value, that may be passed as
  the next argument). See L<"Summary of options"> and L<"Options
  reference"> for details of the available options.
  
  Any other argument that is a string is treated as (part of) the prompt
  to be displayed. All such arguments are concatenated together before the
  prompt is issued. If no prompt string is provided, the string
  C<< '> ' >> is used instead.
  
  Normally, when C<prompt()> is called in either list or scalar context,
  it returns an opaque object that autoconverts to a string. In scalar
  boolean contexts this return object evaluates true if the input
  operation succeeded. In list contexts, if the input operation fails
  C<prompt()> returns an empty list instead of a return object. This
  allows failures in list context to behave correctly (i.e. be false).
  
  If you particularly need a list-context call to C<prompt()> to always
  return a value (i.e. even on failure), prefix the call with C<scalar>:
  
      # Only produces as many elements
      # as there were successful inputs...
      my @data = (
          prompt('Name:'),
          prompt(' Age:'),
          prompt(' Sex:'),
      );
  
      # Always produces exactly three elements
      # (some of which may be failure objects)...
      my @data = (
          scalar prompt('Name:'),
          scalar prompt(' Age:'),
          scalar prompt(' Sex:'),
      );
  
  In void contexts, C<prompt()> still requests input, but also issues a
  warning about the general uselessness of performing an I/O operation
  whose results are then immediately thrown away.
  See L<"Useful useless uses of C<prompt()>"> for an exception to this.
  
  The C<prompt()> function also sets C<$_> if it is called in a boolean
  context but its return value is not assigned to a variable. Hence, it is
  designed to be a drop-in replacement for C<readline> or C<< <> >>.
  
  =head1 INTERFACE
  
  All the options for C<prompt()> start with a hyphen (C<->).
  Most have both a short and long form. The short form is always
  the first letter of the long form.
  
  Most options have some associated value. For short-form options, this
  value is specified as a string appended to the option itself. The
  associated value for long-form options is always specified as a
  separated argument, immediately following the option (typically
  separated from it by a C<< => >>).
  
  Note that this implies that short-form options may not be able to
  specify every possible associated value (for example, the short-form
  C<-d> option cannot specify defaults with values C<'efault'> or
  C<'$%^!'>).  In such cases, just use the long form of the option
  (for example: S<< C<< -def => 'efault' >> >> or C<< -default=>'$%^!' >>).
  
  
  =head2 Summary of options
  
  Note: For options preceded by an asterisk, the short form is actually
  a Perl file operator, and hence cannot be used by itself.
  Either use the long form of these options,
  or L<bundle them with another option|"Bundling short-form options">,
  or add a L<"no-op"|"Escaping otherwise magic options"> to them.
  
  
      Short   Long
      form    form               Effect
      =====   =============      ======================================
  
      -a      -argv              Prompt for @ARGV data if !@ARGV
  
              -comp[lete]=>SPEC  Complete input on <TAB>, as specified
  
      -dSTR   -def[ault]=>STR    What to return if only <ENTER> typed
              -DEF[AULT]=>STR    (as above, but skip any -must checking)
  
    * -e[STR] -echo=>STR         Echo string for each character typed
  
              -echostyle=>SPEC   What colour/style to echo input in
  
    * -f      -filenames         Input should be name of a readable file
  
              -fail=>VALUE       Return failure if input smartmatches value
  
              -guar[antee]=>SPEC Only allow the specified words to be entered
  
      -h[STR] -hist[ory][=>SPEC] Specify the history set this call belongs to
  
              -in=>HANDLE        Read from specified handle
  
      -i      -integer[=>SPEC]   Accept only valid integers (that smartmatch SPEC)
  
      -k      -keyletters        Accept only keyletters (as specified in prompt)
  
    * -l      -line              Don't autochomp
  
              -menu=>SPEC        Specify a menu of responses to be displayed
  
              -must=>HASHREF     Specify requirements/constraints on input
  
      -n      -num[ber][=>SPEC]  Accept only valid numbers (that smartmatch SPEC)
  
              -out=>HANDLE       Prompt to specified handle
  
              -prompt=>STR       Specify prompt explicitly
  
    * -rSTR   -ret[urn]=>STR     After input, echo this string instead of <CR>
  
    * -s -1   -sing[le]          Return immediately after first key pressed
  
              -stdio             Use STDIN and STDOUT for prompting
  
              -style=>SPEC       What colour/style to display the prompt text in
  
      -tNUM   -time[out]=>NUM    Specify a timeout on the input operation
  
      -v      -verb[atim]        Return the input string (no context sensitivity)
  
              -void              Don't complain in void context
  
    * -w      -wipe              Clear screen
              -wipefirst         Clear screen on first prompt() call only
  
    * -y      -yes    [=> NUM]   Return true if [yY] entered, false otherwise
      -yn     -yesno  [=> NUM]   Return true if [yY] entered, false if [nN]
      -Y      -Yes    [=> NUM]   Return true if Y entered, false otherwise
      -YN     -YesNo  [=> NUM]   Return true if Y entered, false if N
  
    * -_                         No-op (handy for bundling ambiguous short forms)
  
  
  =head2 Automatic options
  
  Any of the options listed above (and described in detail below) can be
  automatically applied to every call to C<prompt()> in the current
  lexical scope, by passing them (via an array reference) as the arguments
  to a C<use IO::Prompter> statement.
  
  For example:
  
      use IO::Prompter;
  
      # This call has no automatically added options...
      my $assent = prompt "Do you wish to take the test?", -yn;
  
      {
          use IO::Prompter [-yesno, -single, -style=>'bold'];
  
          # These three calls all have: -yesno, -single, -style=>'bold' options
          my $ready = prompt 'Are you ready to begin?';
          my $prev  = prompt 'Have you taken this test before?';
          my $hints = prompt 'Do you want hints as we go?';
      }
  
      # This call has no automatically added options...
      scalar prompt 'Type any key to start...', -single;
  
  The current scope's lexical options are always I<prepended> to the
  argument list of any call to C<prompt()> in that scope.
  
  To turn off any existing automatic options for the rest of the current
  scope, use:
  
      use IO::Prompter [];
  
  
  =head2 Prebound options
  
  You can also ask IO::Prompter to export modified versions of C<prompt()>
  with zero or more options prebound. For example, you can request an
  C<ask()> subroutine that acts exactly like C<prompt()> but has the C<-
  yn> option pre-specified, or a C<pause()> subroutine that is C<prompt()>
  with a "canned" prompt and the C<-echo>, C<-single>, and C<-void> options.
  
  To specify such subroutines, pass a single hash reference when
  loading the module:
  
      use IO::Prompter {
          ask     => [-yn],
          pause   => [-prompt=>'(Press any key to continue)', -echo, -single, -void],
      }
  
  Each key will be used as the name of a separate subroutine to be
  exported, and each value must be an array reference, containing the
  arguments that are to be automatically supplied.
  
  The resulting subroutines are simply lexically scoped wrappers around
  C<prompt()>, with the specified arguments prepended to the normal
  argument list, equivalent to something like:
  
      my sub ask {
          return prompt(-yn, @_);
      }
  
      my sub pause {
          return prompt(-prompt=>'(Press any key to continue)', -echo, -single, -void, @_);
      }
  
  Note that these subroutines are lexically scoped, so if you want to use
  them throughtout a source file, they should be declared in the outermost
  scope of your program.
  
  
  =head2 Options reference
  
  =head3 Specifying what to prompt
  
  =over 4
  
  C<< -prompt => I<STRING> >>
  
  C<< -pI<STRING> >>
  
  =back
  
  By default, any argument passed to C<prompt()> that does not begin with
  a hyphen is taken to be part of the prompt string to be displayed before
  the input operation. Moreover, if no such string is specified in the
  argument list, the function supplies a default prompt (C<< '> ' >>)
  automatically.
  
  The C<-prompt> option allows you to specify a prompt explicitly, thereby
  enabling you to use a prompt that starts with a hyphen:
  
      my $input
          = prompt -prompt=>'-echo';
  
  or to disable prompting entirely:
  
      my $input
          = prompt -prompt => "";
  
  Note that the use of the C<-prompt> option doesn't override other string
  arguments, it merely adds its argument to the collective prompt.
  
  =head4 Prompt prettification
  
  If the specified prompt ends in a non-whitespace character, C<prompt()>
  adds a single space after it, to better format the output. On the other
  hand, if the prompt ends in a newline, C<prompt()> removes that
  character, to keep the input position on the same line as the prompt.
  
  You can use that second feature to override the first, if necessary. For
  example, if you wanted your prompt to look like:
  
      Load /usr/share/dict/_
  
  (where the _ represents the input cursor), then a call like:
  
      $filename = prompt 'Load /usr/share/dict/';
  
  would not work because it would automatically add a space, producing:
  
      Load /usr/share/dict/ _
  
  But since a terminal newline is removed, you could achieve the desired effect
  with:
  
      $filename = prompt "Load /usr/share/dict/\n";
  
  If for some reason you I<do> want a newline at the end of the prompt (i.e.
  with the input starting on the next line) just put two newlines at the end
  of the prompt. Only the very last one will be removed.
  
  
  =head3 Specifying how the prompt looks
  
  =over 4
  
  C<< -style  => I<SPECIFICATION> >>
  
  =back
  
  If the C<Term::ANSIColor> module is available, this option can be used
  to specify the colour and styling (e.g. bold, inverse, underlined, etc.)
  in which the prompt is displayed.
  
  You can can specify that styling as a single string:
  
      prompt 'next:' -style=>'bold red on yellow';
  
  or an array of styles:
  
      prompt 'next:' -style=>['bold', 'red', 'on_yellow'];
  
  The range of styles and colour names that the option understands is
  quite extensive. All of the following work as expected:
  
      prompt 'next:' -style=>'bold red on yellow';
  
      prompt 'next:' -style=>'strong crimson on gold';
  
      prompt 'next:' -style=>'highlighted vermilion, background of cadmium';
  
      prompt 'next:' -style=>'vivid russet over amber';
  
      prompt 'next:' -style=>'gules fort on a field or';
  
  However, because C<Term::ANSIColor> maps everything back to the
  standard eight ANSI text colours and seven ANSI text styles, all of the
  above will also be rendered identically. See that module's
  documentation for details.
  
  If C<Term::ANSIColor> is not available, this option is silently ignored.
  
  Please bear in mind that up to 10% of people using your interface will
  have some form of colour vision impairment, so its always a good idea
  to differentiate information by style I<and> colour, rather than by colour
  alone. For example:
  
      if ($dangerous_action) {
          prompt 'Really proceed?', -style=>'bold red underlined';
      }
      else {
          prompt 'Proceed?', -style=>'green';
      }
  
  Also bear in mind that (even though C<-style> does support the C<'blink'>
  style) up to 99% of people using your interface will have Flashing Text
  Tolerance Deficiency. Just say "no".
  
  
  =head3 Specifying where to prompt
  
  =over 4
  
  C<< -out => FILEHANDLE >>
  
  C<< -in => FILEHANDLE >>
  
  C<< -stdio >>
  
  =back
  
  The C<-out> option (which has no short form) is used to specify
  where the prompt should be written to. If this option is not specified,
  prompts are written to the currently C<select>-ed filehandle. The most
  common usage is:
  
      prompt(out => *STDERR)
  
  The C<-in> option (which also has no short form) specifies where the input
  should be read from. If this option is not specified, input is read from
  the C<*ARGV> filehandle. The most common usage is:
  
      prompt(in => *STDIN)
  
  in those cases where C<*ARGV> has been opened to a file, but you still
  wish to interact with the terminal (assuming C<*STDIN> is opened to that
  terminal).
  
  The C<-stdio> option (which again has no short form) is simply a shorthand
  for: C<< -in => *STDIN, -out => *STDOUT >>. This is particularly useful when
  there are arguments on the commandline, but you don't want prompt to treat
  those arguments as filenames for magic C<*ARGV> reads.
  
  
  =head3 Specifying how long to wait for input
  
  =over 4
  
  C<< -timeout => I<N> >>
  
  C<< -tI<N> >>
  
  =back
  
  Normally, the C<prompt()> function simply waits for input. However,
  you can use this option to specify a timeout on the read operation.
  If no input is received within the specified I<N> seconds, the call
  to C<prompt()> either returns the value specified by
  L<the C<-default> option|"Specifying what to return by default">
  (if any), or else an object indicating the read failed.
  
  Note that, if the short form is used, I<N> must be an integer. If the long
  form is used, I<N> may be an integer or floating point value.
  
  You can determine whether an input operation timed out, even if a
  default value was returned, by calling the C<timedout()> method on the
  object returned by C<prompt()>:
  
      if (prompt('Continue?', -y1, -timeout=>60) && !$_->timedout) {
          ...
      }
  
  If a time-out occurred, the return value of C<timedout()> is a string
  describing the timeout, such as:
  
      "timed out after 60 seconds"
  
  
  =head3 Providing a menu of responses
  
  =over
  
  =item C<< -menu => I<SPECIFICATION> >>
  
  =back
  
  You can limit the allowable responses to a prompt, by providing a menu.
  
  A menu is specified using the C<-menu> option, and the menu choices
  are specified as an argument to the option, either as a reference to
  an array, hash, or string, or else as a literal string.
  
  If the menu is specified in a hash, C<prompt()> displays the keys of the
  hash, sorted alphabetically, and with each alternative marked with a
  single alphabetic character (its "selector key").
  
  For example, given:
  
      prompt 'Choose...',
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will display:
  
      Choose...
          a. die
          b. live free
          c. transcend
      > _
  
  It will then only permit the user to enter a valid selector key (in the
  previous example: 'a', 'b', or 'c'). Once one of the alternatives is
  selected, C<prompt()> will return the corresponding value from the hash
  (0, 1, or -1, respectively, in this case).
  
  Note that the use of alphabetics as selector keys inherently limits the
  number of usable menu items to 52. See L<"Numeric menus"> for a way to
  overcome this limitation.
  
  A menu is treated like a special kind of prompt, so that any
  other prompt strings in the C<prompt()> call will appear either before or
  after the menu of choices, depending on whether they appear before or
  after the menu specification in the call to C<prompt()>.
  
  If an array is used to specify the choices:
  
      prompt 'Choose...',
             -menu=>[ 'live free', 'die', 'transcend' ],
             '>';
  
  then each array element is displayed (in the original array order) with
  a selector key:
  
      Choose...
          a. live free
          b. die
          c. transcend
      > _
  
  and C<prompt()> returns the element corresponding to the selection (i.e.
  it returns 'live free' if 'a' is entered, 'die' if 'b' is entered, or
  'transcend' if 'c' is entered).
  
  Hence, the difference between using an array and a hash is that the
  array allows you to control the order of items in the menu, whereas a
  hash allows you to show one thing (i.e. keys) but have something related
  (i.e. values) returned instead.
  
  If the argument after C<-menu> is a string or a reference to a string, the
  option splits the string on newlines, and treats the resulting list as if it
  were an array of choices. This is useful, for example, to request the user
  select a filename:
  
      my $files = `ls`;
      prompt 'Select a file...', -menu=>$files, '>';
  
  
  =head4 Numbered menus
  
  As the previous examples indicate, each menu item is given a unique
  alphabetic selector key. However, if the C<-number> or C<-integer>
  option is specified as well:
  
      prompt 'Choose...',
             -number,
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will number each menu item instead, using consecutive integers
  as the selector keys:
  
      Choose...
          1. die
          2. live free
          3. transcend
      > _
  
  This allows for an unlimited number of alternatives in a single menu,
  but prevents the use of C<-single> for one-key selection from menus if
  the menu has more than nine items.
  
  
  =head4 Hierarchical menus
  
  If you use a hash to specify a menu, the values of the hash do not have
  to be strings. Instead, they can be references to nested hashes or
  arrays.
  
  This allows you to create hierarchical menus, where a selection at the
  top level may lead to a secondary menu, etc. until an actual choice is
  possible. For example, the following call to prompt:
  
      my $choices = {
          animates => {
              animals => {
                  felines => [qw<cat lion lynx>],
                  canines => [qw<dog fox wolf>],
                  bovines => [qw<cow ox buffalo>],
              },
              fish => [qw<shark carp trout bream>],
          },
          inanimates => {
              rocks     => [qw<igneous metamorphic sedimentary>],
              languages => [qw<Perl Python Ruby Tcl>],
          },
      };
  
      my $result = prompt -1, 'Select a species...', -menu=>$choices, '> ';
  
  might result in an interaction like this:
  
      Select a species...
      a.  animates
      b.  inanimates
      > a
  
      Select from animates:
      a.  animals
      b.  fish
      > b
  
      Select from fish:
      a.  shark
      b.  carp
      c.  trout
      d.  bream
      > c
  
  At which point, C<prompt()> would return the string C<'trout'>.
  
  Note that you can nest an arbitrary number of hashes, but that each
  "bottom" level choice has to be either a single string, or an array
  of strings.
  
  
  =head4 Navigating hierarchical menus
  
  Within a hierarchical menu, the user must either select a valid option
  (by entering the corresponding letter), or else may request that they be
  taken back up a level in the hierarchy, by entering C<< <ESC> >>.
  Pressing C<< <ESC> >> at the top level of a menu causes the call to
  C<prompt()> to immediately return with failure.
  
  
  =head3 Simulating a command-line
  
  =over 4
  
  C<< -argv >>
  
  C<< -a  >>
  
  =back
  
  The C<prompt()> subroutine can be used to request that the user provide
  command-line arguments interactively. When requested, the input
  operation is only carried out if C<@ARGV> is empty.
  
  Whatever the user enters is broken into a list and assigned to C<@ARGV>.
  
  The input is first C<glob>bed for file expansions, and has any
  environment variables (of the form C<$VARNAME> interpolated). The
  resulting string is then broken into individual words, except where
  parts of it contain single or double quotes, the contents of which are
  always treated as a single string.
  
  This feature is most useful during development, to allow a program to be
  run from within an editor, and yet pass it a variety of command-lines. The
  typical usage is (at the start of a program):
  
      use IO::Prompter;
      BEGIN { prompt -argv }
  
  However, because this pattern is so typical, there is a shortcut:
  
      use IO::Prompter -argv;
  
  You can also specify the name with which the program args, are to
  be prompted, in the usual way (i.e. by providing a prompt):
  
      use IO::Prompter -argv, 'demo.pl';
  
  Note, however, the critical difference between that shortcut
  (which calls C<prompt -argv> when the module is loaded) and:
  
      use IO::Prompter [-argv];
  
  (which sets C<-argv> as an automatic option for every subsequent call to
  C<prompt()> in the current lexical scope).
  
  Note too that the C<-argv> option also implies C<-complete=>'filenames'>.
  
  
  =head3 Input autocompletion
  
  =over 4
  
  C<< -comp[lete] => I<SPECIFICATION> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will complete
  input using the specified collection of strings. By default, when
  completion is active, word completion is requested using the C<< <TAB> >>
  key, but this can be changed by setting the C<$IO_PROMPTER_COMPLETE_KEY>
  environment variable. Once completion has been initiated, you can use
  the completion key or else C<< <CTRL-N> >> to advance to the next completion
  candidate. You can also use C<< <CTRL-P> >> to back up to the previous
  candidate.
  
  The specific completion mechanism can be defined either using a
  subroutine, an array reference, a hash reference, or a special string:
  
      Specification       Possible completions supplied by...
  
        sub {...}         ...whatever non-subroutine specification
                          (as listed below) is returned when the
                          subroutine is called. The subroutine is passed
                          the words of the current input text, split on
                          whitespace, as its argument list.
  
          [...]           ...the elements of the array
  
          {...}           ...the keys of the hash
  
       'filenames'        ...the list of files supplied by globbing the
                          last whitespace-separated word of the input text
  
       'dirnames'         ...the list of directories supplied by globbing the
                          last whitespace-separated word of the input text
  
  If an array or hash is used, only those elements or keys that begin with
  the last whitespace-separated word of the current input are offered as
  completions.
  
  For example:
  
      # Complete with the possible commands...
      my $next_cmd
          = prompt -complete => \%cmds;
  
      # Complete with valid usernames...
      my $user
          = prompt -complete => \@usernames;
  
      # Complete with valid directory names...
      my $file
          = prompt -complete => 'dirnames';
  
      # Complete with cmds on the first word, and filenames on the rest...
      my $cmdline
          = prompt -complete => sub { @_ <= 1 ? \%cmds : 'filenames' };
  
  
  =head4 Completing from your own input history
  
  The C<prompt()> subroutine also tracks previous input and allows you to
  complete with that instead. No special option is required, as the
  feature is enabled by default.
  
  At the start of a prompted input, the user can cycle backwards through
  previous inputs by pressing C<< <CTRL-R> >> (this can be changed
  externally by setting the C<$IO_PROMPTER_HISTORY_KEY> environment
  variable, or internally by assigning a new keyname to
  C<$ENV{IO_PROMPTER_HISTORY_KEY}>). After the first C<< <CTRL-R> >>,
  subsequent C<< <CTRL-R> >>'s will recall earlier inputs. You can also
  use C<< <CTRL-N> >> and C<< <CTRL-P> >>
  (as in L<user-specified completions|"Input autocompletion">) to move
  back and forth through your input history.
  
  If the user has already typed some input, the completion mechanism
  will only show previous inputs that begin with that partial input.
  
  
  =head4 History sets
  
  =over 4
  
  =item C<< -h[NAME] >>
  
  =item C<< -hist[ory] [=> NAME] >>
  
  =back
  
  By default, IO::Prompter tracks every call to C<prompt()> within a
  program, and accumulates a single set of history completions for all of
  them. That means that, at any prompt, C<< <CTRL-R> >> will take the user
  back through I<every> previous input, regardless of which call to
  C<prompt()> originally retrieved it.
  
  Sometimes that's useful, but sometimes you might prefer that different
  calls to C<prompt()> retained distinct memories. For example, consider
  the following input loop:
  
      while (my $name = prompt 'Name:') {
          my $grade   = prompt 'Grade:', -integer;
          my $comment = prompt 'Comment:';
          ...
      }
  
  If you're entering a name, there's no point in C<prompt()> offering
  to complete it with previous grades or comments. In fact, that's
  just annoying.
  
  IO::Prompter allows you to specify that a particular call to
  C<prompt()> belongs to a particular "history set". Then it completes
  input history using only the history of those calls belonging to the
  same history set.
  
  So the previous example could be improved like so:
  
      while (my $name = prompt 'Name:', -hNAME) {
          my $grade   = prompt 'Grade:', -hGRADE, -integer;
          my $comment = prompt 'Comment:', -hOTHER;
          ...
      }
  
  Now, when prompting for a name, only those inputs in the C<'NAME'>
  history set will be offered as history completions. Likewise only
  previous grades will be recalled when prompting for grades and earlier
  only comments when requesting comments.
  
  If you specify the C<-h> or C<-history> option without providing the
  name of the required history set, C<prompt()> uses the prompt text
  itself as the name of the call's history set. So the previous example
  would work equally well if written:
  
      while (my $name = prompt 'Name:', -h) {
          my $grade   = prompt 'Grade:', -h, -integer;
          my $comment = prompt 'Comment:', -h;
          ...
      }
  
  though now the names of the respective history sets would now be
  C<'Name: '>, C<'Grade: '>, and C<'Comment: '>. This is by far the more
  common method of specifying history sets, with explicitly named sets
  generally only being used when two or more separate calls to
  C<prompt()> have to share a common history despite using distinct
  prompts. For example:
  
      for my $n (1..3) {
          $address .= prompt "Address (line $n):", -hADDR;
      }
  
  If you specify C<'NONE'> as the history set, the input is not
  recorded in the history. This is useful when inputting passwords.
  
  
  =head4 Configuring the autocompletion interaction
  
  By default, when user-defined autocompletion is requested, the
  C<prompt()> subroutine determines the list of possible completions,
  displays it above the prompt, and completes to the longest common
  prefix. If the completion key is pressed again immediately, the
  subroutine then proceeds to complete with each possible completion in a
  cyclic sequence. This is known as "list+longest full" mode.
  
  On the other hand, when historical completion is requested, C<prompt()>
  just immediately cycles through previous full inputs. This is known as "full"
  mode.
  
  You can change these behaviours by setting the
  C<$IO_PROMPTER_COMPLETE_MODES> and C<$IO_PROMPTER_HISTORY_MODES>
  environment variables I<before the module is loaded> (either in your shell,
  or in a C<BEGIN> block before the module is imported).
  
  Specifically, you can set the individual string values of either of
  these variables to a whitespace-separated sequence containing any of the
  following:
  
      list         List all options above the input line
  
      longest      Complete to the longest common prefix
  
      full         Complete with each full match in turn
  
  For example:
  
      # Just list options without actually completing...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'list'; }
  
      # Just cycle full alternatives on each <TAB>...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'full'; }
  
      # For history completion, always start with the
      # longest common prefix on the first <CTRL-R>,
      # then just list the alternatives on a subsequent press...
      BEGIN{ $ENV{IO_PROMPTER_HISTORY_MODES} = 'longest list'; }
  
  
  =head3 Specifying what to return by default
  
  =over
  
  C<< -DEF[AULT] => I<STRING> >>
  
  C<< -def[ault] => I<STRING> >>
  
  C<< -dI<STRING> >>
  
  =back
  
  If a default value is specified, that value will be returned if the user
  enters an empty string at the prompt (i.e. if they just hit
  C<< <ENTER>/<RETURN> >> immediately) or if the input operation times out under
  L<the C<timeout> option|"Specifying how long to wait for input">.
  
  Note that the default value is not added to the prompt, unless you
  do so yourself. A typical usage might therefore be:
  
      my $frequency
          = prompt "Enter polling frequency [default: $DEF_FREQ]",
                   -num, -def=>$DEF_FREQ;
  
  You can determine if the default value was autoselected (as opposed to
  the same value being typed in explicitly) by calling the C<defaulted()>
  method on the object returned by C<prompt()>, like so:
  
      if ($frequency->defaulted) {
          say "Using default frequency";
      }
  
  If you use the L<< C<-must> option|"Constraining what can be returned" >>
  any default value must also satisfy all the constraints you specify,
  unless you use the C<-DEFAULT> form, which skips constraint checking
  when the default value is selected.
  
  If you use the L<< C<-menu> option|"Providing a menu of responses" >>,
  the specified default value will be returned immediately C<< <ENTER>/<RETURN> >> is
  pressed, regardless of the depth you are within the menu. Note that the
  default value specifies the value to be returned, not the selector key
  to be entered. The default value does not even have to be one of the
  menu choices.
  
  
  =head3 Specifying what to echo on input
  
  =over
  
  C<< -echo => I<STR> >>
  
  C<< -eI<STR> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will echo the
  specified string once for each character that is entered. Typically this
  would be used to shroud a password entry, like so:
  
      # Enter password silently:
      my $passwd
          = prompt 'Password:', -echo=>"";
  
      # Echo password showing only asterisks:
      my $passwd
          = prompt 'Password:', -echo=>"*";
  
  As a special case, if the C<-echo> value contains a slash (C</>) and the
  any of the <-yesno> options is also specified, the substring before the
  slash is taken as the string to echo for a 'yes' input, and the
  substring after the slash is echoed for a 'no' input.
  
  Note that this option is only available when the Term::ReadKey module
  is installed. If it is used when that module is not available, a warning
  will be issued.
  
  
  =head4 Specifying how to echo on input
  
  C<< -echostyle => I<SPECIFICATION> >>
  
  The C<-echostyle> option works for the text the user types in
  the same way that the C<-style> option works for the prompt.
  That is, you can specify the style and colour in which the user's
  input will be rendered like so:
  
      # Echo password showing only black asterisks on a red background:
      my $passwd
          = prompt 'Password:', -echo=>"*", -echostyle=>'black on red';
  
  Note that C<-echostyle> is completely independent of C<-echo>:
  
      # Echo user's name input in bold white:
      my $passwd
          = prompt 'Name:', -echostyle=>'bold white';
  
  The C<-echostyle> option requires C<Term::ANSIColor>, and will
  be silently ignored if that module is not available.
  
  
  =head4 Input editing
  
  When the Term::ReadKey module is available, C<prompt()> also honours a
  subset of the usual input cursor motion commands:
  
  =over
  
  =item C<CTRL-B>
  
  Move the cursor back one character
  
  =item C<CTRL-F>
  
  Move the cursor forward one character
  
  =item C<CTRL-A>
  
  Move the cursor to the start of the input
  
  =item C<CTRL-E>
  
  Move the cursor to the end of the input
  
  =back
  
  
  =head3 Specifying when input should fail
  
  =over 4
  
  C<< -fail => I<VALUE> >>
  
  C<< -fI<STRING> >>
  
  =back
  
  If this option is specified, the final input value is compared with the
  associated string or value, by smartmatching just before the call to
  C<prompt()> returns. If the two match, C<prompt()> returns a failure
  value. This means that instead of writing:
  
      while (my $cmd = prompt '>') {
          last if $cmd eq 'quit';
          ...
      }
  
  you can just write:
  
      while (my $cmd = prompt '>', -fail=>'quit') {
          ...
      }
  
  
  =head3 Constraining what can be typed
  
  =over 4
  
  =item C<< -guar[antee] => SPEC >>
  
  =back
  
  This option allows you to control what input users can provide.
  The specification can be a regex or a reference to an array or a hash.
  
  If the specification is a regex, that regex is matched against the input
  so far, every time an extra character is input. If the regex ever fails
  to match, the guarantee fails.
  
  If the specification is an array, the input so far is matched against
  the same number of characters from the start of each of the (string)
  elements of the array. If none of these substrings match the input, the
  guarantee fails.
  
  If the specification is a hash, the input so far is matched against the
  same number of characters from the start of each key of the hash. If
  none of these substrings match the input, the guarantee fails.
  
  If the guarantee fails, the input is rejected
  (just as L<< the C<-must> option|"Constraining what can be returned" >>
  does). However, unlike C<-must>, C<-guarantee> rejects the input
  character-by-character as it typed, and I<before> it is even echoed. For
  example, if your call to C<prompt()> is:
  
      my $animal = prompt -guarantee=>['cat','dog','cow'];
  
  then at the prompt:
  
      > _
  
  you will only be able to type in 'c' or 'd'. If you typed 'c', then you would
  only be able to type 'a' or 'o'. If you then typed 'o', you would only be able
  to type 'w'.
  
  In other words, C<-guarantee> ensures that you can only type in a valid input,
  and simply ignores any typing that would not lead to such an input.
  
  To help users get the input right, specifying C<-guarantee> as an array
  or hash reference also automatically specifies a
  L<< C<-complete> option|"Input autocompletion" >> with the array or hash
  as its completion list as well. So, whenever a C<-guarantee> is in
  effect, the user can usually autocomplete the acceptable inputs.
  
  Note, however, that C<-guarantee> can only reject (or autocomplete)
  input as it is typed if the Term::ReadKey module is available. If that
  module cannot be loaded, C<-guarantee> only applies its test after the
  C<< <ENTER>/<RETURN> >> key is pressed, and there will be no autocompletion
  available.
  
  =head4 Constraining input to numbers
  
  =over 4
  
  =item C<< -i >>
  
  =item C<< -integer [=> SPEC] >>
  
  =item C<< -n  >>
  
  =item C<< -num[ber] [=> SPEC] >>
  
  =back
  
  If any of these options are specified, C<prompt()> will only accept a valid
  integer or number as input, and will reprompt until one is entered.
  
  If you need to restrict the kind of number further (say, to positive
  integers), you can supply an extra constraint as an argument to the
  long-form option. Any number entered must satisfy this constraint by
  successfully smart-matching it. For example:
  
      $rep_count = prompt 'How many reps?', -integer => sub{ $_ > 0 };
  
      $die_roll = prompt 'What did you roll?', -integer => [1..6];
  
      $factor = prompt 'Prime factor:', -integer => \&is_prime;
  
      $score = prompt 'Enter score:', -number => sub{ 0 <= $_ && $_ <= 100 };
  
  If the constraint is specified as a subroutine, the entered number will be
  passed to it both as its single argument and in C<$_>.
  
  You cannot pass a scalar value directly as a constraint, except those strings
  listed below. If you want a scalar value as a constraint, use a regex or
  array reference instead:
  
      # Wrong...
      $answer = prompt "What's the ultimate answer?",
                        -integer => 42;
  
      # Use this instead...
      $answer = prompt "What's the ultimate answer?",
                       -integer => qr/^42$/;
  
      # Or this...
      $answer = prompt "What's the ultimate answer?",
                       -integer => [42];
  
  
  Only the following strings may be passed directly as scalar value
  constraints. They do mot match exactly, but instead act as specifiers
  for one or more built-in constraints. You can also pass a string that
  contains two or more of them, separated by whitespace, in which case
  they must all be satisfied. The specifiers are:
  
  =over 4
  
  =item C<'pos'> or C<'positive'>
  
  The number must be greater than zero
  
  =item C<'neg'> or C<'negative'>
  
  The number must be less than zero
  
  =item C<'zero'>
  
  The number must be equal to zero
  
  =item C<'even'> or C<'odd'>
  
  The number must have the correct parity
  
  =back
  
  You can also prepend C<"non"> to any of the above to reverse their meaning.
  
  For example:
  
      $rep_count = prompt 'How much do you bid?', -number => 'positive';
  
      $step_value = prompt 'Next step:', -integer => 'even nonzero';
  
  
  =head4 Constraining input to filenames
  
  =over 4
  
  =item C<< -f >>
  
  =item C<< -filenames >>
  
  =back
  
  You can tell C<prompt()> to accept only valid filenames, using the
  C<-filenames> option (or its shortcut: C<-f>).
  
  This option is equivalent to the options:
  
      -must => {
          'File must exist'       => sub { -e },
          'File must be readable' => sub { -r },
      },
      -complete => 'filenames',
  
  In other words C<-filenames> requires C<prompt()> to accept only the name
  of an existing, readable file, and it also activates filename completion.
  
  
  =head4 Constraining input to "keyletters"
  
  =over
  
  =item C<< -k >>
  
  =item C<< -key[let[ter]][s] >>
  
  =back
  
  A common interaction is to offer the user a range of actions, each of
  which is specified by keying a unique letter, like so:
  
      INPUT:
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          when (/S/i) { save_file()    }
          default     { goto INPUT;    }
      }
  
  This can be cleaned up (very slightly) by using a guarantee:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S',
                    -guarantee=>qr/[SRD]/i
      ) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  However, it's still annoying to have to specify the three key letters
  twice (and the default choice three times) within the call to
  C<prompt()>. So IO::Prompter provides an option that extracts this
  information directly from the prompt itself:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -keyletters) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  This option scans the prompt string and extracts any purely alphanumeric
  character sequences that are enclosed in balanced brackets of any kind
  (square, angle, round, or curly). It then makes each of these character
  sequences a valid input (by implicitly setting the C<-guarantee>
  option), and adds the first option in square brackets (if any) as the
  C<-default> value of the prompt.
  
  Note that the key letters don't have to be at the start of a word, don't
  have to be a single character, and can be either upper or lower case.
  For example:
  
      my $action = prompt -k, '(S)ave, Save(a)ll, (Ex)it without saving';
  
  Multi-character key letters are often a good choice for options with
  serious or irreversible consequences.
  
  A common idiom with key letters is to use the C<-single> option as well,
  so that pressing any key letter immediately completes the input, without
  the user having to also press C<< <ENTER>/<RETURN> >>:
  
      given (prompt -k1, '[S]ave, (R)evert, or (D)iscard:') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  
  
  =head3 Preserving terminal newlines
  
  =over 4
  
  =item C<< -l  >>
  
  =item C<< -line >>
  
  =back
  
  The (encapsulated) string returned by C<prompt()> is automatically chomped by
  default. To prevent that chomping, specify this option.
  
  
  =head3 Constraining what can be returned
  
  =over 4
  
  =item C<< -must => HASHREF >>
  
  =back
  
  This option allows you to specify requirements and constraints on the input
  string that is returned by C<prompt()>. These limitations are specified as the
  values of a hash.
  
  If the C<-must> option is specified, once input is complete every value in the
  specified hash is smartmatched against the input text. If any of them fail to
  match, the input is discarded, the corresponding hash key is printed as an
  error message, and the prompt is repeated.
  
  Note that the values of the constraint hash cannot be single strings or
  numbers, except for certain strings (such as C<'pos'>, C<'nonzero'>, or
  C<'even'>, as described in L<"Constraining input to numbers">).
  
  If you want to constrain the input to a single string or number (a very
  unusual requirement), just place the value in an array, or match it
  with a regex:
  
      # This doesn't work...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => 'please' };
  
      # Use this instead...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => ['please'] };
  
      # Or, better still...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => qr/please/i };
  
  
  The C<-must> option allows you to test inputs against multiple
  conditions and have the appropriate error messages for each displayed.
  It also ensures that, when C<prompt()> eventually returns, you are
  guaranteed that the input meets all the specified conditions.
  
  For example, suppose the user is required to enter a positive odd prime
  number less than 100. You could enforce that with:
  
      my $opnlt100 = prompt 'Enter your guess:',
                            -integer,
                            -must => { 'be odd'                 => 'odd',
                                       'be in range'            => [1..100],
                                       'It must also be prime:' => \&isprime,
                                     };
  
  Note that, if the error message begins with anything except an uppercase
  character, the prompt is reissued followed by the error message in
  parentheses with the word "must" prepended (where appropriate).
  Otherwise, if the error message does start with an uppercase character,
  the prompt is not reissued and the error message is printed verbatim. So
  a typical input sequence for the previous example might look like:
  
      Enter your guess: 101
      Enter your guess: (must be in range) 42
      It must also be prime: 2
      Enter your guess: (must be odd) 7
  
  at which point, the call to C<prompt()> would accept the input and return.
  
  See also L<the C<-guarantee> option|"Constraining what can be typed">,
  which allows you to constrain inputs as they are typed, rather than
  after they are entered.
  
  
  =head3 Changing how returns are echoed
  
  =over 4
  
  =item C<< -r[STR] >>
  
  =item C<< -ret[urn] [=> STR] >>
  
  =back
  
  When C<< <ENTER>/<RETURN> >> is pressed, C<prompt()> usually echoes a carriage return.
  However, if this option is given, C<prompt()> echoes the specified string
  instead. If the string is omitted, it defaults to C<"\n">.
  
  For example:
  
      while (1) {
          my $expr = prompt 'Calculate:', -ret=>' = ';
          say evaluate($expr);
      }
  
  would prompt for something like this:
  
      Calculate: 2*3+4^5_
  
  and when the C<< <ENTER>/<RETURN> >> key is pressed, respond with:
  
      Calculate: 2*3+4^5 = 1030
      Calculate: _
  
  The string specified with C<-return> is also automatically echoed if the
  L<< C<-single> option|"Single-character input" >> is used. So if you
  don't want the automatic carriage return that C<-single> mode supplies,
  specify C<< -return=>"" >>.
  
  
  =head3 Single-character input
  
  =over 4
  
  =item C<< -s >>
  
  =item C<< -1 >>
  
  =item C<< -sing[le] >>
  
  =back
  
  This option causes C<prompt()> to return immediately once any single
  character is input. The user does not have to push the C<< <ENTER>/<RETURN> >>
  key to complete the input operation. C<-single> mode input is only
  available if the Term::ReadKey module can be loaded.
  
  By default, C<prompt()> echoes the single character that is entered. Use
  the L<C<-echo> option|"Specifying what to echo on input"> to change or
  prevent that.
  
      # Let user navigate through maze by single, silent keypresses...
      while ($nextdir = prompt "\n", -single, -echo, -guarantee=>qr/[nsew]/) {
          move_player($nextdir);
      }
  
  Unless echoing has been disabled, by default C<prompt()> also supplies a
  carriage return after the input character. Use
  L<the C<-return> option|"Changing how returns are echoed"> to change
  that behaviour. For example, this:
  
      my $question = <<END_QUESTION;
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer:
      END_QUESTION
  
      my $response = prompt $question, -1, -return=>' is ', -g=>['a'..'d'];
      say $response eq $answer ? 'CORRECT' : 'incorrect';
  
  prompts like this:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: _
  
  accepts a single character, like so:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b_
  
  and completes the line thus:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b is CORRECT
      _
  
  
  =head3 Returning raw data
  
  =over 4
  
  =item C<< -v >>
  
  =item C<< -verb[atim] >>
  
  =back
  
  Normally, C<prompt()> returns a special object that contains the text
  input, the success value, and other information such as whether the
  default was selected and whether the input operation timed out.
  
  However, if you prefer to have C<prompt()> just return the input text string
  directly, you can specify this option.
  
  Note however that, under C<-verbatim>, the input is still
  autochomped (unless you also specify
  L<the C<-line> option|"Preserving terminal newlines">.
  
  
  =head3 Prompting on a clear screen
  
  =over 4
  
  =item C<< -w >>
  
  =item C<< -wipe[first] >>
  
  =back
  
  If this option is present, C<prompt()> prints 1000 newlines before
  printing its prompt, effectively wiping the screen clear of other text.
  
  If the C<-wipefirst> variant is used, the wipe will only occur if the
  particular call to C<prompt()> is the first such call anywhere in your
  program. This is useful if you'd like the screen cleared at the start of
  input only, but you're not sure which call to C<prompt()> will happen
  first: just use C<-wipefirst> on all possible initial calls and only the
  actual first call will wipe the screen.
  
  
  =head3 Requesting confirmations
  
  =over 4
  
  =item C<< -y[n] >> or C<< -Y[N] >>
  
  =item C<< -yes[no] >> or C<< -Yes[No] >>
  
  =item C<< -yes[no] => COUNT >> or C<< -Yes[No] => COUNT >>
  
  =back
  
  This option invokes a special mode that can be used to confirm (or deny)
  something. If one of these options is specified, C<prompt> still
  returns the user's input, but the success or failure of the object returned
  now depends on what the user types in.
  
  A true result is returned if C<'y'> is the first character entered. If
  the flag includes an C<n> or C<N>, a false result is returned if C<'n'>
  is the first character entered (and any other input causes the prompt to
  be reissued). If the option doesn't contain an C<n> or C<N>, any input
  except C<'y'> is treated as a "no" and a false value is returned.
  
  If the option is capitalized (C<-Y> or C<-YN>), the first letter of the
  input must be likewise a capital (this is a handy means of slowing down
  automatic unthinking C<y>..."Oh no!" responses to potentially serious
  decisions).
  
  This option is most often used in conjunction with the C<-single> option, like
  so:
  
      $continue = prompt("Continue? ", -yn1);
  
  so that the user can just hit C<y> or C<n> to continue, without having to hit
  C<< <ENTER>/<RETURN> >> as well.
  
  If the optional I<COUNT> argument is supplied, the prompting is repeated
  that many times, with increasingly insistent requests for confirmation.
  The answer must be "yes" in each case for the final result to be true.
  For example:
  
      $rm_star = prompt("Do you want to delete all files? ", -Yes=>3 );
  
  might prompt:
  
      Do you want to delete all files?  Y
      Really?  Y
      Are you sure?  Y
  
  
  
  =head3 Bundling short-form options
  
  You can bundle together any number of short-form options, including those that
  take string arguments. For example, instead of writing:
  
      if (prompt "Continue? ", -yes, -1, -t10, -dn) {
  
  you could just write:
  
      if (prompt "Continue? ", -y1t10dn) {...}
  
  This often does I<not> improve readability (as the preceding example
  demonstrates), but is handy for common usages such as C<-y1> ("ask for
  confirmation, don't require an C<< <ENTER>/<RETURN> >>) or C<-vl>
  ("Return a verbatim and unchomped string").
  
  
  =head3 Escaping otherwise-magic options
  
  =over 4
  
  C<< -_ >>
  
  =back
  
  The C<-_> option exists only to be an explicit no-op. It allows you to
  specify short-form options that would otherwise be interpreted as Perl
  file operators or other special constructs, simply by prepending or
  appending a C<_> to them. For example:
  
      my $input
          = prompt -l_;  # option -l, not the -l file operator.
  
  The following single-letter options require an underscore to chaperone them
  when they're on their own: C<-e>, C<-l>, C<-r>, C<-s>, C<-w>, and C<-y>.
  However, an underscore is not required if two or more are bundled together.
  
  
  =head2 Useful useless uses of C<prompt()>
  
  Normally, in a void context, a call to C<prompt()> issues a warning that
  you are doing an input operation whose input is immediately thrown away.
  
  There is, however, one situation where this useless use of C<prompt()> in a
  void context is actually useful:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single);
      exit;
  
  Here, we're using prompt simply to pause the application after the data is
  printed. It doesn't matter what the user types in; the typing itself is the
  message (and the message is "move along").
  
  In such cases, the "useless use..." warning can be suppressed using the 
  C<< -void >> option:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single, -void);
      exit;
  
  
  =head2 Simulating input
  
  IO::Prompter provides a mechanism with which you can "script" a sequence of
  inputs to an application. This is particularly useful when demonstrating
  software during a presentation, as you do not have to remember what to type,
  or concentrate on typing at all.
  
  If you pass a string as an argument to C<use IO::Prompter>, the
  individual lines of that string are used as successive input lines to
  any call to C<prompt()>. So for example, you could specify several sets
  of input data, like so:
  
      use IO::Prompter <<END_DATA
      Leslie
      45
      165
      Jessie
      28
      178
      Dana
      12
      120
      END_DATA
  
  and then read this data in an input loop:
  
      while (my $name   = prompt 'Name:') {
             my $age    = prompt 'Age:';
             my $height = prompt 'Height:';
  
             process($name, $age, $height);
      }
  
  Because the C<use IO::Prompter> supplies input data,
  the three calls to C<prompt()> will no longer read
  data from C<*ARGV>. Instead they will read it from
  the supplied input data.
  
  Moreover, each call to C<prompt()> will simulate the typing-in process
  automatically. That is, C<prompt()> uses a special input mode where,
  each time you press a keyboard letter, it echoes not that character, but
  rather the next character from the specified input. The effect is that
  you can just type on the keyboard at random, but have the correct input
  appear. This greatly increases the convincingness of the simulation.
  
  If at any point, you hit C<< <ENTER>/<RETURN> >> on the keyboard, C<prompt()>
  finishes typing in the input for you (using a realistic typing speed),
  and returns the input string. So you can also just hit C<< <ENTER>/<RETURN> >>
  when the prompt first appears, to have the entire line of input typed
  for you.
  
  Alternatively, if you hit C<< <ESC> >> at any point, C<prompt()> escapes
  from the simulated input mode for that particular call to C<prompt()>,
  and allows you to (temporarily) type text in directly. If you enter only
  a single C<< <ESC> >>, then C<prompt()> throws away the current line of
  simulated input; if you enter two C<< <ESC> >>'s, the simulated input is
  merely deferred to the next call to C<prompt()>.
  
  All these keyboard behaviours require the Term::ReadKey module to be
  available. If it isn't, C<prompt()> falls back on a simpler simulation,
  where it just autotypes each entire line for you and pauses at the
  end of the line, waiting for you to hit C<< <ENTER>/<RETURN> >> manually.
  
  Note that any line of the simulated input that begins with
  a <CTRL-D> or <CTRL-Z> is treated as an input failure (just as
  if you'd typed that character as input).
  
  =head1 DIAGNOSTICS
  
  All non-fatal diagnostics can be disabled using a C<no warnings> with the
  appropriate category.
  
  =over
  
  =item C<< prompt(): Can't open *ARGV: %s >>
  
  (F)  By default, C<prompt()> attempts to read input from
       the C<*ARGV> filehandle. However, it failed to open
       that filehandle. The reason is specified at the end of
       the message.
  
  
  =item C<< prompt(): Missing value for %s (expected %s) >>
  
  (F)  A named option that requires an argument was specified,
       but no argument was provided after the option. See
       L<"Summary of options">.
  
  
  =item C<< prompt(): Invalid value for %s (expected %s) >>
  
  (F)  The named option specified expects an particular type
       of argument, but found one of an incompatible type
       instead. See L<"Summary of options">.
  
  
  =item C<< prompt(): Unknown option %s ignored >>
  
  (W misc)  C<prompt()> was passed a string starting with
            a hyphen, but could not parse that string as a
            valid option. The option may have been misspelt.
            Alternatively, if the string was supposed to be
            (part of) the prompt, it will be necessary to use
            L<the C<-prompt> option|"Specifying what to
            prompt"> to specify it.
  
  
  =item C<< prompt(): Unexpected argument (% ref) ignored >>
  
  (W reserved)  C<prompt()> was passed a reference to
                an array or hash or subroutine in a position
                where an option flag or a prompt string was
                expected. This may indicate that a string
                variable in the argument list didn't contain
                what was expected, or a reference variable was
                not properly dereferenced. Alternatively, the
                argument may have been intended as the
                argument to an option, but has become
                separated from it somehow, or perhaps the
                option was deleted without removing the
                argument as well.
  
  
  =item C<< Useless use of prompt() in void context >>
  
  (W void)  C<prompt()> was called but its return value was
            not stored or used in any way. Since the
            subroutine has no side effects in void context,
            calling it this way achieves nothing. Either make
            use of the return value directly or, if the usage
            is deliberate, put a C<scalar> in front of the
            call to remove the void context.
  
  
  =item C<< prompt(): -default value does not satisfy -must constraints >>
  
  (W misc)  The C<-must> flag was used to specify one or more
            input constraints. The C<-default> flag was also
            specified. Unfortunately, the default value
            provided did not satisfy the requirements
            specified by the C<-must> flag. The call to
            C<prompt()> will still go ahead (after issuing the
            warning), but the default value will never be
            returned, since the constraint check will reject
            it. It is probably better simply to include the
            default value in the list of constraints.
  
  
  =item C<< prompt(): -keyletters found too many defaults >>
  
  (W ambiguous)  The C<-keyletters> option was specified,
                 but analysis of the prompt revealed two or
                 more character sequences enclosed in square
                 brackets. Since such sequences are taken to
                 indicate a default value, having two or more
                 makes the default ambiguous. The prompt
                 should be rewritten with no more than one set
                 of square brackets.
  
  
  =item C<< Warning: next input will be in plaintext >>
  
  (W bareword)  The C<prompt()> subroutine was called with
                the C<-echo> flag, but the Term::ReadKey
                module was not available to implement this
                feature. The input will proceed as normal, but
                this warning is issued to ensure that the user
                doesn't type in something secret, expecting it
                to remain hidden, which it won't.
  
  
  =item C<< prompt(): Too many menu items. Ignoring the final %d >>
  
  (W misc)  A C<-menu> was specified with more than 52 choices.
            Because, by default, menus use upper and lower-
            case alphabetic characters as their selectors,
            there were no available selectors for the extra
            items after the first 52. Either reduce the number
            of choices to 52 or less, or else add the
            C<-number> option to use numeric selectors instead.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  IO::Prompter can be configured by setting any of the following
  environment variables:
  
  =over
  
  =item C<$IO_PROMPTER_COMPLETE_KEY>
  
  Specifies the key used to initiate
  L<user-specified completions|"Input autocompletion">.
  Defaults to <TAB>
  
  =item C<$IO_PROMPTER_HISTORY_KEY>
  
  Specifies the key used to initiate
  L<history completions|"Completing from your input history">.
  Defaults to <CTRL-R>
  
  =item C<$IO_PROMPTER_COMPLETE_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for user-defined completions.  Defaults to C<'list+longest  full'>
  
  =item C<$IO_PROMPTER_HISTORY_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for history completions.  Defaults to C<'full'>.
  
  =back
  
  
  =head1 DEPENDENCIES
  
  Requires the Contextual::Return module.
  
  The module also works much better if Term::ReadKey is available
  (though this is not essential).
  
  
  =head1 INCOMPATIBILITIES
  
  This module does not play well with Moose (or more specifically, with
  Moose::Exporter) because both of them try to play sneaky games with
  Scalar::Util::blessed.
  
  The current solution is to make sure that you load Moose before
  loading IO::Prompter. Even just doing this:
  
      use Moose ();
      use IO::Prompter;
  
  is sufficient.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No unresolved bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-io-prompter@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@CPAN.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2009, Damian Conway C<< <DCONWAY@CPAN.org> >>.
  All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
IO_PROMPTER

$fatpacked{"Log/Log4perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL';
  ##################################################
  package Log::Log4perl;
  ##################################################
  
  END { local($?); Log::Log4perl::Logger::cleanup(); }
  
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl::Util;
  use Log::Log4perl::Logger;
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  use Log::Log4perl::Appender;
  
  our $VERSION = '1.46';
  
     # set this to '1' if you're using a wrapper
     # around Log::Log4perl
  our $caller_depth = 0;
  
      #this is a mapping of convenience names to opcode masks used in
      #$ALLOWED_CODE_OPS_IN_CONFIG_FILE below
  our %ALLOWED_CODE_OPS = (
      'safe'        => [ ':browse' ],
      'restrictive' => [ ':default' ],
  );
  
  our %WRAPPERS_REGISTERED = map { $_ => 1 } qw(Log::Log4perl);
  
      #set this to the opcodes which are allowed when
      #$ALLOW_CODE_IN_CONFIG_FILE is set to a true value
      #if undefined, there are no restrictions on code that can be
      #excuted
  our @ALLOWED_CODE_OPS_IN_CONFIG_FILE;
  
      #this hash lists things that should be exported into the Safe
      #compartment.  The keys are the package the symbol should be
      #exported from and the values are array references to the names
      #of the symbols (including the leading type specifier)
  our %VARS_SHARED_WITH_SAFE_COMPARTMENT = (
      main => [ '%ENV' ],
  );
  
      #setting this to a true value will allow Perl code to be executed
      #within the config file.  It works in conjunction with
      #$ALLOWED_CODE_OPS_IN_CONFIG_FILE, which if defined restricts the
      #opcodes which can be executed using the 'Safe' module.
      #setting this to a false value disables code execution in the
      #config file
  our $ALLOW_CODE_IN_CONFIG_FILE = 1;
  
      #arrays in a log message will be joined using this character,
      #see Log::Log4perl::Appender::DBI
  our $JOIN_MSG_ARRAY_CHAR = '';
  
      #version required for XML::DOM, to enable XML Config parsing
      #and XML Config unit tests
  our $DOM_VERSION_REQUIRED = '1.29'; 
  
  our $CHATTY_DESTROY_METHODS = 0;
  
  our $LOGDIE_MESSAGE_ON_STDERR = 1;
  our $LOGEXIT_CODE             = 1;
  our %IMPORT_CALLED;
  
  our $EASY_CLOSURES = {};
  
    # to throw refs as exceptions via logcarp/confess, turn this off
  our $STRINGIFY_DIE_MESSAGE = 1;
  
  use constant _INTERNAL_DEBUG => 0;
  
  ##################################################
  sub import {
  ##################################################
      my($class) = shift;
  
      my $caller_pkg = caller();
  
      return 1 if $IMPORT_CALLED{$caller_pkg}++;
  
      my(%tags) = map { $_ => 1 } @_;
  
          # Lazy man's logger
      if(exists $tags{':easy'}) {
          $tags{':levels'} = 1;
          $tags{':nowarn'} = 1;
          $tags{'get_logger'} = 1;
      }
  
      if(exists $tags{':no_extra_logdie_message'}) {
          $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR = 0;
          delete $tags{':no_extra_logdie_message'};
      }
  
      if(exists $tags{get_logger}) {
          # Export get_logger into the calling module's 
          no strict qw(refs);
          *{"$caller_pkg\::get_logger"} = *get_logger;
  
          delete $tags{get_logger};
      }
  
      if(exists $tags{':levels'}) {
          # Export log levels ($DEBUG, $INFO etc.) from Log4perl::Level
          for my $key (keys %Log::Log4perl::Level::PRIORITY) {
              my $name  = "$caller_pkg\::$key";
                 # Need to split this up in two lines, or CVS will
                 # mess it up.
              my $value = $
                          Log::Log4perl::Level::PRIORITY{$key};
              no strict qw(refs);
              *{"$name"} = \$value;
          }
  
          delete $tags{':levels'};
      }
  
          # Lazy man's logger
      if(exists $tags{':easy'}) {
          delete $tags{':easy'};
  
              # Define default logger object in caller's package
          my $logger = get_logger("$caller_pkg");
          
              # Define DEBUG, INFO, etc. routines in caller's package
          for(qw(TRACE DEBUG INFO WARN ERROR FATAL ALWAYS)) {
              my $level   = $_;
              $level = "OFF" if $level eq "ALWAYS";
              my $lclevel = lc($_);
              easy_closure_create($caller_pkg, $_, sub {
                  Log::Log4perl::Logger::init_warn() unless 
                      $Log::Log4perl::Logger::INITIALIZED or
                      $Log::Log4perl::Logger::NON_INIT_WARNED;
                  $logger->{$level}->($logger, @_, $level);
              }, $logger);
          }
  
              # Define LOGCROAK, LOGCLUCK, etc. routines in caller's package
          for(qw(LOGCROAK LOGCLUCK LOGCARP LOGCONFESS)) {
              my $method = "Log::Log4perl::Logger::" . lc($_);
  
              easy_closure_create($caller_pkg, $_, sub {
                  unshift @_, $logger;
                  goto &$method;
              }, $logger);
          }
  
              # Define LOGDIE, LOGWARN
           easy_closure_create($caller_pkg, "LOGDIE", sub {
               Log::Log4perl::Logger::init_warn() unless 
                       $Log::Log4perl::Logger::INITIALIZED or
                       $Log::Log4perl::Logger::NON_INIT_WARNED;
               $logger->{FATAL}->($logger, @_, "FATAL");
               $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ?
                   CORE::die(Log::Log4perl::Logger::callerline(join '', @_)) :
                   exit $Log::Log4perl::LOGEXIT_CODE;
           }, $logger);
  
           easy_closure_create($caller_pkg, "LOGEXIT", sub {
              Log::Log4perl::Logger::init_warn() unless 
                      $Log::Log4perl::Logger::INITIALIZED or
                      $Log::Log4perl::Logger::NON_INIT_WARNED;
              $logger->{FATAL}->($logger, @_, "FATAL");
              exit $Log::Log4perl::LOGEXIT_CODE;
           }, $logger);
  
          easy_closure_create($caller_pkg, "LOGWARN", sub {
              Log::Log4perl::Logger::init_warn() unless 
                      $Log::Log4perl::Logger::INITIALIZED or
                      $Log::Log4perl::Logger::NON_INIT_WARNED;
              $logger->{WARN}->($logger, @_, "WARN");
              CORE::warn(Log::Log4perl::Logger::callerline(join '', @_))
                  if $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR;
          }, $logger);
      }
  
      if(exists $tags{':nowarn'}) {
          $Log::Log4perl::Logger::NON_INIT_WARNED = 1;
          delete $tags{':nowarn'};
      }
  
      if(exists $tags{':nostrict'}) {
          $Log::Log4perl::Logger::NO_STRICT = 1;
          delete $tags{':nostrict'};
      }
  
      if(exists $tags{':resurrect'}) {
          my $FILTER_MODULE = "Filter::Util::Call";
          if(! Log::Log4perl::Util::module_available($FILTER_MODULE)) {
              die "$FILTER_MODULE required with :resurrect" .
                  "(install from CPAN)";
          }
          eval "require $FILTER_MODULE" or die "Cannot pull in $FILTER_MODULE";
          Filter::Util::Call::filter_add(
              sub {
                  my($status);
                  s/^\s*###l4p// if
                      ($status = Filter::Util::Call::filter_read()) > 0;
                  $status;
                  });
          delete $tags{':resurrect'};
      }
  
      if(keys %tags) {
          # We received an Option we couldn't understand.
          die "Unknown Option(s): @{[keys %tags]}";
      }
  }
  
  ##################################################
  sub initialized {
  ##################################################
      return $Log::Log4perl::Logger::INITIALIZED;
  }
  
  ##################################################
  sub new {
  ##################################################
      die "THIS CLASS ISN'T FOR DIRECT USE. " .
          "PLEASE CHECK 'perldoc " . __PACKAGE__ . "'.";
  }
  
  ##################################################
  sub reset { # Mainly for debugging/testing
  ##################################################
      # Delegate this to the logger ...
      return Log::Log4perl::Logger->reset();
  }
  
  ##################################################
  sub init_once { # Call init only if it hasn't been
                  # called yet.
  ##################################################
      init(@_) unless $Log::Log4perl::Logger::INITIALIZED;
  }
  
  ##################################################
  sub init { # Read the config file
  ##################################################
      my($class, @args) = @_;
  
      #woops, they called ::init instead of ->init, let's be forgiving
      if ($class ne __PACKAGE__) {
          unshift(@args, $class);
      }
  
      # Delegate this to the config module
      return Log::Log4perl::Config->init(@args);
  }
  
  ##################################################
  sub init_and_watch { 
  ##################################################
      my($class, @args) = @_;
  
      #woops, they called ::init instead of ->init, let's be forgiving
      if ($class ne __PACKAGE__) {
          unshift(@args, $class);
      }
  
      # Delegate this to the config module
      return Log::Log4perl::Config->init_and_watch(@args);
  }
  
  
  ##################################################
  sub easy_init { # Initialize the root logger with a screen appender
  ##################################################
      my($class, @args) = @_;
  
      # Did somebody call us with Log::Log4perl::easy_init()?
      if(ref($class) or $class =~ /^\d+$/) {
          unshift @args, $class;
      }
  
      # Reset everything first
      Log::Log4perl->reset();
  
      my @loggers = ();
  
      my %default = ( level    => $DEBUG,
                      file     => "STDERR",
                      utf8     => undef,
                      category => "",
                      layout   => "%d %m%n",
                    );
  
      if(!@args) {
          push @loggers, \%default;
      } else {
          for my $arg (@args) {
              if($arg =~ /^\d+$/) {
                  my %logger = (%default, level => $arg);
                  push @loggers, \%logger;
              } elsif(ref($arg) eq "HASH") {
                  my %logger = (%default, %$arg);
                  push @loggers, \%logger;
              }
          }
      }
  
      for my $logger (@loggers) {
  
          my $app;
  
          if($logger->{file} =~ /^stderr$/i) {
              $app = Log::Log4perl::Appender->new(
                  "Log::Log4perl::Appender::Screen",
                  utf8 => $logger->{utf8});
          } elsif($logger->{file} =~ /^stdout$/i) {
              $app = Log::Log4perl::Appender->new(
                  "Log::Log4perl::Appender::Screen",
                  stderr => 0,
                  utf8   => $logger->{utf8});
          } else {
              my $binmode;
              if($logger->{file} =~ s/^(:.*?)>/>/) {
                  $binmode = $1;
              }
              $logger->{file} =~ /^(>)?(>)?/;
              my $mode = ($2 ? "append" : "write");
              $logger->{file} =~ s/.*>+\s*//g;
              $app = Log::Log4perl::Appender->new(
                  "Log::Log4perl::Appender::File",
                  filename => $logger->{file},
                  mode     => $mode,
                  utf8     => $logger->{utf8},
                  binmode  => $binmode,
              );
          }
  
          my $layout = Log::Log4perl::Layout::PatternLayout->new(
                                                          $logger->{layout});
          $app->layout($layout);
  
          my $log = Log::Log4perl->get_logger($logger->{category});
          $log->level($logger->{level});
          $log->add_appender($app);
      }
  
      $Log::Log4perl::Logger::INITIALIZED = 1;
  }
  
  ##################################################
  sub wrapper_register {  
  ##################################################
      my $wrapper = $_[-1];
  
      $WRAPPERS_REGISTERED{ $wrapper } = 1;
  }
  
  ##################################################
  sub get_logger {  # Get an instance (shortcut)
  ##################################################
      # get_logger() can be called in the following ways:
      #
      #   (1) Log::Log4perl::get_logger()     => ()
      #   (2) Log::Log4perl->get_logger()     => ("Log::Log4perl")
      #   (3) Log::Log4perl::get_logger($cat) => ($cat)
      #   
      #   (5) Log::Log4perl->get_logger($cat) => ("Log::Log4perl", $cat)
      #   (6)   L4pSubclass->get_logger($cat) => ("L4pSubclass", $cat)
  
      # Note that (4) L4pSubclass->get_logger() => ("L4pSubclass")
      # is indistinguishable from (3) and therefore can't be allowed.
      # Wrapper classes always have to specify the category explicitly.
  
      my $category;
  
      if(@_ == 0) {
            # 1
          my $level = 0;
          do { $category = scalar caller($level++);
          } while exists $WRAPPERS_REGISTERED{ $category };
  
      } elsif(@_ == 1) {
            # 2, 3
          $category = $_[0];
  
          my $level = 0;
          while(exists $WRAPPERS_REGISTERED{ $category }) { 
              $category = scalar caller($level++);
          }
  
      } else {
            # 5, 6
          $category = $_[1];
      }
  
      # Delegate this to the logger module
      return Log::Log4perl::Logger->get_logger($category);
  }
  
  ###########################################
  sub caller_depth_offset {
  ###########################################
      my( $level ) = @_;
  
      my $category;
  
      { 
          my $category = scalar caller($level + 1);
  
          if(defined $category and
             exists $WRAPPERS_REGISTERED{ $category }) {
              $level++;
              redo;
          }
      }
  
      return $level;
  }
  
  ##################################################
  sub appenders {  # Get a hashref of all defined appender wrappers
  ##################################################
      return \%Log::Log4perl::Logger::APPENDER_BY_NAME;
  }
  
  ##################################################
  sub add_appender { # Add an appender to the system, but don't assign
  	           # it to a logger yet
  ##################################################
      my($class, $appender) = @_;
  
      my $name = $appender->name();
      die "Mandatory parameter 'name' missing in appender" unless defined $name;
  
        # Make it known by name in the Log4perl universe
        # (so that composite appenders can find it)
      Log::Log4perl->appenders()->{ $name } = $appender;
  }
  
  ##################################################
  # Return number of appenders changed
  sub appender_thresholds_adjust {  # Readjust appender thresholds
  ##################################################
          # If someone calls L4p-> and not L4p::
      shift if $_[0] eq __PACKAGE__;
      my($delta, $appenders) = @_;
  	my $retval = 0;
  
      if($delta == 0) {
            # Nothing to do, no delta given.
          return;
      }
  
      if(defined $appenders) {
              # Map names to objects
          $appenders = [map { 
                         die "Unkown appender: '$_'" unless exists
                            $Log::Log4perl::Logger::APPENDER_BY_NAME{
                              $_};
                         $Log::Log4perl::Logger::APPENDER_BY_NAME{
                           $_} 
                        } @$appenders];
      } else {
              # Just hand over all known appenders
          $appenders = [values %{Log::Log4perl::appenders()}] unless 
              defined $appenders;
      }
  
          # Change all appender thresholds;
      foreach my $app (@$appenders) {
          my $old_thres = $app->threshold();
          my $new_thres;
          if($delta > 0) {
              $new_thres = Log::Log4perl::Level::get_higher_level(
                               $old_thres, $delta);
          } else {
              $new_thres = Log::Log4perl::Level::get_lower_level(
                               $old_thres, -$delta);
          }
  
          ++$retval if ($app->threshold($new_thres) == $new_thres);
      }
  	return $retval;
  }
  
  ##################################################
  sub appender_by_name {  # Get a (real) appender by name
  ##################################################
          # If someone calls L4p->appender_by_name and not L4p::appender_by_name
      shift if $_[0] eq __PACKAGE__;
  
      my($name) = @_;
  
      if(defined $name and
         exists $Log::Log4perl::Logger::APPENDER_BY_NAME{
                   $name}) {
          return $Log::Log4perl::Logger::APPENDER_BY_NAME{
                   $name}->{appender};
      } else {
          return undef;
      }
  }
  
  ##################################################
  sub eradicate_appender {  # Remove an appender from the system
  ##################################################
          # If someone calls L4p->... and not L4p::...
      shift if $_[0] eq __PACKAGE__;
      Log::Log4perl::Logger->eradicate_appender(@_);
  }
  
  ##################################################
  sub infiltrate_lwp {  # 
  ##################################################
      no warnings qw(redefine);
  
      my $l4p_wrapper = sub {
          my($prio, @message) = @_;
          local $Log::Log4perl::caller_depth =
                $Log::Log4perl::caller_depth + 2;
          get_logger(scalar caller(1))->log($prio, @message);
      };
  
      *LWP::Debug::trace = sub { 
          $l4p_wrapper->($INFO, @_); 
      };
      *LWP::Debug::conns =
      *LWP::Debug::debug = sub { 
          $l4p_wrapper->($DEBUG, @_); 
      };
  }
  
  ##################################################
  sub easy_closure_create {
  ##################################################
      my($caller_pkg, $entry, $code, $logger) = @_;
  
      no strict 'refs';
  
      print("easy_closure: Setting shortcut $caller_pkg\::$entry ", 
           "(logger=$logger\n") if _INTERNAL_DEBUG;
  
      $EASY_CLOSURES->{ $caller_pkg }->{ $entry } = $logger;
      *{"$caller_pkg\::$entry"} = $code;
  }
  
  ###########################################
  sub easy_closure_cleanup {
  ###########################################
      my($caller_pkg, $entry) = @_;
  
      no warnings 'redefine';
      no strict 'refs';
  
      my $logger = $EASY_CLOSURES->{ $caller_pkg }->{ $entry };
  
      print("easy_closure: Nuking easy shortcut $caller_pkg\::$entry ", 
           "(logger=$logger\n") if _INTERNAL_DEBUG;
  
      *{"$caller_pkg\::$entry"} = sub { };
      delete $EASY_CLOSURES->{ $caller_pkg }->{ $entry };
  }
  
  ##################################################
  sub easy_closure_category_cleanup {
  ##################################################
      my($caller_pkg) = @_;
  
      if(! exists $EASY_CLOSURES->{ $caller_pkg } ) {
          return 1;
      }
  
      for my $entry ( keys %{ $EASY_CLOSURES->{ $caller_pkg } } ) {
          easy_closure_cleanup( $caller_pkg, $entry );
      }
  
      delete $EASY_CLOSURES->{ $caller_pkg };
  }
  
  ###########################################
  sub easy_closure_global_cleanup {
  ###########################################
  
      for my $caller_pkg ( keys %$EASY_CLOSURES ) {
          easy_closure_category_cleanup( $caller_pkg );
      }
  }
  
  ###########################################
  sub easy_closure_logger_remove {
  ###########################################
      my($class, $logger) = @_;
  
      PKG: for my $caller_pkg ( keys %$EASY_CLOSURES ) {
          for my $entry ( keys %{ $EASY_CLOSURES->{ $caller_pkg } } ) {
              if( $logger == $EASY_CLOSURES->{ $caller_pkg }->{ $entry } ) {
                  easy_closure_category_cleanup( $caller_pkg );
                  next PKG;
              }
          }
      }
  }
  
  ##################################################
  sub remove_logger {
  ##################################################
      my ($class, $logger) = @_;
  
      # Any stealth logger convenience function still using it will
      # now become a no-op.
      Log::Log4perl->easy_closure_logger_remove( $logger );
  
      # Remove the logger from the system
      delete $Log::Log4perl::Logger::LOGGERS_BY_NAME->{ $logger->{category} };
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl - Log4j implementation for Perl
  
  =head1 SYNOPSIS
          # Easy mode if you like it simple ...
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($ERROR);
  
      DEBUG "This doesn't go anywhere";
      ERROR "This gets logged";
  
          # ... or standard mode for more features:
  
      Log::Log4perl::init('/etc/log4perl.conf');
      
      --or--
      
          # Check config every 10 secs
      Log::Log4perl::init_and_watch('/etc/log4perl.conf',10);
  
      --then--
      
      $logger = Log::Log4perl->get_logger('house.bedrm.desk.topdrwr');
      
      $logger->debug('this is a debug message');
      $logger->info('this is an info message');
      $logger->warn('etc');
      $logger->error('..');
      $logger->fatal('..');
      
      #####/etc/log4perl.conf###############################
      log4perl.logger.house              = WARN,  FileAppndr1
      log4perl.logger.house.bedroom.desk = DEBUG, FileAppndr1
      
      log4perl.appender.FileAppndr1      = Log::Log4perl::Appender::File
      log4perl.appender.FileAppndr1.filename = desk.log 
      log4perl.appender.FileAppndr1.layout   = \
                              Log::Log4perl::Layout::SimpleLayout
      ######################################################
  
  =head1 ABSTRACT
  
  Log::Log4perl provides a powerful logging API for your application
  
  =head1 DESCRIPTION
  
  Log::Log4perl lets you remote-control and fine-tune the logging behaviour
  of your system from the outside. It implements the widely popular 
  (Java-based) Log4j logging package in pure Perl. 
  
  B<For a detailed tutorial on Log::Log4perl usage, please read> 
  
  L<http://www.perl.com/pub/a/2002/09/11/log4perl.html>
  
  Logging beats a debugger if you want to know what's going on 
  in your code during runtime. However, traditional logging packages
  are too static and generate a flood of log messages in your log files
  that won't help you.
  
  C<Log::Log4perl> is different. It allows you to control the number of 
  logging messages generated at three different levels:
  
  =over 4
  
  =item *
  
  At a central location in your system (either in a configuration file or
  in the startup code) you specify I<which components> (classes, functions) 
  of your system should generate logs.
  
  =item *
  
  You specify how detailed the logging of these components should be by
  specifying logging I<levels>.
  
  =item *
  
  You also specify which so-called I<appenders> you want to feed your
  log messages to ("Print it to the screen and also append it to /tmp/my.log")
  and which format ("Write the date first, then the file name and line 
  number, and then the log message") they should be in.
  
  =back
  
  This is a very powerful and flexible mechanism. You can turn on and off
  your logs at any time, specify the level of detail and make that
  dependent on the subsystem that's currently executed. 
  
  Let me give you an example: You might 
  find out that your system has a problem in the 
  C<MySystem::Helpers::ScanDir>
  component. Turning on detailed debugging logs all over the system would
  generate a flood of useless log messages and bog your system down beyond
  recognition. With C<Log::Log4perl>, however, you can tell the system:
  "Continue to log only severe errors to the log file. Open a second
  log file, turn on full debug logs in the C<MySystem::Helpers::ScanDir>
  component and dump all messages originating from there into the new
  log file". And all this is possible by just changing the parameters
  in a configuration file, which your system can re-read even 
  while it's running!
  
  =head1 How to use it
  
  The C<Log::Log4perl> package can be initialized in two ways: Either
  via Perl commands or via a C<log4j>-style configuration file.
  
  =head2 Initialize via a configuration file
  
  This is the easiest way to prepare your system for using
  C<Log::Log4perl>. Use a configuration file like this:
  
      ############################################################
      # A simple root logger with a Log::Log4perl::Appender::File 
      # file appender in Perl.
      ############################################################
      log4perl.rootLogger=ERROR, LOGFILE
      
      log4perl.appender.LOGFILE=Log::Log4perl::Appender::File
      log4perl.appender.LOGFILE.filename=/var/log/myerrs.log
      log4perl.appender.LOGFILE.mode=append
      
      log4perl.appender.LOGFILE.layout=PatternLayout
      log4perl.appender.LOGFILE.layout.ConversionPattern=[%r] %F %L %c - %m%n
  
  These lines define your standard logger that's appending severe
  errors to C</var/log/myerrs.log>, using the format
  
      [millisecs] source-filename line-number class - message newline
  
  Assuming that this configuration file is saved as C<log.conf>, you need to 
  read it in the startup section of your code, using the following
  commands:
  
    use Log::Log4perl;
    Log::Log4perl->init("log.conf");
  
  After that's done I<somewhere> in the code, you can retrieve
  logger objects I<anywhere> in the code. Note that
  there's no need to carry any logger references around with your 
  functions and methods. You can get a logger anytime via a singleton
  mechanism:
  
      package My::MegaPackage;
      use  Log::Log4perl;
  
      sub some_method {
          my($param) = @_;
  
          my $log = Log::Log4perl->get_logger("My::MegaPackage");
  
          $log->debug("Debug message");
          $log->info("Info message");
          $log->error("Error message");
  
          ...
      }
  
  With the configuration file above, C<Log::Log4perl> will write
  "Error message" to the specified log file, but won't do anything for 
  the C<debug()> and C<info()> calls, because the log level has been set
  to C<ERROR> for all components in the first line of 
  configuration file shown above.
  
  Why C<Log::Log4perl-E<gt>get_logger> and
  not C<Log::Log4perl-E<gt>new>? We don't want to create a new
  object every time. Usually in OO-Programming, you create an object
  once and use the reference to it to call its methods. However,
  this requires that you pass around the object to all functions
  and the last thing we want is pollute each and every function/method
  we're using with a handle to the C<Logger>:
  
      sub function {  # Brrrr!!
          my($logger, $some, $other, $parameters) = @_;
      }
  
  Instead, if a function/method wants a reference to the logger, it
  just calls the Logger's static C<get_logger($category)> method to obtain
  a reference to the I<one and only> possible logger object of
  a certain category.
  That's called a I<singleton> if you're a Gamma fan.
  
  How does the logger know
  which messages it is supposed to log and which ones to suppress?
  C<Log::Log4perl> works with inheritance: The config file above didn't 
  specify anything about C<My::MegaPackage>. 
  And yet, we've defined a logger of the category 
  C<My::MegaPackage>.
  In this case, C<Log::Log4perl> will walk up the namespace hierarchy
  (C<My> and then we're at the root) to figure out if a log level is
  defined somewhere. In the case above, the log level at the root
  (root I<always> defines a log level, but not necessarily an appender)
  defines that 
  the log level is supposed to be C<ERROR> -- meaning that I<DEBUG>
  and I<INFO> messages are suppressed. Note that this 'inheritance' is
  unrelated to Perl's class inheritance, it is merely related to the
  logger namespace.
  By the way, if you're ever in doubt about what a logger's category is, 
  use C<$logger-E<gt>category()> to retrieve it.
  
  =head2 Log Levels
  
  There are six predefined log levels: C<FATAL>, C<ERROR>, C<WARN>, C<INFO>,
  C<DEBUG>, and C<TRACE> (in descending priority). Your configured logging level
  has to at least match the priority of the logging message.
  
  If your configured logging level is C<WARN>, then messages logged 
  with C<info()>, C<debug()>, and C<trace()> will be suppressed. 
  C<fatal()>, C<error()> and C<warn()> will make their way through,
  because their priority is higher or equal than the configured setting.
  
  Instead of calling the methods
  
      $logger->trace("...");  # Log a trace message
      $logger->debug("...");  # Log a debug message
      $logger->info("...");   # Log a info message
      $logger->warn("...");   # Log a warn message
      $logger->error("...");  # Log a error message
      $logger->fatal("...");  # Log a fatal message
  
  you could also call the C<log()> method with the appropriate level
  using the constants defined in C<Log::Log4perl::Level>:
  
      use Log::Log4perl::Level;
  
      $logger->log($TRACE, "...");
      $logger->log($DEBUG, "...");
      $logger->log($INFO, "...");
      $logger->log($WARN, "...");
      $logger->log($ERROR, "...");
      $logger->log($FATAL, "...");
  
  This form is rarely used, but it comes in handy if you want to log 
  at different levels depending on an exit code of a function:
  
      $logger->log( $exit_level{ $rc }, "...");
  
  As for needing more logging levels than these predefined ones: It's
  usually best to steer your logging behaviour via the category 
  mechanism instead.
  
  If you need to find out if the currently configured logging
  level would allow a logger's logging statement to go through, use the
  logger's C<is_I<level>()> methods:
  
      $logger->is_trace()    # True if trace messages would go through
      $logger->is_debug()    # True if debug messages would go through
      $logger->is_info()     # True if info messages would go through
      $logger->is_warn()     # True if warn messages would go through
      $logger->is_error()    # True if error messages would go through
      $logger->is_fatal()    # True if fatal messages would go through
  
  Example: C<$logger-E<gt>is_warn()> returns true if the logger's current
  level, as derived from either the logger's category (or, in absence of
  that, one of the logger's parent's level setting) is 
  C<$WARN>, C<$ERROR> or C<$FATAL>.
  
  Also available are a series of more Java-esque functions which return
  the same values. These are of the format C<isI<Level>Enabled()>,
  so C<$logger-E<gt>isDebugEnabled()> is synonymous to 
  C<$logger-E<gt>is_debug()>.
  
  
  These level checking functions
  will come in handy later, when we want to block unnecessary
  expensive parameter construction in case the logging level is too
  low to log the statement anyway, like in:
  
      if($logger->is_error()) {
          $logger->error("Erroneous array: @super_long_array");
      }
  
  If we had just written
  
      $logger->error("Erroneous array: @super_long_array");
  
  then Perl would have interpolated
  C<@super_long_array> into the string via an expensive operation
  only to figure out shortly after that the string can be ignored
  entirely because the configured logging level is lower than C<$ERROR>.
  
  The to-be-logged
  message passed to all of the functions described above can
  consist of an arbitrary number of arguments, which the logging functions
  just chain together to a single string. Therefore
  
      $logger->debug("Hello ", "World", "!");  # and
      $logger->debug("Hello World!");
  
  are identical.
  
  Note that even if one of the methods above returns true, it doesn't 
  necessarily mean that the message will actually get logged. 
  What is_debug() checks is that
  the logger used is configured to let a message of the given priority 
  (DEBUG) through. But after this check, Log4perl will eventually apply custom 
  filters and forward the message to one or more appenders. None of this
  gets checked by is_xxx(), for the simple reason that it's 
  impossible to know what a custom filter does with a message without
  having the actual message or what an appender does to a message without
  actually having it log it.
  
  =head2 Log and die or warn
  
  Often, when you croak / carp / warn / die, you want to log those messages.
  Rather than doing the following:
  
      $logger->fatal($err) && die($err);
  
  you can use the following:
  
      $logger->logdie($err);
  
  And if instead of using
  
      warn($message);
      $logger->warn($message);
  
  to both issue a warning via Perl's warn() mechanism and make sure you have
  the same message in the log file as well, use:
  
      $logger->logwarn($message);
  
  Since there is
  an ERROR level between WARN and FATAL, there are two additional helper
  functions in case you'd like to use ERROR for either warn() or die():
  
      $logger->error_warn();
      $logger->error_die();
  
  Finally, there's the Carp functions that, in addition to logging,
  also pass the stringified message to their companions in the Carp package:
  
      $logger->logcarp();        # warn w/ 1-level stack trace
      $logger->logcluck();       # warn w/ full stack trace
      $logger->logcroak();       # die w/ 1-level stack trace
      $logger->logconfess();     # die w/ full stack trace
  
  =head2 Appenders
  
  If you don't define any appenders, nothing will happen. Appenders will
  be triggered whenever the configured logging level requires a message
  to be logged and not suppressed.
  
  C<Log::Log4perl> doesn't define any appenders by default, not even the root
  logger has one.
  
  C<Log::Log4perl> already comes with a standard set of appenders:
  
      Log::Log4perl::Appender::Screen
      Log::Log4perl::Appender::ScreenColoredLevels
      Log::Log4perl::Appender::File
      Log::Log4perl::Appender::Socket
      Log::Log4perl::Appender::DBI
      Log::Log4perl::Appender::Synchronized
      Log::Log4perl::Appender::RRDs
  
  to log to the screen, to files and to databases. 
  
  On CPAN, you can find additional appenders like
  
      Log::Log4perl::Layout::XMLLayout
  
  by Guido Carls E<lt>gcarls@cpan.orgE<gt>.
  It allows for hooking up Log::Log4perl with the graphical Log Analyzer
  Chainsaw (see 
  L<Log::Log4perl::FAQ/"Can I use Log::Log4perl with log4j's Chainsaw?">).
  
  =head2 Additional Appenders via Log::Dispatch
  
  C<Log::Log4perl> also supports I<Dave Rolskys> excellent C<Log::Dispatch>
  framework which implements a wide variety of different appenders. 
  
  Here's the list of appender modules currently available via C<Log::Dispatch>:
  
         Log::Dispatch::ApacheLog
         Log::Dispatch::DBI (by Tatsuhiko Miyagawa)
         Log::Dispatch::Email,
         Log::Dispatch::Email::MailSend,
         Log::Dispatch::Email::MailSendmail,
         Log::Dispatch::Email::MIMELite
         Log::Dispatch::File
         Log::Dispatch::FileRotate (by Mark Pfeiffer)
         Log::Dispatch::Handle
         Log::Dispatch::Screen
         Log::Dispatch::Syslog
         Log::Dispatch::Tk (by Dominique Dumont)
  
  Please note that in order to use any of these additional appenders, you
  have to fetch Log::Dispatch from CPAN and install it. Also the particular
  appender you're using might require installing the particular module.
  
  For additional information on appenders, please check the
  L<Log::Log4perl::Appender> manual page.
  
  =head2 Appender Example
  
  Now let's assume that we want to log C<info()> or
  higher prioritized messages in the C<Foo::Bar> category
  to both STDOUT and to a log file, say C<test.log>.
  In the initialization section of your system,
  just define two appenders using the readily available
  C<Log::Log4perl::Appender::File> and C<Log::Log4perl::Appender::Screen> 
  modules:
  
    use Log::Log4perl;
  
       # Configuration in a string ...
    my $conf = q(
      log4perl.category.Foo.Bar          = INFO, Logfile, Screen
  
      log4perl.appender.Logfile          = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.filename = test.log
      log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = [%r] %F %L %m%n
  
      log4perl.appender.Screen         = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.stderr  = 0
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
    );
  
       # ... passed as a reference to init()
    Log::Log4perl::init( \$conf );
  
  Once the initialization shown above has happened once, typically in
  the startup code of your system, just use the defined logger anywhere in 
  your system:
  
    ##########################
    # ... in some function ...
    ##########################
    my $log = Log::Log4perl::get_logger("Foo::Bar");
  
      # Logs both to STDOUT and to the file test.log
    $log->info("Important Info!");
  
  The C<layout> settings specified in the configuration section define the 
  format in which the
  message is going to be logged by the specified appender. The format shown
  for the file appender is logging not only the message but also the number of
  milliseconds since the program has started (%r), the name of the file
  the call to the logger has happened and the line number there (%F and
  %L), the message itself (%m) and a OS-specific newline character (%n):
  
      [187] ./myscript.pl 27 Important Info!
  
  The
  screen appender above, on the other hand, 
  uses a C<SimpleLayout>, which logs the 
  debug level, a hyphen (-) and the log message:
  
      INFO - Important Info!
  
  For more detailed info on layout formats, see L<Log Layouts>. 
  
  In the configuration sample above, we chose to define a I<category> 
  logger (C<Foo::Bar>).
  This will cause only messages originating from
  this specific category logger to be logged in the defined format
  and locations.
  
  =head2 Logging newlines
  
  There's some controversy between different logging systems as to when and 
  where newlines are supposed to be added to logged messages.
  
  The Log4perl way is that a logging statement I<should not> 
  contain a newline:
  
      $logger->info("Some message");
      $logger->info("Another message");
  
  If this is supposed to end up in a log file like
  
      Some message
      Another message
  
  then an appropriate appender layout like "%m%n" will take care of adding
  a newline at the end of each message to make sure every message is 
  printed on its own line.
  
  Other logging systems, Log::Dispatch in particular, recommend adding the
  newline to the log statement. This doesn't work well, however, if you, say,
  replace your file appender by a database appender, and all of a sudden
  those newlines scattered around the code don't make sense anymore.
  
  Assigning matching layouts to different appenders and leaving newlines
  out of the code solves this problem. If you inherited code that has logging
  statements with newlines and want to make it work with Log4perl, read
  the L<Log::Log4perl::Layout::PatternLayout> documentation on how to 
  accomplish that.
  
  =head2 Configuration files
  
  As shown above, you can define C<Log::Log4perl> loggers both from within
  your Perl code or from configuration files. The latter have the unbeatable
  advantage that you can modify your system's logging behaviour without 
  interfering with the code at all. So even if your code is being run by 
  somebody who's totally oblivious to Perl, they still can adapt the
  module's logging behaviour to their needs.
  
  C<Log::Log4perl> has been designed to understand C<Log4j> configuration
  files -- as used by the original Java implementation. Instead of 
  reiterating the format description in [2], let me just list three
  examples (also derived from [2]), which should also illustrate
  how it works:
  
      log4j.rootLogger=DEBUG, A1
      log4j.appender.A1=org.apache.log4j.ConsoleAppender
      log4j.appender.A1.layout=org.apache.log4j.PatternLayout
      log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %c %x - %m%n
  
  This enables messages of priority C<DEBUG> or higher in the root
  hierarchy and has the system write them to the console. 
  C<ConsoleAppender> is a Java appender, but C<Log::Log4perl> jumps
  through a significant number of hoops internally to map these to their
  corresponding Perl classes, C<Log::Log4perl::Appender::Screen> in this case.
  
  Second example:
  
      log4perl.rootLogger=DEBUG, A1
      log4perl.appender.A1=Log::Log4perl::Appender::Screen
      log4perl.appender.A1.layout=PatternLayout
      log4perl.appender.A1.layout.ConversionPattern=%d %-5p %c - %m%n
      log4perl.logger.com.foo=WARN
  
  This defines two loggers: The root logger and the C<com.foo> logger.
  The root logger is easily triggered by debug-messages, 
  but the C<com.foo> logger makes sure that messages issued within
  the C<Com::Foo> component and below are only forwarded to the appender
  if they're of priority I<warning> or higher. 
  
  Note that the C<com.foo> logger doesn't define an appender. Therefore,
  it will just propagate the message up the hierarchy until the root logger
  picks it up and forwards it to the one and only appender of the root
  category, using the format defined for it.
  
  Third example:
  
      log4j.rootLogger=DEBUG, stdout, R
      log4j.appender.stdout=org.apache.log4j.ConsoleAppender
      log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
      log4j.appender.stdout.layout.ConversionPattern=%5p (%F:%L) - %m%n
      log4j.appender.R=org.apache.log4j.RollingFileAppender
      log4j.appender.R.File=example.log
      log4j.appender.R.layout=org.apache.log4j.PatternLayout
      log4j.appender.R.layout.ConversionPattern=%p %c - %m%n
  
  The root logger defines two appenders here: C<stdout>, which uses 
  C<org.apache.log4j.ConsoleAppender> (ultimately mapped by C<Log::Log4perl>
  to L<Log::Log4perl::Appender::Screen>) to write to the screen. And
  C<R>, a C<org.apache.log4j.RollingFileAppender> 
  (mapped by C<Log::Log4perl> to 
  L<Log::Dispatch::FileRotate> with the C<File> attribute specifying the
  log file.
  
  See L<Log::Log4perl::Config> for more examples and syntax explanations.
  
  =head2 Log Layouts
  
  If the logging engine passes a message to an appender, because it thinks
  it should be logged, the appender doesn't just
  write it out haphazardly. There's ways to tell the appender how to format
  the message and add all sorts of interesting data to it: The date and
  time when the event happened, the file, the line number, the
  debug level of the logger and others.
  
  There's currently two layouts defined in C<Log::Log4perl>: 
  C<Log::Log4perl::Layout::SimpleLayout> and
  C<Log::Log4perl::Layout::PatternLayout>:
  
  =over 4 
  
  =item C<Log::Log4perl::SimpleLayout> 
  
  formats a message in a simple
  way and just prepends it by the debug level and a hyphen:
  C<"$level - $message>, for example C<"FATAL - Can't open password file">.
  
  =item C<Log::Log4perl::Layout::PatternLayout> 
  
  on the other hand is very powerful and 
  allows for a very flexible format in C<printf>-style. The format
  string can contain a number of placeholders which will be
  replaced by the logging engine when it's time to log the message:
  
      %c Category of the logging event.
      %C Fully qualified package (or class) name of the caller
      %d Current date in yyyy/MM/dd hh:mm:ss format
      %F File where the logging event occurred
      %H Hostname (if Sys::Hostname is available)
      %l Fully qualified name of the calling method followed by the
         callers source the file name and line number between 
         parentheses.
      %L Line number within the file where the log statement was issued
      %m The message to be logged
      %m{chomp} The message to be logged, stripped off a trailing newline
      %M Method or function where the logging request was issued
      %n Newline (OS-independent)
      %p Priority of the logging event
      %P pid of the current process
      %r Number of milliseconds elapsed from program start to logging 
         event
      %R Number of milliseconds elapsed from last logging event to
         current logging event 
      %T A stack trace of functions called
      %x The topmost NDC (see below)
      %X{key} The entry 'key' of the MDC (see below)
      %% A literal percent (%) sign
  
  NDC and MDC are explained in L<"Nested Diagnostic Context (NDC)">
  and L<"Mapped Diagnostic Context (MDC)">.
  
  Also, C<%d> can be fine-tuned to display only certain characteristics
  of a date, according to the SimpleDateFormat in the Java World
  (L<http://java.sun.com/j2se/1.3/docs/api/java/text/SimpleDateFormat.html>)
  
  In this way, C<%d{HH:mm}> displays only hours and minutes of the current date,
  while C<%d{yy, EEEE}> displays a two-digit year, followed by a spelled-out
  (like C<Wednesday>). 
  
  Similar options are available for shrinking the displayed category or
  limit file/path components, C<%F{1}> only displays the source file I<name>
  without any path components while C<%F> logs the full path. %c{2} only
  logs the last two components of the current category, C<Foo::Bar::Baz> 
  becomes C<Bar::Baz> and saves space.
  
  If those placeholders aren't enough, then you can define your own right in
  the config file like this:
  
      log4perl.PatternLayout.cspec.U = sub { return "UID $<" }
  
  See L<Log::Log4perl::Layout::PatternLayout> for further details on
  customized specifiers.
  
  Please note that the subroutines you're defining in this way are going
  to be run in the C<main> namespace, so be sure to fully qualify functions
  and variables if they're located in different packages.
  
  SECURITY NOTE: this feature means arbitrary perl code can be embedded in the 
  config file.  In the rare case where the people who have access to your config 
  file are different from the people who write your code and shouldn't have 
  execute rights, you might want to call
  
      Log::Log4perl::Config->allow_code(0);
  
  before you call init(). Alternatively you can supply a restricted set of
  Perl opcodes that can be embedded in the config file as described in
  L<"Restricting what Opcodes can be in a Perl Hook">.
  
  =back
  
  All placeholders are quantifiable, just like in I<printf>. Following this 
  tradition, C<%-20c> will reserve 20 chars for the category and left-justify it.
  
  For more details on logging and how to use the flexible and the simple
  format, check out the original C<log4j> website under
  
  L<SimpleLayout|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/SimpleLayout.html>
  and
  L<PatternLayout|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html>
  
  =head2 Penalties
  
  Logging comes with a price tag. C<Log::Log4perl> has been optimized
  to allow for maximum performance, both with logging enabled and disabled.
  
  But you need to be aware that there's a small hit every time your code
  encounters a log statement -- no matter if logging is enabled or not. 
  C<Log::Log4perl> has been designed to keep this so low that it will
  be unnoticeable to most applications.
  
  Here's a couple of tricks which help C<Log::Log4perl> to avoid
  unnecessary delays:
  
  You can save serious time if you're logging something like
  
          # Expensive in non-debug mode!
      for (@super_long_array) {
          $logger->debug("Element: $_");
      }
  
  and C<@super_long_array> is fairly big, so looping through it is pretty
  expensive. Only you, the programmer, knows that going through that C<for>
  loop can be skipped entirely if the current logging level for the 
  actual component is higher than C<debug>.
  In this case, use this instead:
  
          # Cheap in non-debug mode!
      if($logger->is_debug()) {
          for (@super_long_array) {
              $logger->debug("Element: $_");
          }
      }
  
  If you're afraid that generating the parameters to the
  logging function is fairly expensive, use closures:
  
          # Passed as subroutine ref
      use Data::Dumper;
      $logger->debug(sub { Dumper($data) } );
  
  This won't unravel C<$data> via Dumper() unless it's actually needed
  because it's logged. 
  
  Also, Log::Log4perl lets you specify arguments
  to logger functions in I<message output filter syntax>:
  
      $logger->debug("Structure: ",
                     { filter => \&Dumper,
                       value  => $someref });
  
  In this way, shortly before Log::Log4perl sending the
  message out to any appenders, it will be searching all arguments for
  hash references and treat them in a special way:
  
  It will invoke the function given as a reference with the C<filter> key
  (C<Data::Dumper::Dumper()>) and pass it the value that came with
  the key named C<value> as an argument.
  The anonymous hash in the call above will be replaced by the return 
  value of the filter function.
  
  =head1 Categories
  
  B<Categories are also called "Loggers" in Log4perl, both refer
  to the same thing and these terms are used interchangeably.>
  C<Log::Log4perl> uses I<categories> to determine if a log statement in
  a component should be executed or suppressed at the current logging level.
  Most of the time, these categories are just the classes the log statements
  are located in:
  
      package Candy::Twix;
  
      sub new { 
          my $logger = Log::Log4perl->get_logger("Candy::Twix");
          $logger->debug("Creating a new Twix bar");
          bless {}, shift;
      }
   
      # ...
  
      package Candy::Snickers;
  
      sub new { 
          my $logger = Log::Log4perl->get_logger("Candy.Snickers");
          $logger->debug("Creating a new Snickers bar");
          bless {}, shift;
      }
  
      # ...
  
      package main;
      Log::Log4perl->init("mylogdefs.conf");
  
          # => "LOG> Creating a new Snickers bar"
      my $first = Candy::Snickers->new();
          # => "LOG> Creating a new Twix bar"
      my $second = Candy::Twix->new();
  
  Note that you can separate your category hierarchy levels
  using either dots like
  in Java (.) or double-colons (::) like in Perl. Both notations
  are equivalent and are handled the same way internally.
  
  However, categories are just there to make
  use of inheritance: if you invoke a logger in a sub-category, 
  it will bubble up the hierarchy and call the appropriate appenders.
  Internally, categories are not related to the class hierarchy of the program
  at all -- they're purely virtual. You can use arbitrary categories --
  for example in the following program, which isn't oo-style, but
  procedural:
  
      sub print_portfolio {
  
          my $log = Log::Log4perl->get_logger("user.portfolio");
          $log->debug("Quotes requested: @_");
  
          for(@_) {
              print "$_: ", get_quote($_), "\n";
          }
      }
  
      sub get_quote {
  
          my $log = Log::Log4perl->get_logger("internet.quotesystem");
          $log->debug("Fetching quote: $_[0]");
  
          return yahoo_quote($_[0]);
      }
  
  The logger in first function, C<print_portfolio>, is assigned the
  (virtual) C<user.portfolio> category. Depending on the C<Log4perl>
  configuration, this will either call a C<user.portfolio> appender,
  a C<user> appender, or an appender assigned to root -- without
  C<user.portfolio> having any relevance to the class system used in 
  the program.
  The logger in the second function adheres to the 
  C<internet.quotesystem> category -- again, maybe because it's bundled 
  with other Internet functions, but not because there would be
  a class of this name somewhere.
  
  However, be careful, don't go overboard: if you're developing a system
  in object-oriented style, using the class hierarchy is usually your best
  choice. Think about the people taking over your code one day: The
  class hierarchy is probably what they know right up front, so it's easy
  for them to tune the logging to their needs.
  
  =head2 Turn off a component
  
  C<Log4perl> doesn't only allow you to selectively switch I<on> a category
  of log messages, you can also use the mechanism to selectively I<disable>
  logging in certain components whereas logging is kept turned on in higher-level
  categories. This mechanism comes in handy if you find that while bumping 
  up the logging level of a high-level (i. e. close to root) category, 
  that one component logs more than it should, 
  
  Here's how it works: 
  
      ############################################################
      # Turn off logging in a lower-level category while keeping
      # it active in higher-level categories.
      ############################################################
      log4perl.rootLogger=DEBUG, LOGFILE
      log4perl.logger.deep.down.the.hierarchy = ERROR, LOGFILE
  
      # ... Define appenders ...
  
  This way, log messages issued from within 
  C<Deep::Down::The::Hierarchy> and below will be
  logged only if they're C<ERROR> or worse, while in all other system components
  even C<DEBUG> messages will be logged.
  
  =head2 Return Values
  
  All logging methods return values indicating if their message
  actually reached one or more appenders. If the message has been
  suppressed because of level constraints, C<undef> is returned.
  
  For example,
  
      my $ret = $logger->info("Message");
  
  will return C<undef> if the system debug level for the current category
  is not C<INFO> or more permissive. 
  If Log::Log4perl
  forwarded the message to one or more appenders, the number of appenders
  is returned.
  
  If appenders decide to veto on the message with an appender threshold,
  the log method's return value will have them excluded. This means that if
  you've got one appender holding an appender threshold and you're 
  logging a message
  which passes the system's log level hurdle but not the appender threshold,
  C<0> will be returned by the log function.
  
  The bottom line is: Logging functions will return a I<true> value if the message
  made it through to one or more appenders and a I<false> value if it didn't.
  This allows for constructs like
  
      $logger->fatal("@_") or print STDERR "@_\n";
  
  which will ensure that the fatal message isn't lost
  if the current level is lower than FATAL or printed twice if 
  the level is acceptable but an appender already points to STDERR.
  
  =head2 Pitfalls with Categories
  
  Be careful with just blindly reusing the system's packages as
  categories. If you do, you'll get into trouble with inherited methods.
  Imagine the following class setup:
  
      use Log::Log4perl;
  
      ###########################################
      package Bar;
      ###########################################
      sub new {
          my($class) = @_;
          my $logger = Log::Log4perl::get_logger(__PACKAGE__);
          $logger->debug("Creating instance");
          bless {}, $class;
      }
      ###########################################
      package Bar::Twix;
      ###########################################
      our @ISA = qw(Bar);
  
      ###########################################
      package main;
      ###########################################
      Log::Log4perl->init(\ qq{
      log4perl.category.Bar.Twix = DEBUG, Screen
      log4perl.appender.Screen = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
      });
  
      my $bar = Bar::Twix->new();
  
  C<Bar::Twix> just inherits everything from C<Bar>, including the constructor
  C<new()>.
  Contrary to what you might be thinking at first, this won't log anything. 
  Reason for this is the C<get_logger()> call in package C<Bar>, which
  will always get a logger of the C<Bar> category, even if we call C<new()> via
  the C<Bar::Twix> package, which will make perl go up the inheritance 
  tree to actually execute C<Bar::new()>. Since we've only defined logging
  behaviour for C<Bar::Twix> in the configuration file, nothing will happen.
  
  This can be fixed by changing the C<get_logger()> method in C<Bar::new()>
  to obtain a logger of the category matching the
  I<actual> class of the object, like in
  
          # ... in Bar::new() ...
      my $logger = Log::Log4perl::get_logger( $class );
  
  In a method other than the constructor, the class name of the actual
  object can be obtained by calling C<ref()> on the object reference, so
  
      package BaseClass;
      use Log::Log4perl qw( get_logger );
  
      sub new { 
          bless {}, shift; 
      }
  
      sub method {
          my( $self ) = @_;
  
          get_logger( ref $self )->debug( "message" );
      }
  
      package SubClass;
      our @ISA = qw(BaseClass);
  
  is the recommended pattern to make sure that 
  
      my $sub = SubClass->new();
      $sub->meth();
  
  starts logging if the C<"SubClass"> category 
  (and not the C<"BaseClass"> category has logging enabled at the DEBUG level.
  
  =head2 Initialize once and only once
  
  It's important to realize that Log::Log4perl gets initialized once and only
  once, typically at the start of a program or system. Calling C<init()>
  more than once will cause it to clobber the existing configuration and
  I<replace> it by the new one.
  
  If you're in a traditional CGI environment, where every request is
  handled by a new process, calling C<init()> every time is fine. In
  persistent environments like C<mod_perl>, however, Log::Log4perl
  should be initialized either at system startup time (Apache offers
  startup handlers for that) or via
  
          # Init or skip if already done
      Log::Log4perl->init_once($conf_file);
  
  C<init_once()> is identical to C<init()>, just with the exception
  that it will leave a potentially existing configuration alone and 
  will only call C<init()> if Log::Log4perl hasn't been initialized yet.
  
  If you're just curious if Log::Log4perl has been initialized yet, the
  check
  
      if(Log::Log4perl->initialized()) {
          # Yes, Log::Log4perl has already been initialized
      } else {
          # No, not initialized yet ...
      }
  
  can be used.
  
  If you're afraid that the components of your system are stepping on 
  each other's toes or if you are thinking that different components should
  initialize Log::Log4perl separately, try to consolidate your system
  to use a centralized Log4perl configuration file and use 
  Log4perl's I<categories> to separate your components.
  
  =head2 Custom Filters
  
  Log4perl allows the use of customized filters in its appenders
  to control the output of messages. These filters might grep for
  certain text chunks in a message, verify that its priority
  matches or exceeds a certain level or that this is the 10th
  time the same message has been submitted -- and come to a log/no log 
  decision based upon these circumstantial facts.
  
  Check out L<Log::Log4perl::Filter> for detailed instructions 
  on how to use them.
  
  =head2 Performance
  
  The performance of Log::Log4perl calls obviously depends on a lot of things.
  But to give you a general idea, here's some rough numbers:
  
  On a Pentium 4 Linux box at 2.4 GHz, you'll get through
  
  =over 4
  
  =item *
  
  500,000 suppressed log statements per second
  
  =item *
  
  30,000 logged messages per second (using an in-memory appender)
  
  =item *
  
  init_and_watch delay mode: 300,000 suppressed, 30,000 logged.
  init_and_watch signal mode: 450,000 suppressed, 30,000 logged.
  
  =back
  
  Numbers depend on the complexity of the Log::Log4perl configuration.
  For a more detailed benchmark test, check the C<docs/benchmark.results.txt> 
  document in the Log::Log4perl distribution.
  
  =head1 Cool Tricks
  
  Here's a collection of useful tricks for the advanced C<Log::Log4perl> user.
  For more, check the FAQ, either in the distribution 
  (L<Log::Log4perl::FAQ>) or on L<http://log4perl.sourceforge.net>.
  
  =head2 Shortcuts
  
  When getting an instance of a logger, instead of saying
  
      use Log::Log4perl;
      my $logger = Log::Log4perl->get_logger();
  
  it's often more convenient to import the C<get_logger> method from 
  C<Log::Log4perl> into the current namespace:
  
      use Log::Log4perl qw(get_logger);
      my $logger = get_logger();
  
  Please note this difference: To obtain the root logger, please use
  C<get_logger("")>, call it without parameters (C<get_logger()>), you'll
  get the logger of a category named after the current package. 
  C<get_logger()> is equivalent to C<get_logger(__PACKAGE__)>.
  
  =head2 Alternative initialization
  
  Instead of having C<init()> read in a configuration file by specifying
  a file name or passing it a reference to an open filehandle
  (C<Log::Log4perl-E<gt>init( \*FILE )>),
  you can 
  also pass in a reference to a string, containing the content of
  the file:
  
      Log::Log4perl->init( \$config_text );
  
  Also, if you've got the C<name=value> pairs of the configuration in
  a hash, you can just as well initialize C<Log::Log4perl> with
  a reference to it:
  
      my %key_value_pairs = (
          "log4perl.rootLogger"       => "ERROR, LOGFILE",
          "log4perl.appender.LOGFILE" => "Log::Log4perl::Appender::File",
          ...
      );
  
      Log::Log4perl->init( \%key_value_pairs );
  
  Or also you can use a URL, see below:
  
  =head2 Using LWP to parse URLs
  
  (This section borrowed from XML::DOM::Parser by T.J. Mather).
  
  The init() function now also supports URLs, e.g. I<http://www.erols.com/enno/xsa.xml>.
  It uses LWP to download the file and then calls parse() on the resulting string.
  By default it will use a L<LWP::UserAgent> that is created as follows:
  
   use LWP::UserAgent;
   $LWP_USER_AGENT = LWP::UserAgent->new;
   $LWP_USER_AGENT->env_proxy;
  
  Note that env_proxy reads proxy settings from environment variables, which is what I need to
  do to get thru our firewall. If you want to use a different LWP::UserAgent, you can 
  set it with
  
      Log::Log4perl::Config::set_LWP_UserAgent($my_agent);
  
  Currently, LWP is used when the filename (passed to parsefile) starts with one of
  the following URL schemes: http, https, ftp, wais, gopher, or file (followed by a colon.)
  
  Don't use this feature with init_and_watch().
  
  =head2 Automatic reloading of changed configuration files
  
  Instead of just statically initializing Log::Log4perl via
  
      Log::Log4perl->init($conf_file);
  
  there's a way to have Log::Log4perl periodically check for changes
  in the configuration and reload it if necessary:
  
      Log::Log4perl->init_and_watch($conf_file, $delay);
  
  In this mode, Log::Log4perl will examine the configuration file 
  C<$conf_file> every C<$delay> seconds for changes via the file's
  last modification timestamp. If the file has been updated, it will
  be reloaded and replace the current Log::Log4perl configuration.
  
  The way this works is that with every logger function called 
  (debug(), is_debug(), etc.), Log::Log4perl will check if the delay 
  interval has expired. If so, it will run a -M file check on the 
  configuration file. If its timestamp has been modified, the current
  configuration will be dumped and new content of the file will be
  loaded.
  
  This convenience comes at a price, though: Calling time() with every
  logging function call, especially the ones that are "suppressed" (!), 
  will slow down these Log4perl calls by about 40%.
  
  To alleviate this performance hit a bit, C<init_and_watch()> 
  can be configured to listen for a Unix signal to reload the 
  configuration instead:
  
      Log::Log4perl->init_and_watch($conf_file, 'HUP');
  
  This will set up a signal handler for SIGHUP and reload the configuration
  if the application receives this signal, e.g. via the C<kill> command:
  
      kill -HUP pid
  
  where C<pid> is the process ID of the application. This will bring you back
  to about 85% of Log::Log4perl's normal execution speed for suppressed
  statements. For details, check out L<"Performance">. For more info
  on the signal handler, look for L<Log::Log4perl::Config::Watch/"SIGNAL MODE">.
  
  If you have a somewhat long delay set between physical config file checks
  or don't want to use the signal associated with the config file watcher,
  you can trigger a configuration reload at the next possible time by
  calling C<Log::Log4perl::Config-E<gt>watcher-E<gt>force_next_check()>.
  
  One thing to watch out for: If the configuration file contains a syntax
  or other fatal error, a running application will stop with C<die> if
  this damaged configuration will be loaded during runtime, triggered
  either by a signal or if the delay period expired and the change is 
  detected. This behaviour might change in the future.
  
  To allow the application to intercept and control a configuration reload
  in init_and_watch mode, a callback can be specified:
  
      Log::Log4perl->init_and_watch($conf_file, 10, { 
              preinit_callback => \&callback });
  
  If Log4perl determines that the configuration needs to be reloaded, it will
  call the C<preinit_callback> function without parameters. If the callback
  returns a true value, Log4perl will proceed and reload the configuration.  If
  the callback returns a false value, Log4perl will keep the old configuration
  and skip reloading it until the next time around.  Inside the callback, an
  application can run all kinds of checks, including accessing the configuration
  file, which is available via
  C<Log::Log4perl::Config-E<gt>watcher()-E<gt>file()>.
  
  =head2 Variable Substitution
  
  To avoid having to retype the same expressions over and over again,
  Log::Log4perl's configuration files support simple variable substitution.
  New variables are defined simply by adding
  
      varname = value
  
  lines to the configuration file before using
  
      ${varname}
  
  afterwards to recall the assigned values. Here's an example:
  
      layout_class   = Log::Log4perl::Layout::PatternLayout
      layout_pattern = %d %F{1} %L> %m %n
      
      log4perl.category.Bar.Twix = WARN, Logfile, Screen
  
      log4perl.appender.Logfile  = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.filename = test.log
      log4perl.appender.Logfile.layout = ${layout_class}
      log4perl.appender.Logfile.layout.ConversionPattern = ${layout_pattern}
  
      log4perl.appender.Screen  = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = ${layout_class}
      log4perl.appender.Screen.layout.ConversionPattern = ${layout_pattern}
  
  This is a convenient way to define two appenders with the same layout 
  without having to retype the pattern definitions.
  
  Variable substitution via C<${varname}> 
  will first try to find an explicitly defined 
  variable. If that fails, it will check your shell's environment
  for a variable of that name. If that also fails, the program will C<die()>.
  
  =head2 Perl Hooks in the Configuration File
  
  If some of the values used in the Log4perl configuration file 
  need to be dynamically modified by the program, use Perl hooks:
  
      log4perl.appender.File.filename = \
          sub { return getLogfileName(); }
  
  Each value starting with the string C<sub {...> is interpreted as Perl code to
  be executed at the time the application parses the configuration
  via C<Log::Log4perl::init()>. The return value of the subroutine
  is used by Log::Log4perl as the configuration value.
  
  The Perl code is executed in the C<main> package, functions in
  other packages have to be called in fully-qualified notation.
  
  Here's another example, utilizing an environment variable as a
  username for a DBI appender:
  
      log4perl.appender.DB.username = \
          sub { $ENV{DB_USER_NAME } }
  
  However, please note the difference between these code snippets and those
  used for user-defined conversion specifiers as discussed in
  L<Log::Log4perl::Layout::PatternLayout>: 
  While the snippets above are run I<once>
  when C<Log::Log4perl::init()> is called, the conversion specifier
  snippets are executed I<each time> a message is rendered according to
  the PatternLayout.
  
  SECURITY NOTE: this feature means arbitrary perl code can be embedded in the 
  config file.  In the rare case where the people who have access to your config 
  file are different from the people who write your code and shouldn't have 
  execute rights, you might want to set
  
      Log::Log4perl::Config->allow_code(0);
  
  before you call init().  Alternatively you can supply a restricted set of
  Perl opcodes that can be embedded in the config file as described in
  L<"Restricting what Opcodes can be in a Perl Hook">.
  
  =head2 Restricting what Opcodes can be in a Perl Hook
  
  The value you pass to Log::Log4perl::Config->allow_code() determines whether
  the code that is embedded in the config file is eval'd unrestricted, or
  eval'd in a Safe compartment.  By default, a value of '1' is assumed,
  which does a normal 'eval' without any restrictions. A value of '0' 
  however prevents any embedded code from being evaluated.
  
  If you would like fine-grained control over what can and cannot be included
  in embedded code, then please utilize the following methods:
  
   Log::Log4perl::Config->allow_code( $allow );
   Log::Log4perl::Config->allowed_code_ops($op1, $op2, ... );
   Log::Log4perl::Config->vars_shared_with_safe_compartment( [ \%vars | $package, \@vars ] );
   Log::Log4perl::Config->allowed_code_ops_convenience_map( [ \%map | $name, \@mask ] );
  
  Log::Log4perl::Config-E<gt>allowed_code_ops() takes a list of opcode masks
  that are allowed to run in the compartment.  The opcode masks must be
  specified as described in L<Opcode>:
  
   Log::Log4perl::Config->allowed_code_ops(':subprocess');
  
  This example would allow Perl operations like backticks, system, fork, and
  waitpid to be executed in the compartment.  Of course, you probably don't
  want to use this mask -- it would allow exactly what the Safe compartment is
  designed to prevent.
  
  Log::Log4perl::Config-E<gt>vars_shared_with_safe_compartment() 
  takes the symbols which
  should be exported into the Safe compartment before the code is evaluated. 
  The keys of this hash are the package names that the symbols are in, and the
  values are array references to the literal symbol names.  For convenience,
  the default settings export the '%ENV' hash from the 'main' package into the
  compartment:
  
   Log::Log4perl::Config->vars_shared_with_safe_compartment(
     main => [ '%ENV' ],
   );
  
  Log::Log4perl::Config-E<gt>allowed_code_ops_convenience_map() is an accessor
  method to a map of convenience names to opcode masks. At present, the
  following convenience names are defined:
  
   safe        = [ ':browse' ]
   restrictive = [ ':default' ]
  
  For convenience, if Log::Log4perl::Config-E<gt>allow_code() is called with a
  value which is a key of the map previously defined with
  Log::Log4perl::Config-E<gt>allowed_code_ops_convenience_map(), then the
  allowed opcodes are set according to the value defined in the map. If this
  is confusing, consider the following:
  
   use Log::Log4perl;
   
   my $config = <<'END';
    log4perl.logger = INFO, Main
    log4perl.appender.Main = Log::Log4perl::Appender::File
    log4perl.appender.Main.filename = \
        sub { "example" . getpwuid($<) . ".log" }
    log4perl.appender.Main.layout = Log::Log4perl::Layout::SimpleLayout
   END
   
   $Log::Log4perl::Config->allow_code('restrictive');
   Log::Log4perl->init( \$config );       # will fail
   $Log::Log4perl::Config->allow_code('safe');
   Log::Log4perl->init( \$config );       # will succeed
  
  The reason that the first call to -E<gt>init() fails is because the
  'restrictive' name maps to an opcode mask of ':default'.  getpwuid() is not
  part of ':default', so -E<gt>init() fails.  The 'safe' name maps to an opcode
  mask of ':browse', which allows getpwuid() to run, so -E<gt>init() succeeds.
  
  allowed_code_ops_convenience_map() can be invoked in several ways:
  
  =over 4
  
  =item allowed_code_ops_convenience_map()
  
  Returns the entire convenience name map as a hash reference in scalar
  context or a hash in list context.
  
  =item allowed_code_ops_convenience_map( \%map )
  
  Replaces the entire convenience name map with the supplied hash reference.
  
  =item allowed_code_ops_convenience_map( $name )
  
  Returns the opcode mask for the given convenience name, or undef if no such
  name is defined in the map.
  
  =item allowed_code_ops_convenience_map( $name, \@mask )
  
  Adds the given name/mask pair to the convenience name map.  If the name
  already exists in the map, it's value is replaced with the new mask.
  
  =back
  
  as can vars_shared_with_safe_compartment():
  
  =over 4
  
  =item vars_shared_with_safe_compartment()
  
  Return the entire map of packages to variables as a hash reference in scalar
  context or a hash in list context.
  
  =item vars_shared_with_safe_compartment( \%packages )
  
  Replaces the entire map of packages to variables with the supplied hash
  reference.
  
  =item vars_shared_with_safe_compartment( $package )
  
  Returns the arrayref of variables to be shared for a specific package.
  
  =item vars_shared_with_safe_compartment( $package, \@vars )
  
  Adds the given package / varlist pair to the map.  If the package already
  exists in the map, it's value is replaced with the new arrayref of variable
  names.
  
  =back
  
  For more information on opcodes and Safe Compartments, see L<Opcode> and
  L<Safe>.
  
  =head2 Changing the Log Level on a Logger
  
  Log4perl provides some internal functions for quickly adjusting the
  log level from within a running Perl program. 
  
  Now, some people might
  argue that you should adjust your levels from within an external 
  Log4perl configuration file, but Log4perl is everybody's darling.
  
  Typically run-time adjusting of levels is done
  at the beginning, or in response to some external input (like a
  "more logging" runtime command for diagnostics).
  
  You get the log level from a logger object with:
  
      $current_level = $logger->level();
  
  and you may set it with the same method, provided you first
  imported the log level constants, with:
  
      use Log::Log4perl::Level;
  
  Then you can set the level on a logger to one of the constants,
  
      $logger->level($ERROR); # one of DEBUG, INFO, WARN, ERROR, FATAL
  
  To B<increase> the level of logging currently being done, use:
  
      $logger->more_logging($delta);
  
  and to B<decrease> it, use:
  
      $logger->less_logging($delta);
  
  $delta must be a positive integer (for now, we may fix this later ;).
  
  There are also two equivalent functions:
  
      $logger->inc_level($delta);
      $logger->dec_level($delta);
  
  They're included to allow you a choice in readability. Some folks
  will prefer more/less_logging, as they're fairly clear in what they
  do, and allow the programmer not to worry too much about what a Level
  is and whether a higher Level means more or less logging. However,
  other folks who do understand and have lots of code that deals with
  levels will probably prefer the inc_level() and dec_level() methods as
  they want to work with Levels and not worry about whether that means
  more or less logging. :)
  
  That diatribe aside, typically you'll use more_logging() or inc_level()
  as such:
  
      my $v = 0; # default level of verbosity.
      
      GetOptions("v+" => \$v, ...);
  
      if( $v ) {
        $logger->more_logging($v); # inc logging level once for each -v in ARGV
      }
  
  =head2 Custom Log Levels
  
  First off, let me tell you that creating custom levels is heavily
  deprecated by the log4j folks. Indeed, instead of creating additional
  levels on top of the predefined DEBUG, INFO, WARN, ERROR and FATAL, 
  you should use categories to control the amount of logging smartly,
  based on the location of the log-active code in the system.
  
  Nevertheless, 
  Log4perl provides a nice way to create custom levels via the 
  create_custom_level() routine function. However, this must be done
  before the first call to init() or get_logger(). Say you want to create
  a NOTIFY logging level that comes after WARN (and thus before INFO).
  You'd do such as follows:
  
      use Log::Log4perl;
      use Log::Log4perl::Level;
  
      Log::Log4perl::Logger::create_custom_level("NOTIFY", "WARN");
  
  And that's it! create_custom_level() creates the following functions /
  variables for level FOO:
  
      $FOO_INT        # integer to use in L4p::Level::to_level()
      $logger->foo()  # log function to log if level = FOO
      $logger->is_foo()   # true if current level is >= FOO
  
  These levels can also be used in your
  config file, but note that your config file probably won't be
  portable to another log4perl or log4j environment unless you've
  made the appropriate mods there too.
  
  Since Log4perl translates log levels to syslog and Log::Dispatch if 
  their appenders are used, you may add mappings for custom levels as well:
  
    Log::Log4perl::Level::add_priority("NOTIFY", "WARN",
                                       $syslog_equiv, $log_dispatch_level);
  
  For example, if your new custom "NOTIFY" level is supposed to map 
  to syslog level 2 ("LOG_NOTICE") and Log::Dispatch level 2 ("notice"), use:
  
    Log::Log4perl::Logger::create_custom_level("NOTIFY", "WARN", 2, 2);
  
  =head2 System-wide log levels
  
  As a fairly drastic measure to decrease (or increase) the logging level
  all over the system with one single configuration option, use the C<threshold>
  keyword in the Log4perl configuration file:
  
      log4perl.threshold = ERROR
  
  sets the system-wide (or hierarchy-wide according to the log4j documentation)
  to ERROR and therefore deprives every logger in the system of the right 
  to log lower-prio messages.
  
  =head2 Easy Mode
  
  For teaching purposes (especially for [1]), I've put C<:easy> mode into 
  C<Log::Log4perl>, which just initializes a single root logger with a 
  defined priority and a screen appender including some nice standard layout:
  
      ### Initialization Section
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($ERROR);  # Set priority of root logger to ERROR
  
      ### Application Section
      my $logger = get_logger();
      $logger->fatal("This will get logged.");
      $logger->debug("This won't.");
  
  This will dump something like
  
      2002/08/04 11:43:09 ERROR> script.pl:16 main::function - This will get logged.
  
  to the screen. While this has been proven to work well familiarizing people
  with C<Log::Logperl> slowly, effectively avoiding to clobber them over the 
  head with a 
  plethora of different knobs to fiddle with (categories, appenders, levels, 
  layout), the overall mission of C<Log::Log4perl> is to let people use
  categories right from the start to get used to the concept. So, let's keep
  this one fairly hidden in the man page (congrats on reading this far :).
  
  =head2 Stealth loggers
  
  Sometimes, people are lazy. If you're whipping up a 50-line script and want 
  the comfort of Log::Log4perl without having the burden of carrying a
  separate log4perl.conf file or a 5-liner defining that you want to append
  your log statements to a file, you can use the following features:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init( { level   => $DEBUG,
                                  file    => ">>test.log" } );
  
          # Logs to test.log via stealth logger
      DEBUG("Debug this!");
      INFO("Info this!");
      WARN("Warn this!");
      ERROR("Error this!");
  
      some_function();
  
      sub some_function {
              # Same here
          FATAL("Fatal this!");
      }
  
  In C<:easy> mode, C<Log::Log4perl> will instantiate a I<stealth logger>
  and introduce the
  convenience functions C<TRACE>, C<DEBUG()>, C<INFO()>, C<WARN()>, 
  C<ERROR()>, C<FATAL()>, and C<ALWAYS> into the package namespace.
  These functions simply take messages as
  arguments and forward them to the stealth loggers methods (C<debug()>,
  C<info()>, and so on).
  
  If a message should never be blocked, regardless of the log level,
  use the C<ALWAYS> function which corresponds to a log level of C<OFF>:
  
      ALWAYS "This will be printed regardless of the log level";
  
  The C<easy_init> method can be called with a single level value to
  create a STDERR appender and a root logger as in
  
      Log::Log4perl->easy_init($DEBUG);
  
  or, as shown below (and in the example above) 
  with a reference to a hash, specifying values
  for C<level> (the logger's priority), C<file> (the appender's data sink),
  C<category> (the logger's category and C<layout> for the appender's 
  pattern layout specification.
  All key-value pairs are optional, they 
  default to C<$DEBUG> for C<level>, C<STDERR> for C<file>,
  C<""> (root category) for C<category> and 
  C<%d %m%n> for C<layout>:
  
      Log::Log4perl->easy_init( { level    => $DEBUG,
                                  file     => ">test.log",
                                  utf8     => 1,
                                  category => "Bar::Twix",
                                  layout   => '%F{1}-%L-%M: %m%n' } );
  
  The C<file> parameter takes file names preceded by C<"E<gt>">
  (overwrite) and C<"E<gt>E<gt>"> (append) as arguments. This will
  cause C<Log::Log4perl::Appender::File> appenders to be created behind
  the scenes. Also the keywords C<STDOUT> and C<STDERR> (no C<E<gt>> or
  C<E<gt>E<gt>>) are recognized, which will utilize and configure
  C<Log::Log4perl::Appender::Screen> appropriately. The C<utf8> flag,
  if set to a true value, runs a C<binmode> command on the file handle
  to establish a utf8 line discipline on the file, otherwise you'll get a
  'wide character in print' warning message and probably not what you'd
  expect as output.
  
  The stealth loggers can be used in different packages, you just need to make
  sure you're calling the "use" function in every package you're using
  C<Log::Log4perl>'s easy services:
  
      package Bar::Twix;
      use Log::Log4perl qw(:easy);
      sub eat { DEBUG("Twix mjam"); }
  
      package Bar::Mars;
      use Log::Log4perl qw(:easy);
      sub eat { INFO("Mars mjam"); }
  
      package main;
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init( { level    => $DEBUG,
                                  file     => ">>test.log",
                                  category => "Bar::Twix",
                                  layout   => '%F{1}-%L-%M: %m%n' },
                                { level    => $DEBUG,
                                  file     => "STDOUT",
                                  category => "Bar::Mars",
                                  layout   => '%m%n' },
                              );
      Bar::Twix::eat();
      Bar::Mars::eat();
  
  As shown above, C<easy_init()> will take any number of different logger 
  definitions as hash references.
  
  Also, stealth loggers feature the functions C<LOGWARN()>, C<LOGDIE()>,
  and C<LOGEXIT()>,
  combining a logging request with a subsequent Perl warn() or die() or exit()
  statement. So, for example
  
      if($all_is_lost) {
          LOGDIE("Terrible Problem");
      }
  
  will log the message if the package's logger is at least C<FATAL> but
  C<die()> (including the traditional output to STDERR) in any case afterwards.
  
  See L<"Log and die or warn"> for the similar C<logdie()> and C<logwarn()>
  functions of regular (i.e non-stealth) loggers.
  
  Similarily, C<LOGCARP()>, C<LOGCLUCK()>, C<LOGCROAK()>, and C<LOGCONFESS()>
  are provided in C<:easy> mode, facilitating the use of C<logcarp()>,
  C<logcluck()>, C<logcroak()>, and C<logconfess()> with stealth loggers.
  
  B<When using Log::Log4perl in easy mode, 
  please make sure you understand the implications of 
  L</"Pitfalls with Categories">>.
  
  By the way, these convenience functions perform exactly as fast as the 
  standard Log::Log4perl logger methods, there's I<no> performance penalty
  whatsoever.
  
  =head2 Nested Diagnostic Context (NDC)
  
  If you find that your application could use a global (thread-specific)
  data stack which your loggers throughout the system have easy access to,
  use Nested Diagnostic Contexts (NDCs). Also check out
  L<"Mapped Diagnostic Context (MDC)">, this might turn out to be even more
  useful.
  
  For example, when handling a request of a web client, it's probably 
  useful to have the user's IP address available in all log statements
  within code dealing with this particular request. Instead of passing
  this piece of data around between your application functions, you can just
  use the global (but thread-specific) NDC mechanism. It allows you
  to push data pieces (scalars usually) onto its stack via
  
      Log::Log4perl::NDC->push("San");
      Log::Log4perl::NDC->push("Francisco");
  
  and have your loggers retrieve them again via the "%x" placeholder in
  the PatternLayout. With the stack values above and a PatternLayout format
  like "%x %m%n", the call
  
      $logger->debug("rocks");
  
  will end up as 
  
      San Francisco rocks
  
  in the log appender.
  
  The stack mechanism allows for nested structures.
  Just make sure that at the end of the request, you either decrease the stack
  one by one by calling
  
      Log::Log4perl::NDC->pop();
      Log::Log4perl::NDC->pop();
  
  or clear out the entire NDC stack by calling
  
      Log::Log4perl::NDC->remove();
  
  Even if you should forget to do that, C<Log::Log4perl> won't grow the stack
  indefinitely, but limit it to a maximum, defined in C<Log::Log4perl::NDC>
  (currently 5). A call to C<push()> on a full stack will just replace
  the topmost element by the new value.
  
  Again, the stack is always available via the "%x" placeholder
  in the Log::Log4perl::Layout::PatternLayout class whenever a logger
  fires. It will replace "%x" by the blank-separated list of the
  values on the stack. It does that by just calling
  
      Log::Log4perl::NDC->get();
  
  internally. See details on how this standard log4j feature is implemented
  in L<Log::Log4perl::NDC>.
  
  =head2 Mapped Diagnostic Context (MDC)
  
  Just like the previously discussed NDC stores thread-specific
  information in a stack structure, the MDC implements a hash table
  to store key/value pairs in.
  
  The static method
  
      Log::Log4perl::MDC->put($key, $value);
  
  stores C<$value> under a key C<$key>, with which it can be retrieved later
  (possibly in a totally different part of the system) by calling
  the C<get> method:
  
      my $value = Log::Log4perl::MDC->get($key);
  
  If no value has been stored previously under C<$key>, the C<get> method
  will return C<undef>.
  
  Typically, MDC values are retrieved later on via the C<"%X{...}"> placeholder
  in C<Log::Log4perl::Layout::PatternLayout>. If the C<get()> method
  returns C<undef>, the placeholder will expand to the string C<[undef]>.
  
  An application taking a web request might store the remote host
  like
  
      Log::Log4perl::MDC->put("remote_host", $r->headers("HOST"));
  
  at its beginning and if the appender's layout looks something like
  
      log4perl.appender.Logfile.layout.ConversionPattern = %X{remote_host}: %m%n
  
  then a log statement like
  
     DEBUG("Content delivered");
  
  will log something like
  
     adsl-63.dsl.snf.pacbell.net: Content delivered 
  
  later on in the program.
  
  For details, please check L<Log::Log4perl::MDC>.
  
  =head2 Resurrecting hidden Log4perl Statements
  
  Sometimes scripts need to be deployed in environments without having
  Log::Log4perl installed yet. On the other hand, you don't want to
  live without your Log4perl statements -- they're gonna come in
  handy later.
  
  So, just deploy your script with Log4perl statements commented out with the
  pattern C<###l4p>, like in
  
      ###l4p DEBUG "It works!";
      # ...
      ###l4p INFO "Really!";
  
  If Log::Log4perl is available,
  use the C<:resurrect> tag to have Log4perl resurrect those buried 
  statements before the script starts running:
  
      use Log::Log4perl qw(:resurrect :easy);
  
      ###l4p Log::Log4perl->easy_init($DEBUG);
      ###l4p DEBUG "It works!";
      # ...
      ###l4p INFO "Really!";
  
  This will have a source filter kick in and indeed print
  
      2004/11/18 22:08:46 It works!
      2004/11/18 22:08:46 Really!
  
  In environments lacking Log::Log4perl, just comment out the first line
  and the script will run nevertheless (but of course without logging):
  
      # use Log::Log4perl qw(:resurrect :easy);
  
      ###l4p Log::Log4perl->easy_init($DEBUG);
      ###l4p DEBUG "It works!";
      # ...
      ###l4p INFO "Really!";
  
  because everything's a regular comment now. Alternatively, put the
  magic Log::Log4perl comment resurrection line into your shell's 
  PERL5OPT environment variable, e.g. for bash:
  
      set PERL5OPT=-MLog::Log4perl=:resurrect,:easy
      export PERL5OPT
  
  This will awaken the giant within an otherwise silent script like
  the following:
  
      #!/usr/bin/perl
  
      ###l4p Log::Log4perl->easy_init($DEBUG);
      ###l4p DEBUG "It works!";
  
  As of C<Log::Log4perl> 1.12, you can even force I<all> modules
  loaded by a script to have their hidden Log4perl statements
  resurrected. For this to happen, load C<Log::Log4perl::Resurrector>
  I<before> loading any modules:
  
      use Log::Log4perl qw(:easy);
      use Log::Log4perl::Resurrector;
  
      use Foobar; # All hidden Log4perl statements in here will
                  # be uncommented before Foobar gets loaded.
  
      Log::Log4perl->easy_init($DEBUG);
      ...
  
  Check the C<Log::Log4perl::Resurrector> manpage for more details.
  
  =head2 Access defined appenders
  
  All appenders defined in the configuration file or via Perl code
  can be retrieved by the C<appender_by_name()> class method. This comes
  in handy if you want to manipulate or query appender properties after
  the Log4perl configuration has been loaded via C<init()>.
  
  Note that internally, Log::Log4perl uses the C<Log::Log4perl::Appender> 
  wrapper class to control the real appenders (like 
  C<Log::Log4perl::Appender::File> or C<Log::Dispatch::FileRotate>). 
  The C<Log::Log4perl::Appender> class has an C<appender> attribute,
  pointing to the real appender.
  
  The reason for this is that external appenders like 
  C<Log::Dispatch::FileRotate> don't support all of Log::Log4perl's 
  appender control mechanisms (like appender thresholds).
  
  The previously mentioned method C<appender_by_name()> returns a
  reference to the I<real> appender object. If you want access to the
  wrapper class (e.g. if you want to modify the appender's threshold),
  use the hash C<$Log::Log4perl::Logger::APPENDER_BY_NAME{...}> instead,
  which holds references to all appender wrapper objects.
  
  =head2 Modify appender thresholds
  
  To set an appender's threshold, use its C<threshold()> method:
  
      $app->threshold( $FATAL );
  
  To conveniently adjust I<all> appender thresholds (e.g. because a script
  uses more_logging()), use
  
         # decrease thresholds of all appenders
      Log::Log4perl->appender_thresholds_adjust(-1);
  
  This will decrease the thresholds of all appenders in the system by
  one level, i.e. WARN becomes INFO, INFO becomes DEBUG, etc. To only modify 
  selected ones, use
  
         # decrease thresholds of all appenders
      Log::Log4perl->appender_thresholds_adjust(-1, ['AppName1', ...]);
  
  and pass the names of affected appenders in a ref to an array.
  
  =head1 Advanced configuration within Perl
  
  Initializing Log::Log4perl can certainly also be done from within Perl.
  At last, this is what C<Log::Log4perl::Config> does behind the scenes.
  Log::Log4perl's configuration file parsers are using a publically 
  available API to set up Log::Log4perl's categories, appenders and layouts.
  
  Here's an example on how to configure two appenders with the same layout
  in Perl, without using a configuration file at all:
  
    ########################
    # Initialization section
    ########################
    use Log::Log4perl;
    use Log::Log4perl::Layout;
    use Log::Log4perl::Level;
  
       # Define a category logger
    my $log = Log::Log4perl->get_logger("Foo::Bar");
  
       # Define a layout
    my $layout = Log::Log4perl::Layout::PatternLayout->new("[%r] %F %L %m%n");
  
       # Define a file appender
    my $file_appender = Log::Log4perl::Appender->new(
                            "Log::Log4perl::Appender::File",
                            name      => "filelog",
                            filename  => "/tmp/my.log");
  
       # Define a stdout appender
    my $stdout_appender =  Log::Log4perl::Appender->new(
                            "Log::Log4perl::Appender::Screen",
                            name      => "screenlog",
                            stderr    => 0);
  
       # Have both appenders use the same layout (could be different)
    $stdout_appender->layout($layout);
    $file_appender->layout($layout);
  
    $log->add_appender($stdout_appender);
    $log->add_appender($file_appender);
    $log->level($INFO);
  
  Please note the class of the appender object is passed as a I<string> to
  C<Log::Log4perl::Appender> in the I<first> argument. Behind the scenes,
  C<Log::Log4perl::Appender> will create the necessary
  C<Log::Log4perl::Appender::*> (or C<Log::Dispatch::*>) object and pass
  along the name value pairs we provided to
  C<Log::Log4perl::Appender-E<gt>new()> after the first argument.
  
  The C<name> value is optional and if you don't provide one,
  C<Log::Log4perl::Appender-E<gt>new()> will create a unique one for you.
  The names and values of additional parameters are dependent on the requirements
  of the particular appender class and can be looked up in their
  manual pages.
  
  A side note: In case you're wondering if
  C<Log::Log4perl::Appender-E<gt>new()> will also take care of the
  C<min_level> argument to the C<Log::Dispatch::*> constructors called
  behind the scenes -- yes, it does. This is because we want the
  C<Log::Dispatch> objects to blindly log everything we send them
  (C<debug> is their lowest setting) because I<we> in C<Log::Log4perl>
  want to call the shots and decide on when and what to log.
  
  The call to the appender's I<layout()> method specifies the format (as a
  previously created C<Log::Log4perl::Layout::PatternLayout> object) in which the
  message is being logged in the specified appender. 
  If you don't specify a layout, the logger will fall back to
  C<Log::Log4perl::SimpleLayout>, which logs the debug level, a hyphen (-)
  and the log message.
  
  Layouts are objects, here's how you create them:
  
          # Create a simple layout
      my $simple = Log::Log4perl::SimpleLayout();
  
          # create a flexible layout:
          # ("yyyy/MM/dd hh:mm:ss (file:lineno)> message\n")
      my $pattern = Log::Log4perl::Layout::PatternLayout("%d (%F:%L)> %m%n");
  
  Every appender has exactly one layout assigned to it. You assign
  the layout to the appender using the appender's C<layout()> object:
  
      my $app =  Log::Log4perl::Appender->new(
                    "Log::Log4perl::Appender::Screen",
                    name      => "screenlog",
                    stderr    => 0);
  
          # Assign the previously defined flexible layout
      $app->layout($pattern);
  
          # Add the appender to a previously defined logger
      $logger->add_appender($app);
  
          # ... and you're good to go!
      $logger->debug("Blah");
          # => "2002/07/10 23:55:35 (test.pl:207)> Blah\n"
  
  It's also possible to remove appenders from a logger:
  
      $logger->remove_appender($appender_name);
  
  will remove an appender, specified by name, from a given logger. 
  Please note that this does
  I<not> remove an appender from the system.
  
  To eradicate an appender from the system, 
  you need to call C<Log::Log4perl-E<gt>eradicate_appender($appender_name)>
  which will first remove the appender from every logger in the system
  and then will delete all references Log4perl holds to it.
  
  To remove a logger from the system, use 
  C<Log::Log4perl-E<gt>remove_logger($logger)>. After the remaining 
  reference C<$logger> goes away, the logger will self-destruct. If the
  logger in question is a stealth logger, all of its convenience shortcuts
  (DEBUG, INFO, etc) will turn into no-ops.
  
  =head1 How about Log::Dispatch::Config?
  
  Tatsuhiko Miyagawa's C<Log::Dispatch::Config> is a very clever 
  simplified logger implementation, covering some of the I<log4j>
  functionality. Among the things that 
  C<Log::Log4perl> can but C<Log::Dispatch::Config> can't are:
  
  =over 4
  
  =item *
  
  You can't assign categories to loggers. For small systems that's fine,
  but if you can't turn off and on detailed logging in only a tiny
  subsystem of your environment, you're missing out on a majorly
  useful log4j feature.
  
  =item *
  
  Defining appender thresholds. Important if you want to solve problems like
  "log all messages of level FATAL to STDERR, plus log all DEBUG
  messages in C<Foo::Bar> to a log file". If you don't have appenders
  thresholds, there's no way to prevent cluttering STDERR with DEBUG messages.
  
  =item *
  
  PatternLayout specifications in accordance with the standard
  (e.g. "%d{HH:mm}").
  
  =back
  
  Bottom line: Log::Dispatch::Config is fine for small systems with
  simple logging requirements. However, if you're
  designing a system with lots of subsystems which you need to control
  independently, you'll love the features of C<Log::Log4perl>,
  which is equally easy to use.
  
  =head1 Using Log::Log4perl with wrapper functions and classes
  
  If you don't use C<Log::Log4perl> as described above, 
  but from a wrapper function, the pattern layout will generate wrong data 
  for %F, %C, %L, and the like. Reason for this is that C<Log::Log4perl>'s 
  loggers assume a static caller depth to the application that's using them. 
  
  If you're using
  one (or more) wrapper functions, C<Log::Log4perl> will indicate where
  your logger function called the loggers, not where your application
  called your wrapper:
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init({ level => $DEBUG, 
                                 layout => "%M %m%n" });
  
      sub mylog {
          my($message) = @_;
  
          DEBUG $message;
      }
  
      sub func {
          mylog "Hello";
      }
  
      func();
  
  prints
  
      main::mylog Hello
  
  but that's probably not what your application expects. Rather, you'd
  want
  
      main::func Hello
  
  because the C<func> function called your logging function.
  
  But don't despair, there's a solution: Just register your wrapper
  package with Log4perl beforehand. If Log4perl then finds that it's being 
  called from a registered wrapper, it will automatically step up to the
  next call frame.
  
      Log::Log4perl->wrapper_register(__PACKAGE__);
  
      sub mylog {
          my($message) = @_;
  
          DEBUG $message;
      }
  
  Alternatively, you can increase the value of the global variable
  C<$Log::Log4perl::caller_depth> (defaults to 0) by one for every
  wrapper that's in between your application and C<Log::Log4perl>,
  then C<Log::Log4perl> will compensate for the difference:
  
      sub mylog {
          my($message) = @_;
  
          local $Log::Log4perl::caller_depth =
                $Log::Log4perl::caller_depth + 1;
          DEBUG $message;
      }
  
  Also, note that if you're writing a subclass of Log4perl, like
  
      package MyL4pWrapper;
      use Log::Log4perl;
      our @ISA = qw(Log::Log4perl);
  
  and you want to call get_logger() in your code, like
  
      use MyL4pWrapper;
  
      sub get_logger {
          my $logger = Log::Log4perl->get_logger();
      }
  
  then the get_logger() call will get a logger for the C<MyL4pWrapper>
  category, not for the package calling the wrapper class as in
  
      package UserPackage;
      my $logger = MyL4pWrapper->get_logger();
  
  To have the above call to get_logger return a logger for the 
  "UserPackage" category, you need to tell Log4perl that "MyL4pWrapper"
  is a Log4perl wrapper class:
  
      use MyL4pWrapper;
      Log::Log4perl->wrapper_register(__PACKAGE__);
  
      sub get_logger {
            # Now gets a logger for the category of the calling package
          my $logger = Log::Log4perl->get_logger();
      }
  
  This feature works both for Log4perl-relaying classes like the wrapper
  described above, and for wrappers that inherit from Log4perl use Log4perl's
  get_logger function via inheritance, alike.
  
  =head1 Access to Internals
  
  The following methods are only of use if you want to peek/poke in
  the internals of Log::Log4perl. Be careful not to disrupt its
  inner workings.
  
  =over 4
  
  =item C<< Log::Log4perl->appenders() >>
  
  To find out which appenders are currently defined (not only
  for a particular logger, but overall), a C<appenders()>
  method is available to return a reference to a hash mapping appender
  names to their Log::Log4perl::Appender object references.
  
  =back
  
  =head1 Dirty Tricks
  
  =over 4
  
  =item infiltrate_lwp()
  
  The famous LWP::UserAgent module isn't Log::Log4perl-enabled. Often, though,
  especially when tracing Web-related problems, it would be helpful to get
  some insight on what's happening inside LWP::UserAgent. Ideally, LWP::UserAgent
  would even play along in the Log::Log4perl framework.
  
  A call to C<Log::Log4perl-E<gt>infiltrate_lwp()> does exactly this. 
  In a very rude way, it pulls the rug from under LWP::UserAgent and transforms
  its C<debug/conn> messages into C<debug()> calls of loggers of the category
  C<"LWP::UserAgent">. Similarily, C<LWP::UserAgent>'s C<trace> messages 
  are turned into C<Log::Log4perl>'s C<info()> method calls. Note that this
  only works for LWP::UserAgent versions E<lt> 5.822, because this (and
  probably later) versions miss debugging functions entirely.
  
  =item Suppressing 'duplicate' LOGDIE messages
  
  If a script with a simple Log4perl configuration uses logdie() to catch
  errors and stop processing, as in 
  
      use Log::Log4perl qw(:easy) ;
      Log::Log4perl->easy_init($DEBUG);
      
      shaky_function() or LOGDIE "It failed!";
  
  there's a cosmetic problem: The message gets printed twice:
  
      2005/07/10 18:37:14 It failed!
      It failed! at ./t line 12
  
  The obvious solution is to use LOGEXIT() instead of LOGDIE(), but there's
  also a special tag for Log4perl that suppresses the second message:
  
      use Log::Log4perl qw(:no_extra_logdie_message);
  
  This causes logdie() and logcroak() to call exit() instead of die(). To
  modify the script exit code in these occasions, set the variable
  C<$Log::Log4perl::LOGEXIT_CODE> to the desired value, the default is 1.
  
  =item Redefine values without causing errors
  
  Log4perl's configuration file parser has a few basic safety mechanisms to 
  make sure configurations are more or less sane. 
  
  One of these safety measures is catching redefined values. For example, if
  you first write
  
      log4perl.category = WARN, Logfile
  
  and then a couple of lines later
  
      log4perl.category = TRACE, Logfile
  
  then you might have unintentionally overwritten the first value and Log4perl
  will die on this with an error (suspicious configurations always throw an
  error). Now, there's a chance that this is intentional, for example when
  you're lumping together several configuration files and actually I<want>
  the first value to overwrite the second. In this case use
  
      use Log::Log4perl qw(:nostrict);
  
  to put Log4perl in a more permissive mode.
  
  =item Prevent croak/confess from stringifying
  
  The logcroak/logconfess functions stringify their arguments before
  they pass them to Carp's croak/confess functions. This can get in the
  way if you want to throw an object or a hashref as an exception, in
  this case use:
  
      $Log::Log4perl::STRINGIFY_DIE_MESSAGE = 0;
  
      eval {
            # throws { foo => "bar" }
            # without stringification
          $logger->logcroak( { foo => "bar" } );
      };
  
  =back
  
  =head1 EXAMPLE
  
  A simple example to cut-and-paste and get started:
  
      use Log::Log4perl qw(get_logger);
      
      my $conf = q(
      log4perl.category.Bar.Twix         = WARN, Logfile
      log4perl.appender.Logfile          = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.filename = test.log
      log4perl.appender.Logfile.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = %d %F{1} %L> %m %n
      );
      
      Log::Log4perl::init(\$conf);
      
      my $logger = get_logger("Bar::Twix");
      $logger->error("Blah");
  
  This will log something like
  
      2002/09/19 23:48:15 t1 25> Blah 
  
  to the log file C<test.log>, which Log4perl will append to or 
  create it if it doesn't exist already.
  
  =head1 INSTALLATION
  
  If you want to use external appenders provided with C<Log::Dispatch>,
  you need to install C<Log::Dispatch> (2.00 or better) from CPAN,
  which itself depends on C<Attribute-Handlers> and
  C<Params-Validate>. And a lot of other modules, that's the reason
  why we're now shipping Log::Log4perl with its own standard appenders
  and only if you wish to use additional ones, you'll have to go through
  the C<Log::Dispatch> installation process.
  
  Log::Log4perl needs C<Test::More>, C<Test::Harness> and C<File::Spec>, 
  but they already come with fairly recent versions of perl.
  If not, everything's automatically fetched from CPAN if you're using the CPAN 
  shell (CPAN.pm), because they're listed as dependencies.
  
  C<Time::HiRes> (1.20 or better) is required only if you need the
  fine-grained time stamps of the C<%r> parameter in
  C<Log::Log4perl::Layout::PatternLayout>.
  
  Manual installation works as usual with
  
      perl Makefile.PL
      make
      make test
      make install
  
  =head1 DEVELOPMENT
  
  Log::Log4perl is still being actively developed. We will
  always make sure the test suite (approx. 500 cases) will pass, but there 
  might still be bugs. please check L<http://github.com/mschilli/log4perl>
  for the latest release. The api has reached a mature state, we will 
  not change it unless for a good reason.
  
  Bug reports and feedback are always welcome, just email them to our 
  mailing list shown in the AUTHORS section. We're usually addressing
  them immediately.
  
  =head1 REFERENCES
  
  =over 4
  
  =item [1]
  
  Michael Schilli, "Retire your debugger, log smartly with Log::Log4perl!",
  Tutorial on perl.com, 09/2002, 
  L<http://www.perl.com/pub/a/2002/09/11/log4perl.html>
  
  =item [2]
  
  Ceki Gülcü, "Short introduction to log4j",
  L<http://logging.apache.org/log4j/1.2/manual.html>
  
  =item [3]
  
  Vipan Singla, "Don't Use System.out.println! Use Log4j.",
  L<http://www.vipan.com/htdocs/log4jhelp.html>
  
  =item [4]
  
  The Log::Log4perl project home page: L<http://log4perl.com>
  
  =back
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Config|Log::Log4perl::Config>,
  L<Log::Log4perl::Appender|Log::Log4perl::Appender>,
  L<Log::Log4perl::Layout::PatternLayout|Log::Log4perl::Layout::PatternLayout>,
  L<Log::Log4perl::Layout::SimpleLayout|Log::Log4perl::Layout::SimpleLayout>,
  L<Log::Log4perl::Level|Log::Log4perl::Level>,
  L<Log::Log4perl::JavaMap|Log::Log4perl::JavaMap>
  L<Log::Log4perl::NDC|Log::Log4perl::NDC>,
  
  =head1 AUTHORS
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier, David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
LOG_LOG4PERL

$fatpacked{"Log/Log4perl/Appender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER';
  ##################################################
  package Log::Log4perl::Appender;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl::Config;
  use Log::Log4perl::Level;
  use Carp;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $unique_counter = 0;
  
  ##################################################
  sub reset {
  ##################################################
      $unique_counter = 0;
  }
  
  ##################################################
  sub unique_name {
  ##################################################
          # THREADS: Need to lock here to make it thread safe
      $unique_counter++;
      my $unique_name = sprintf("app%03d", $unique_counter);
          # THREADS: Need to unlock here to make it thread safe
      return $unique_name;
  }
  
  ##################################################
  sub new {
  ##################################################
      my($class, $appenderclass, %params) = @_;
  
          # Pull in the specified Log::Log4perl::Appender object
      eval {
  
             # Eval erroneously succeeds on unknown appender classes if
             # the eval string just consists of valid perl code (e.g. an
             # appended ';' in $appenderclass variable). Fail if we see
             # anything in there that can't be class name.
          die "'$appenderclass' not a valid class name " if 
              $appenderclass =~ /[^:\w]/;
  
          # Check if the class/package is already available because
          # something like Class::Prototyped injected it previously.
  
          # Use UNIVERSAL::can to check the appender's new() method
          # [RT 28987]
          if( ! $appenderclass->can('new') ) {
              # Not available yet, try to pull it in.
              # see 'perldoc -f require' for why two evals
              eval "require $appenderclass";
                   #unless ${$appenderclass.'::IS_LOADED'};  #for unit tests, 
                                                            #see 004Config
              die $@ if $@;
          }
      };
  
      $@ and die "ERROR: can't load appenderclass '$appenderclass'\n$@";
  
      $params{name} = unique_name() unless exists $params{name};
  
      # If it's a Log::Dispatch::File appender, default to append 
      # mode (Log::Dispatch::File defaults to 'clobber') -- consensus 9/2002
      # (Log::Log4perl::Appender::File already defaults to 'append')
      if ($appenderclass eq 'Log::Dispatch::File' &&
          ! exists $params{mode}) {
          $params{mode} = 'append';
      }
  
      my $appender = $appenderclass->new(
              # Set min_level to the lowest setting. *we* are 
              # controlling this now, the appender should just
              # log it with no questions asked.
          min_level => 'debug',
              # Set 'name' and other parameters
          map { $_ => $params{$_} } keys %params,
      );
  
      my $self = {
                   appender  => $appender,
                   name      => $params{name},
                   layout    => undef,
                   level     => $ALL,
                   composite => 0,
                 };
  
          #whether to collapse arrays, etc.
      $self->{warp_message} = $params{warp_message};
      if($self->{warp_message} and
         my $cref = 
         Log::Log4perl::Config::compile_if_perl($self->{warp_message})) {
          $self->{warp_message} = $cref;
      }
      
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub composite { # Set/Get the composite flag
  ##################################################
      my ($self, $flag) = @_;
  
      $self->{composite} = $flag if defined $flag;
      return $self->{composite};
  }
  
  ##################################################
  sub threshold { # Set/Get the appender threshold
  ##################################################
      my ($self, $level) = @_;
  
      print "Setting threshold to $level\n" if _INTERNAL_DEBUG;
  
      if(defined $level) {
          # Checking for \d makes for a faster regex(p)
          $self->{level} = ($level =~ /^(\d+)$/) ? $level :
              # Take advantage of &to_priority's error reporting
              Log::Log4perl::Level::to_priority($level);
      }
  
      return $self->{level};
  }
  
  ##################################################
  sub log { 
  ##################################################
  # Relay this call to Log::Log4perl::Appender:* or
  # Log::Dispatch::*
  ##################################################
      my ($self, $p, $category, $level, $cache) = @_;
  
      # Check if the appender has a last-minute veto in form
      # of an "appender threshold"
      if($self->{level} > $
                          Log::Log4perl::Level::PRIORITY{$level}) {
          print "$self->{level} > $level, aborting\n" if _INTERNAL_DEBUG;
          return undef;
      }
  
      # Run against the (yes only one) customized filter (which in turn
      # might call other filters via the Boolean filter) and check if its
      # ok() method approves the message or blocks it.
      if($self->{filter}) {
          if($self->{filter}->ok(%$p,
                                 log4p_category => $category,
                                 log4p_level    => $level )) {
              print "Filter $self->{filter}->{name} passes\n" if _INTERNAL_DEBUG;
          } else {
              print "Filter $self->{filter}->{name} blocks\n" if _INTERNAL_DEBUG;
              return undef;
          }
      }
  
      unless($self->composite()) {
  
              #not defined, the normal case
          if (! defined $self->{warp_message} ){
                  #join any message elements
              if (ref $p->{message} eq "ARRAY") {
                  for my $i (0..$#{$p->{message}}) {
                      if( !defined $p->{message}->[ $i ] ) {
                          local $Carp::CarpLevel =
                          $Carp::CarpLevel + $Log::Log4perl::caller_depth + 1;
                          carp "Warning: Log message argument #" . 
                               ($i+1) . " undefined";
                      }
                  }
                  $p->{message} = 
                      join($Log::Log4perl::JOIN_MSG_ARRAY_CHAR, 
                           @{$p->{message}} 
                           );
              }
              
              #defined but false, e.g. Appender::DBI
          } elsif (! $self->{warp_message}) {
              ;  #leave the message alone
      
          } elsif (ref($self->{warp_message}) eq "CODE") {
              #defined and a subref
              $p->{message} = 
                  [$self->{warp_message}->(@{$p->{message}})];
          } else {
              #defined and a function name?
              no strict qw(refs);
              $p->{message} = 
                  [$self->{warp_message}->(@{$p->{message}})];
          }
  
          $p->{message} = $self->{layout}->render($p->{message}, 
              $category,
              $level,
              3 + $Log::Log4perl::caller_depth,
          ) if $self->layout();
      }
  
      my $args = [%$p, log4p_category => $category, log4p_level => $level];
  
      if(defined $cache) {
          $$cache = $args;
      } else {
          $self->{appender}->log(@$args);
      }
  
      return 1;
  }
  
  ###########################################
  sub log_cached {
  ###########################################
      my ($self, $cache) = @_;
  
      $self->{appender}->log(@$cache);
  }
  
  ##################################################
  sub name { # Set/Get the name
  ##################################################
      my($self, $name) = @_;
  
          # Somebody wants to *set* the name?
      if($name) {
          $self->{name} = $name;
      }
  
      return $self->{name};
  }
  
  ###########################################
  sub layout { # Set/Get the layout object
               # associated with this appender
  ###########################################
      my($self, $layout) = @_;
  
          # Somebody wants to *set* the layout?
      if($layout) {
          $self->{layout} = $layout;
  
          # somebody wants a layout, but not set yet, so give 'em default
      }elsif (! $self->{layout}) {
          $self->{layout} = Log::Log4perl::Layout::SimpleLayout
                                                  ->new($self->{name});
  
      }
  
      return $self->{layout};
  }
  
  ##################################################
  sub filter { # Set filter
  ##################################################
      my ($self, $filter) = @_;
  
      if($filter) {
          print "Setting filter to $filter->{name}\n" if _INTERNAL_DEBUG;
          $self->{filter} = $filter;
      }
  
      return $self->{filter};
  }
  
  ##################################################
  sub AUTOLOAD { 
  ##################################################
  # Relay everything else to the underlying 
  # Log::Log4perl::Appender::* or Log::Dispatch::*
  #  object
  ##################################################
      my $self = shift;
  
      no strict qw(vars);
  
      $AUTOLOAD =~ s/.*:://;
  
      if(! defined $self->{appender}) {
          die "Can't locate object method $AUTOLOAD() in ", __PACKAGE__;
      }
  
      return $self->{appender}->$AUTOLOAD(@_);
  }
  
  ##################################################
  sub DESTROY {
  ##################################################
      foreach my $key (keys %{$_[0]}) {
          # print "deleting $key\n";
          delete $_[0]->{$key};
      }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender - Log appender class
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
        # Define a logger
    my $logger = Log::Log4perl->get_logger("abc.def.ghi");
  
        # Define a layout
    my $layout = Log::Log4perl::Layout::PatternLayout->new(
                     "%d (%F:%L)> %m");
  
        # Define an appender
    my $appender = Log::Log4perl::Appender->new(
                     "Log::Log4perl::Appender::Screen",
                     name => 'dumpy');
  
        # Set the appender's layout
    $appender->layout($layout);
    $logger->add_appender($appender);
  
  =head1 DESCRIPTION
  
  This class is a wrapper around the C<Log::Log4perl::Appender>
  appender set. 
  
  It also supports the <Log::Dispatch::*> collections of appenders. The
  module hides the idiosyncrasies of C<Log::Dispatch> (e.g. every
  dispatcher gotta have a name, but there's no accessor to retrieve it)
  from C<Log::Log4perl> and yet re-uses the extremely useful variety of
  dispatchers already created and tested in C<Log::Dispatch>.
  
  =head1 FUNCTIONS
  
  =head2 Log::Log4perl::Appender->new($dispatcher_class_name, ...);
  
  The constructor C<new()> takes the name of the appender
  class to be created as a I<string> (!) argument, optionally followed by 
  a number of appender-specific parameters,
  for example:
  
        # Define an appender
    my $appender = Log::Log4perl::Appender->new(
        "Log::Log4perl::Appender::File"
        filename => 'out.log');
  
  In case of C<Log::Dispatch> appenders,
  if no C<name> parameter is specified, the appender object will create
  a unique one (format C<appNNN>), which can be retrieved later via
  the C<name()> method:
  
    print "The appender's name is ", $appender->name(), "\n";
  
  Other parameters are specific to the appender class being used.
  In the case above, the C<filename> parameter specifies the name of 
  the C<Log::Log4perl::Appender::File> dispatcher used. 
  
  However, if, for instance, 
  you're using a C<Log::Dispatch::Email> dispatcher to send you 
  email, you'll have to specify C<from> and C<to> email addresses.
  Every dispatcher is different.
  Please check the C<Log::Dispatch::*> documentation for the appender used
  for details on specific requirements.
  
  The C<new()> method will just pass these parameters on to a newly created
  C<Log::Dispatch::*> object of the specified type.
  
  When it comes to logging, the C<Log::Log4perl::Appender> will transparently
  relay all messages to the C<Log::Dispatch::*> object it carries 
  in its womb.
  
  =head2 $appender->layout($layout);
  
  The C<layout()> method sets the log layout
  used by the appender to the format specified by the 
  C<Log::Log4perl::Layout::*> object which is passed to it as a reference.
  Currently there's two layouts available:
  
      Log::Log4perl::Layout::SimpleLayout
      Log::Log4perl::Layout::PatternLayout
  
  Please check the L<Log::Log4perl::Layout::SimpleLayout> and 
  L<Log::Log4perl::Layout::PatternLayout> manual pages for details.
  
  =head1 Supported Appenders 
  
  Here's the list of appender modules currently available via C<Log::Dispatch>,
  if not noted otherwise, written by Dave Rolsky:
  
         Log::Dispatch::ApacheLog
         Log::Dispatch::DBI (by Tatsuhiko Miyagawa)
         Log::Dispatch::Email,
         Log::Dispatch::Email::MailSend,
         Log::Dispatch::Email::MailSendmail,
         Log::Dispatch::Email::MIMELite
         Log::Dispatch::File
         Log::Dispatch::FileRotate (by Mark Pfeiffer)
         Log::Dispatch::Handle
         Log::Dispatch::Screen
         Log::Dispatch::Syslog
         Log::Dispatch::Tk (by Dominique Dumont)
  
  C<Log4perl> doesn't care which ones you use, they're all handled in 
  the same way via the C<Log::Log4perl::Appender> interface.
  Please check the well-written manual pages of the 
  C<Log::Dispatch> hierarchy on how to use each one of them.
  
  =head1 Parameters passed on to the appender's log() method
  
  When calling the appender's log()-Funktion, Log::Log4perl will 
  submit a list of key/value pairs. Entries to the following keys are
  guaranteed to be present:
  
  =over 4
  
  =item message
  
  Text of the rendered message
  
  =item log4p_category
  
  Name of the category of the logger that triggered the event.
  
  =item log4p_level
  
  Log::Log4perl level of the event
  
  =back
  
  =head1 Pitfalls
  
  Since the C<Log::Dispatch::File> appender truncates log files by default,
  and most of the time this is I<not> what you want, we've instructed 
  C<Log::Log4perl> to change this behavior by slipping it the 
  C<mode =E<gt> append> parameter behind the scenes. So, effectively
  with C<Log::Log4perl> 0.23, a configuration like
  
      log4perl.category = INFO, FileAppndr
      log4perl.appender.FileAppndr          = Log::Dispatch::File
      log4perl.appender.FileAppndr.filename = test.log
      log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout
  
  will always I<append> to an existing logfile C<test.log> while if you 
  specifically request clobbering like in
  
      log4perl.category = INFO, FileAppndr
      log4perl.appender.FileAppndr          = Log::Dispatch::File
      log4perl.appender.FileAppndr.filename = test.log
      log4perl.appender.FileAppndr.mode     = write
      log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout
  
  it will overwrite an existing log file C<test.log> and start from scratch.
  
  =head1 Appenders Expecting Message Chunks
  
  Instead of simple strings, certain appenders are expecting multiple fields
  as log messages. If a statement like 
  
      $logger->debug($ip, $user, "signed in");
  
  causes an off-the-shelf C<Log::Log4perl::Appender::Screen> 
  appender to fire, the appender will 
  just concatenate the three message chunks passed to it
  in order to form a single string.
  The chunks will be separated by a string defined in 
  C<$Log::Log4perl::JOIN_MSG_ARRAY_CHAR> (defaults to the empty string
  ""). 
  
  However, different appenders might choose to 
  interpret the message above differently: An
  appender like C<Log::Log4perl::Appender::DBI> might take the
  three arguments passed to the logger and put them in three separate
  rows into the DB.
  
  The  C<warp_message> appender option is used to specify the desired 
  behavior.
  If no setting for the appender property
  
      # *** Not defined ***
      # log4perl.appender.SomeApp.warp_message
  
  is defined in the Log4perl configuration file, the
  appender referenced by C<SomeApp> will fall back to the standard behavior
  and join all message chunks together, separating them by
  C<$Log::Log4perl::JOIN_MSG_ARRAY_CHAR>.
  
  If, on the other hand, it is set to a false value, like in
  
      log4perl.appender.SomeApp.layout=NoopLayout
      log4perl.appender.SomeApp.warp_message = 0
  
  then the message chunks are passed unmodified to the appender as an
  array reference. Please note that you need to set the appender's
  layout to C<Log::Log4perl::Layout::NoopLayout> which just leaves 
  the messages chunks alone instead of formatting them or replacing
  conversion specifiers.
  
  B<Please note that the standard appenders in the Log::Dispatch hierarchy
  will choke on a bunch of messages passed to them as an array reference. 
  You can't use C<warp_message = 0> (or the function name syntax
  defined below) on them.
  Only special appenders like Log::Log4perl::Appender::DBI can deal with
  this.>
  
  If (and now we're getting fancy)
  an appender expects message chunks, but we would 
  like to pre-inspect and probably modify them before they're 
  actually passed to the appender's C<log>
  method, an inspection subroutine can be defined with the
  appender's C<warp_message> property:
  
      log4perl.appender.SomeApp.layout=NoopLayout
      log4perl.appender.SomeApp.warp_message = sub { \
                                             $#_ = 2 if @_ > 3; \
                                             return @_; }
  
  The inspection subroutine defined by the C<warp_message> 
  property will receive the list of message chunks, like they were
  passed to the logger and is expected to return a corrected list.
  The example above simply limits the argument list to a maximum of
  three by cutting off excess elements and returning the shortened list.
  
  Also, the warp function can be specified by name like in
  
      log4perl.appender.SomeApp.layout=NoopLayout
      log4perl.appender.SomeApp.warp_message = main::filter_my_message
  
  In this example,
  C<filter_my_message> is a function in the C<main> package, 
  defined like this:
  
      my $COUNTER = 0;
  
      sub filter_my_message {
          my @chunks = @_;
          unshift @chunks, ++$COUNTER;
          return @chunks;
      }
  
  The subroutine above will add an ever increasing counter
  as an additional first field to 
  every message passed to the C<SomeApp> appender -- but not to
  any other appender in the system.
  
  =head2 Composite Appenders
  
  Composite appenders relay their messages to sub-appenders after providing
  some filtering or synchronizing functionality on incoming messages. 
  Examples are 
  Log::Log4perl::Appender::Synchronized,
  Log::Log4perl::Appender::Limit, and
  Log::Log4perl::Appender::Buffer. Check their manual pages for details.
  
  Composite appender objects are regular Log::Log4perl::Appender objects, 
  but they have the composite flag set:
  
      $app->composite(1);
  
  and they define a post_init() method, which sets the appender it relays
  its messages to:
  
      ###########################################
      sub post_init {
      ############################################
          my($self) = @_;
      
          if(! exists $self->{appender}) {
              die "No appender defined for " . __PACKAGE__;
          }
      
          my $appenders = Log::Log4perl->appenders();
          my $appender = Log::Log4perl->appenders()->{$self->{appender}};
      
          if(! defined $appender) {
              die "Appender $self->{appender} not defined (yet) when " .
                  __PACKAGE__ . " needed it";
          }
      
          $self->{app} = $appender;
      }
  
  The reason for this post-processing step is that the relay appender
  might not be defined yet when the composite appender gets defined.
  This can happen if Log4perl is initialized with a configuration file
  (which is the most common way to initialize Log4perl), because
  appenders spring into existence in unpredictable order.
  
  For example, if you define a Synchronized appender like
  
      log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer.appender   = Logfile
  
  then Log4perl will set the appender's C<appender> attribute to the
  I<name> of the appender to finally relay messages to. After the
  Log4perl configuration file has been processed, Log4perl will remember to 
  call the composite appender's post_init() method, which will grab
  the relay appender instance referred to by the name (Logfile) 
  and set it in its C<app> attribute. This is exactly what the
  code snippet above does.
  
  But if you initialize Log4perl by its API, you need to remember to
  perform these steps. Here's the lineup:
  
      use Log::Log4perl qw(get_logger :levels);
      
      my $fileApp = Log::Log4perl::Appender->new(
      		'Log::Log4perl::Appender::File',
      		name     => 'MyFileApp',
      		filename => 'mylog',
      		mode     => 'append',
      		);
      $fileApp->layout(
      		Log::Log4perl::Layout::PatternLayout::Multiline->new(
      			'%d{yyyy-MM-dd HH:mm:ss} %p [%c] #%P> %m%n')
      		);
        # Make the appender known to the system (without assigning it to
        # any logger
      Log::Log4perl->add_appender( $fileApp );
      
      my $syncApp = Log::Log4perl::Appender->new(
      		'Log::Log4perl::Appender::Synchronized',
      		name       => 'MySyncApp',
      		appender   => 'MyFileApp',
      		key        => 'nem',
      		);
      $syncApp->post_init();
      $syncApp->composite(1);
  
        # The Synchronized appender is now ready, assign it to a logger
        # and start logging.
      get_logger("")->add_appender($syncApp);
  
      get_logger("")->level($DEBUG);
      get_logger("wonk")->debug("waah!");
  
  The composite appender's log() function will typically cache incoming 
  messages until a certain trigger condition is met and then forward a bulk
  of messages to the relay appender.
  
  Caching messages is surprisingly tricky, because you want them to look
  like they came from the code location they were originally issued from
  and not from the location that triggers the flush. Luckily, Log4perl
  offers a cache mechanism for messages, all you need to do is call the
  base class' log() function with an additional reference to a scalar,
  and then save its content to your composite appender's message buffer
  afterwards:
  
      ###########################################
      sub log {
      ###########################################
          my($self, %params) = @_;
  
          # ... some logic to decide whether to cache or flush
  
              # Adjust the caller stack
          local $Log::Log4perl::caller_depth =
                $Log::Log4perl::caller_depth + 2;
  
              # We need to cache.
              # Ask the appender to save a cached message in $cache
          $self->{relay_app}->SUPER::log(\%params,
                               $params{log4p_category},
                               $params{log4p_level}, \my $cache);
  
              # Save it in the appender's message buffer
          push @{ $self->{buffer} }, $cache;
      }
  
  Note that before calling the log() method of the relay appender's base class
  (and thus introducing two additional levels on the call stack), we need to
  adjust the call stack to allow Log4perl to render cspecs like the %M or %L
  correctly.  The cache will then contain a correctly rendered message, according
  to the layout of the target appender.
  
  Later, when the time comes to flush the cached messages, a call to the relay
  appender's base class' log_cached() method with the cached message as 
  an argument will forward the correctly rendered message:
  
      ###########################################
      sub log {
      ###########################################
          my($self, %params) = @_;
  
          # ... some logic to decide whether to cache or flush
  
              # Flush pending messages if we have any
          for my $cache (@{$self->{buffer}}) {
              $self->{relay_app}->SUPER::log_cached($cache);
          }
      }
  
  
  =head1 SEE ALSO
  
  Log::Dispatch
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER

$fatpacked{"Log/Log4perl/Appender/Buffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_BUFFER';
  ######################################################################
  # Buffer.pm -- 2004, Mike Schilli <m@perlmeister.com>
  ######################################################################
  # Composite appender buffering messages until a trigger condition is met.
  ######################################################################
  
  ###########################################
  package Log::Log4perl::Appender::Buffer;
  ###########################################
  
  use strict;
  use warnings;
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  our $CVSVERSION   = '$Revision: 1.2 $';
  our ($VERSION)    = ($CVSVERSION =~ /(\d+\.\d+)/);
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = {
          appender=> undef,
          buffer  => [],
          options => { 
              max_messages  => undef, 
              trigger       => undef,
              trigger_level => undef,
          },
          level   => 0,
          %options,
      };
  
      if($self->{trigger_level}) {
          $self->{trigger} = level_trigger($self->{trigger_level});
      }
  
          # Pass back the appender to be synchronized as a dependency
          # to the configuration file parser
      push @{$options{l4p_depends_on}}, $self->{appender};
  
          # Run our post_init method in the configurator after
          # all appenders have been defined to make sure the
          # appender we're playing 'dam' for really exists
      push @{$options{l4p_post_config_subs}}, sub { $self->post_init() };
  
      bless $self, $class;
  }
  
  ###########################################
  sub log {
  ###########################################
      my($self, %params) = @_;
  
      local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 2;
  
          # Do we need to discard a message because there's already
          # max_size messages in the buffer?
      if(defined $self->{max_messages} and
         @{$self->{buffer}} == $self->{max_messages}) {
          shift @{$self->{buffer}};
      }
          # Ask the appender to save a cached message in $cache
      $self->{app}->SUPER::log(\%params,
                           $params{log4p_category},
                           $params{log4p_level}, \my $cache);
  
          # Save it in the appender's message buffer, but only if
          # it hasn't been suppressed by an appender threshold
      if( defined $cache ) {
          push @{ $self->{buffer} }, $cache;
      }
  
      $self->flush() if $self->{trigger}->($self, \%params);
  }
  
  ###########################################
  sub flush {
  ###########################################
      my($self) = @_;
  
          # Flush pending messages if we have any
      for my $cache (@{$self->{buffer}}) {
          $self->{app}->SUPER::log_cached($cache);
      }
  
          # Empty buffer
      $self->{buffer} = [];
  }
  
  ###########################################
  sub post_init {
  ###########################################
      my($self) = @_;
  
      if(! exists $self->{appender}) {
         die "No appender defined for " . __PACKAGE__;
      }
  
      my $appenders = Log::Log4perl->appenders();
      my $appender = Log::Log4perl->appenders()->{$self->{appender}};
  
      if(! defined $appender) {
         die "Appender $self->{appender} not defined (yet) when " .
             __PACKAGE__ . " needed it";
      }
  
      $self->{app} = $appender;
  }
  
  ###########################################
  sub level_trigger {
  ###########################################
      my($level) = @_;
  
          # closure holding $level
      return sub {
          my($self, $params) = @_;
  
          return Log::Log4perl::Level::to_priority(
                   $params->{log4p_level}) >= 
                 Log::Log4perl::Level::to_priority($level);
      };
  }
      
  ###########################################
  sub DESTROY {
  ###########################################
      my($self) = @_;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
      Log::Log4perl::Appender::Buffer - Buffering Appender
  
  =head1 SYNOPSIS
  
      use Log::Log4perl qw(:easy);
  
      my $conf = qq(
      log4perl.category                  = DEBUG, Buffer
  
          # Regular Screen Appender
      log4perl.appender.Screen           = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.stdout    = 1
      log4perl.appender.Screen.layout    = PatternLayout
      log4perl.appender.Screen.layout.ConversionPattern = %d %p %c %m %n
  
          # Buffering appender, using the appender above as outlet
      log4perl.appender.Buffer               = Log::Log4perl::Appender::Buffer
      log4perl.appender.Buffer.appender      = Screen
      log4perl.appender.Buffer.trigger_level = ERROR
      );
  
      Log::Log4perl->init(\$conf);
  
      DEBUG("This message gets buffered.");
      INFO("This message gets buffered also.");
  
      # Time passes. Nothing happens. But then ...
  
      print "It's GO time!!!\n";
  
      ERROR("This message triggers a buffer flush.");
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Appender::Buffer> takes these arguments:
  
  =over 4
  
  =item C<appender>
  
  Specifies the name of the appender it buffers messages for. The
  appender specified must be defined somewhere in the configuration file,
  not necessarily before the definition of 
  C<Log::Log4perl::Appender::Buffer>.
  
  =item C<max_messages>
  
  Specifies the maximum number of messages the appender will hold in
  its ring buffer. C<max_messages> is optional. By default,
  C<Log::Log4perl::Appender::Buffer> will I<not> limit the number of
  messages buffered. This might be undesirable in long-running processes
  accumulating lots of messages before a flush happens. If
  C<max_messages> is set to a numeric value,
  C<Log::Log4perl::Appender::Buffer> will displace old messages in its
  buffer to make room if the buffer is full.
  
  =item C<trigger_level>
  
  If trigger_level is set to one of Log4perl's levels (see
  Log::Log4perl::Level), a C<trigger> function will be defined internally
  to flush the buffer if a message with a priority of $level or higher
  comes along. This is just a convenience function. Defining
  
      log4perl.appender.Buffer.trigger_level = ERROR
  
  is equivalent to creating a trigger function like
  
      log4perl.appender.Buffer.trigger = sub {   \
          my($self, $params) = @_;               \
          return $params->{log4p_level} >=       \
                 $Log::Log4perl::Level::ERROR; }
  
  See the next section for defining generic trigger functions.
  
  =item C<trigger>
  
  C<trigger> holds a reference to a subroutine, which
  C<Log::Log4perl::Appender::Buffer> will call on every incoming message
  with the same parameters as the appender's C<log()> method:
  
          my($self, $params) = @_;
  
  C<$params> references a hash containing
  the message priority (key C<l4p_level>), the
  message category (key C<l4p_category>) and the content of the message
  (key C<message>).
  
  If the subroutine returns 1, it will trigger a flush of buffered messages.
  
  Shortcut 
  
  =back
  
  =head1 DEVELOPMENT NOTES
  
  C<Log::Log4perl::Appender::Buffer> is a I<composite> appender.
  Unlike other appenders, it doesn't log any messages, it just
  passes them on to its attached sub-appender.
  For this reason, it doesn't need a layout (contrary to regular appenders).
  If it defines none, messages are passed on unaltered.
  
  Custom filters are also applied to the composite appender only.
  They are I<not> applied to the sub-appender. Same applies to appender
  thresholds. This behaviour might change in the future.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_BUFFER

$fatpacked{"Log/Log4perl/Appender/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_DBI';
  package Log::Log4perl::Appender::DBI;
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  use Carp;
  
  use strict;
  use DBI;
  
  sub new {
      my($proto, %p) = @_;
      my $class = ref $proto || $proto;
  
      my $self = bless {}, $class;
  
      $self->_init(%p);
  
      my %defaults = (
          reconnect_attempts => 1,
          reconnect_sleep    => 0,
      );
  
      for (keys %defaults) {
          if(exists $p{$_}) {
              $self->{$_} = $p{$_};
          } else {
              $self->{$_} = $defaults{$_};
          }
      }
  
      #e.g.
      #log4j.appender.DBAppndr.params.1 = %p    
      #log4j.appender.DBAppndr.params.2 = %5.5m
      foreach my $pnum (keys %{$p{params}}){
          $self->{bind_value_layouts}{$pnum} = 
                  Log::Log4perl::Layout::PatternLayout->new({
                     ConversionPattern  => {value  => $p{params}->{$pnum}},
                     undef_column_value => undef,
                  });
      }
      #'bind_value_layouts' now contains a PatternLayout
      #for each parameter heading for the Sql engine
  
      $self->{SQL} = $p{sql}; #save for error msg later on
  
      $self->{MAX_COL_SIZE} = $p{max_col_size};
  
      $self->{BUFFERSIZE} = $p{bufferSize} || 1; 
  
      if ($p{usePreparedStmt}) {
          $self->{sth} = $self->create_statement($p{sql});
          $self->{usePreparedStmt} = 1;
      }else{
          $self->{layout} = Log::Log4perl::Layout::PatternLayout->new({
              ConversionPattern  => {value  => $p{sql}},
              undef_column_value => undef,
          });
      }
  
      if ($self->{usePreparedStmt} &&  $self->{bufferSize}){
          warn "Log4perl: you've defined both usePreparedStmt and bufferSize \n".
          "in your appender '$p{name}'--\n".
          "I'm going to ignore bufferSize and just use a prepared stmt\n";
      }
  
      return $self;
  }
  
  
  sub _init {
      my $self = shift;
      my %params = @_;
  
      if ($params{dbh}) {
          $self->{dbh} = $params{dbh};
      } else {
          $self->{connect} = sub {
              DBI->connect(@params{qw(datasource username password)},
                           {PrintError => 0, $params{attrs} ? %{$params{attrs}} : ()})
                              or croak "Log4perl: $DBI::errstr";
          };
          $self->{dbh} = $self->{connect}->();
          $self->{_mine} = 1;
      }
  }
  
  sub create_statement {
      my ($self, $stmt) = @_;
  
      $stmt || croak "Log4perl: sql not set in Log4perl::Appender::DBI";
  
      return $self->{dbh}->prepare($stmt) || croak "Log4perl: DBI->prepare failed $DBI::errstr\n$stmt";
  
  }
  
  
  sub log {
      my $self = shift;
      my %p = @_;
  
      #%p is
      #    { name    => $appender_name,
      #      level   => loglevel
      #      message => $message,
      #      log4p_category => $category,
      #      log4p_level  => $level,);
      #    },
  
          #getting log4j behavior with no specified ConversionPattern
      chomp $p{message} unless ref $p{message}; 
  
          
      my $qmarks = $self->calculate_bind_values(\%p);
  
  
      if ($self->{usePreparedStmt}) {
  
          $self->query_execute($self->{sth}, @$qmarks);
  
      }else{
  
          #first expand any %x's in the statement
          my $stmt = $self->{layout}->render(
                          $p{message},
                          $p{log4p_category},
                          $p{log4p_level},
                          5 + $Log::Log4perl::caller_depth,  
                          );
  
          push @{$self->{BUFFER}}, $stmt, $qmarks;
  
          $self->check_buffer();
      }
  }
  
  sub query_execute {
      my($self, $sth, @qmarks) = @_;
  
      my $errstr = "[no error]";
  
      for my $attempt (0..$self->{reconnect_attempts}) {
          #warn "Exe: @qmarks"; # TODO
          if(! $sth->execute(@qmarks)) {
  
                    # save errstr because ping() would override it [RT 56145]
                  $errstr = $self->{dbh}->errstr();
  
                  # Exe failed -- was it because we lost the DB
                  # connection?
                  if($self->{dbh}->ping()) {
                      # No, the connection is ok, we failed because there's
                      # something wrong with the execute(): Bad SQL or 
                      # missing parameters or some such). Abort.
                      croak "Log4perl: DBI appender error: '$errstr'";
                  }
  
                  if($attempt == $self->{reconnect_attempts}) {
                      croak "Log4perl: DBI appender failed to " .
                            ($self->{reconnect_attempts} == 1 ? "" : "re") .
                            "connect " .
                            "to database after " .
                            "$self->{reconnect_attempts} attempt" .
                            ($self->{reconnect_attempts} == 1 ? "" : "s") .
                            " (last error error was [$errstr]";
                  }
              if(! $self->{dbh}->ping()) {
                  # Ping failed, try to reconnect
                  if($attempt) {
                      #warn "Sleeping"; # TODO
                      sleep($self->{reconnect_sleep}) if $self->{reconnect_sleep};
                  }
  
                  eval {
                      #warn "Reconnecting to DB"; # TODO
                      $self->{dbh} = $self->{connect}->();
                  };
              }
  
              if ($self->{usePreparedStmt}) {
                  $sth = $self->create_statement($self->{SQL});
                  $self->{sth} = $sth if $self->{sth};
              } else {
                  #warn "Pending stmt: $self->{pending_stmt}"; #TODO
                  $sth = $self->create_statement($self->{pending_stmt});
              }
  
              next;
          }
          return 1;
      }
      croak "Log4perl: DBI->execute failed $errstr, \n".
            "on $self->{SQL}\n @qmarks";
  }
  
  sub calculate_bind_values {
      my ($self, $p) = @_;
  
      my @qmarks;
      my $user_ph_idx = 0;
  
      my $i=0;
      
      if ($self->{bind_value_layouts}) {
  
          my $prev_pnum = 0;
          my $max_pnum = 0;
      
          my @pnums = sort {$a <=> $b} keys %{$self->{bind_value_layouts}};
          $max_pnum = $pnums[-1];
          
          #Walk through the integers for each possible bind value.
          #If it doesn't have a layout assigned from the config file
          #then shift it off the array from the $log call
          #This needs to be reworked now that we always get an arrayref? --kg 1/2003
          foreach my $pnum (1..$max_pnum){
              my $msg;
      
                  #we've got a bind_value_layout to fill the spot
              if ($self->{bind_value_layouts}{$pnum}){
                 $msg = $self->{bind_value_layouts}{$pnum}->render(
                          $p->{message},
                          $p->{log4p_category},
                          $p->{log4p_level},
                          5 + $Log::Log4perl::caller_depth,  
                      );
  
                 #we don't have a bind_value_layout, so get
                 #a message bit
              }elsif (ref $p->{message} eq 'ARRAY' && @{$p->{message}}){
                  #$msg = shift @{$p->{message}};
                  $msg = $p->{message}->[$i++];
  
                 #here handle cases where we ran out of message bits
                 #before we ran out of bind_value_layouts, just keep going
              }elsif (ref $p->{message} eq 'ARRAY'){
                  $msg = undef;
                  $p->{message} = undef;
  
                 #here handle cases where we didn't get an arrayref
                 #log the message in the first placeholder and nothing in the rest
              }elsif (! ref $p->{message} ){
                  $msg = $p->{message};
                  $p->{message} = undef;
  
              }
  
              if ($self->{MAX_COL_SIZE} &&
                  length($msg) > $self->{MAX_COL_SIZE}){
                  substr($msg, $self->{MAX_COL_SIZE}) = '';
              }
              push @qmarks, $msg;
          }
      }
  
      #handle leftovers
      if (ref $p->{message} eq 'ARRAY' && @{$p->{message}} ) {
          #push @qmarks, @{$p->{message}};
          push @qmarks, @{$p->{message}}[$i..@{$p->{message}}-1];
  
      }
  
      return \@qmarks;
  }
  
  
  sub check_buffer {
      my $self = shift;
  
      return unless ($self->{BUFFER} && ref $self->{BUFFER} eq 'ARRAY');
  
      if (scalar @{$self->{BUFFER}} >= $self->{BUFFERSIZE} * 2) {
  
          my ($sth, $stmt, $prev_stmt);
  
          $prev_stmt = ""; # Init to avoid warning (ms 5/10/03)
  
          while (@{$self->{BUFFER}}) {
              my ($stmt, $qmarks) = splice (@{$self->{BUFFER}},0,2);
  
              $self->{pending_stmt} = $stmt;
  
                  #reuse the sth if the stmt doesn't change
              if ($stmt ne $prev_stmt) {
                  $sth->finish if $sth;
                  $sth = $self->create_statement($stmt);
              }
  
              $self->query_execute($sth, @$qmarks);
  
              $prev_stmt = $stmt;
  
          }
  
          $sth->finish;
  
          my $dbh = $self->{dbh};
  
          if ($dbh && ! $dbh->{AutoCommit}) {
              $dbh->commit;
          }
      }
  }
  
  sub DESTROY {
      my $self = shift;
  
      $self->{BUFFERSIZE} = 1;
  
      $self->check_buffer();
  
      if ($self->{_mine} && $self->{dbh}) {
          $self->{dbh}->disconnect;
      }
  }
  
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::DBI - implements appending to a DB
  
  =head1 SYNOPSIS
  
      my $config = q{
       log4j.category = WARN, DBAppndr
       log4j.appender.DBAppndr             = Log::Log4perl::Appender::DBI
       log4j.appender.DBAppndr.datasource  = DBI:CSV:f_dir=t/tmp
       log4j.appender.DBAppndr.username    = bobjones
       log4j.appender.DBAppndr.password    = 12345
       log4j.appender.DBAppndr.sql         = \
          insert into log4perltest           \
          (loglevel, custid, category, message, ipaddr) \
          values (?,?,?,?,?)
       log4j.appender.DBAppndr.params.1 = %p    
                                     #2 is custid from the log() call
       log4j.appender.DBAppndr.params.3 = %c
                                     #4 is the message from log()
                                     #5 is ipaddr from log()
  
       log4j.appender.DBAppndr.usePreparedStmt = 1
        #--or--
       log4j.appender.DBAppndr.bufferSize = 2
  
       #just pass through the array of message items in the log statement
       log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::NoopLayout
       log4j.appender.DBAppndr.warp_message = 0
  
       #driver attributes support
       log4j.appender.DBAppndr.attrs.f_encoding = utf8
      };
  
      $logger->warn( $custid, 'big problem!!', $ip_addr );
  
  =head1 CAVEAT
  
  This is a very young module and there are a lot of variations
  in setups with different databases and connection methods,
  so make sure you test thoroughly!  Any feedback is welcome!
  
  =head1 DESCRIPTION
  
  This is a specialized Log::Dispatch object customized to work with
  log4perl and its abilities, originally based on Log::Dispatch::DBI 
  by Tatsuhiko Miyagawa but with heavy modifications.
  
  It is an attempted compromise between what Log::Dispatch::DBI was 
  doing and what log4j's JDBCAppender does.  Note the log4j docs say
  the JDBCAppender "is very likely to be completely replaced in the future."
  
  The simplest usage is this:
  
      log4j.category = WARN, DBAppndr
      log4j.appender.DBAppndr            = Log::Log4perl::Appender::DBI
      log4j.appender.DBAppndr.datasource = DBI:CSV:f_dir=t/tmp
      log4j.appender.DBAppndr.username   = bobjones
      log4j.appender.DBAppndr.password   = 12345
      log4j.appender.DBAppndr.sql        = \
         INSERT INTO logtbl                \
            (loglevel, message)            \
            VALUES ('%c','%m')
  
      log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::PatternLayout
  
  
      $logger->fatal('fatal message');
      $logger->warn('warning message');
  
      ===============================
      |FATAL|fatal message          |
      |WARN |warning message        |
      ===============================
  
  
  But the downsides to that usage are:
  
  =over 4
  
  =item * 
  
  You'd better be darn sure there are not quotes in your log message, or your
  insert could have unforeseen consequences!  This is a very insecure way to
  handle database inserts, using place holders and bind values is much better, 
  keep reading. (Note that the log4j docs warn "Be careful of quotes in your 
  messages!") B<*>.
  
  =item *
  
  It's not terribly high-performance, a statement is created and executed
  for each log call.
  
  =item *
  
  The only run-time parameter you get is the %m message, in reality
  you probably want to log specific data in specific table columns.
  
  =back
  
  So let's try using placeholders, and tell the logger to create a
  prepared statement handle at the beginning and just reuse it 
  (just like Log::Dispatch::DBI does)
  
  
      log4j.appender.DBAppndr.sql = \
         INSERT INTO logtbl \
            (custid, loglevel, message) \
            VALUES (?,?,?)
  
      #---------------------------------------------------
      #now the bind values:
                                    #1 is the custid
      log4j.appender.DBAppndr.params.2 = %p    
                                    #3 is the message
      #---------------------------------------------------
  
      log4j.appender.DBAppndr.layout    = Log::Log4perl::Layout::NoopLayout
      log4j.appender.DBAppndr.warp_message = 0
      
      log4j.appender.DBAppndr.usePreparedStmt = 1
      
      
      $logger->warn( 1234, 'warning message' ); 
  
  
  Now see how we're using the '?' placeholders in our statement?  This
  means we don't have to worry about messages that look like 
  
      invalid input: 1234';drop table custid;
  
  fubaring our database!
  
  Normally a list of things in the logging statement gets concatenated into 
  a single string, but setting C<warp_message> to 0 and using the 
  NoopLayout means that in
  
      $logger->warn( 1234, 'warning message', 'bgates' );
  
  the individual list values will still be available for the DBI appender later 
  on.  (If C<warp_message> is not set to 0, the default behavior is to
  join the list elements into a single string.   If PatternLayout or SimpleLayout
  are used, their attempt to C<render()> your layout will result in something 
  like "ARRAY(0x841d8dc)" in your logs.  More information on C<warp_message>
  is in Log::Log4perl::Appender.)
  
  In your insert SQL you can mix up '?' placeholders with conversion specifiers 
  (%c, %p, etc) as you see fit--the logger will match the question marks to 
  params you've defined in the config file and populate the rest with values 
  from your list.  If there are more '?' placeholders than there are values in 
  your message, it will use undef for the rest.  For instance, 
  
  	log4j.appender.DBAppndr.sql =                 \
  	   insert into log4perltest                   \
  	   (loglevel, message, datestr, subpoena_id)\
  	   values (?,?,?,?)
  	log4j.appender.DBAppndr.params.1 = %p
  	log4j.appender.DBAppndr.params.3 = %d
  
  	log4j.appender.DBAppndr.warp_message=0
  
  
  	$logger->info('arrest him!', $subpoena_id);
  
  results in the first '?' placeholder being bound to %p, the second to
  "arrest him!", the third to the date from "%d", and the fourth to your
  $subpoenaid.  If you forget the $subpoena_id and just log
  
  	$logger->info('arrest him!');
  
  then you just get undef in the fourth column.
  
  
  If the logger statement is also being handled by other non-DBI appenders,
  they will just join the list into a string, joined with 
  C<$Log::Log4perl::JOIN_MSG_ARRAY_CHAR> (default is an empty string).
  
  And see the C<usePreparedStmt>?  That creates a statement handle when
  the logger object is created and just reuses it.  That, however, may
  be problematic for long-running processes like webservers, in which case
  you can use this parameter instead
  
      log4j.appender.DBAppndr.bufferSize=2
  
  This copies log4j's JDBCAppender's behavior, it saves up that many
  log statements and writes them all out at once.  If your INSERT
  statement uses only ? placeholders and no %x conversion specifiers
  it should be quite efficient because the logger can re-use the
  same statement handle for the inserts.
  
  If the program ends while the buffer is only partly full, the DESTROY
  block should flush the remaining statements, if the DESTROY block
  runs of course.
  
  * I<As I was writing this, Danko Mannhaupt was coming out with his
  improved log4j JDBCAppender (http://www.mannhaupt.com/danko/projects/)
  which overcomes many of the drawbacks of the original JDBCAppender.>
  
  =head1 DESCRIPTION 2
  
  Or another way to say the same thing:
  
  The idea is that if you're logging to a database table, you probably
  want specific parts of your log information in certain columns.  To this
  end, you pass an list to the log statement, like 
  
      $logger->warn('big problem!!',$userid,$subpoena_nr,$ip_addr);
  
  and the array members drop into the positions defined by the placeholders
  in your SQL statement. You can also define information in the config
  file like
  
      log4j.appender.DBAppndr.params.2 = %p    
  
  in which case those numbered placeholders will be filled in with
  the specified values, and the rest of the placeholders will be
  filled in with the values from your log statement's array.
  
  =head1 MISC PARAMETERS
  
  
  =over 4
  
  =item usePreparedStmt
  
  See above.
  
  =item warp_message
  
  see Log::Log4perl::Appender
  
  =item max_col_size
  
  If you're used to just throwing debugging messages like huge stacktraces
  into your logger, some databases (Sybase's DBD!!) may surprise you 
  by choking on data size limitations.  Normally, the data would
  just be truncated to fit in the column, but Sybases's DBD it turns out
  maxes out at 255 characters.  Use this parameter in such a situation
  to truncate long messages before they get to the INSERT statement.
  
  =back
  
  =head1 CHANGING DBH CONNECTIONS (POOLING)
  
  If you want to get your dbh from some place in particular, like
  maybe a pool, subclass and override _init() and/or create_statement(), 
  for instance 
  
      sub _init {
          ; #no-op, no pooling at this level
      }
      sub create_statement {
          my ($self, $stmt) = @_;
      
          $stmt || croak "Log4perl: sql not set in ".__PACKAGE__;
      
          return My::Connections->getConnection->prepare($stmt) 
              || croak "Log4perl: DBI->prepare failed $DBI::errstr\n$stmt";
      }
  
  
  =head1 LIFE OF CONNECTIONS
  
  If you're using C<log4j.appender.DBAppndr.usePreparedStmt>
  this module creates an sth when it starts and keeps it for the life
  of the program.  For long-running processes (e.g. mod_perl), connections
  might go stale, but if C<Log::Log4perl::Appender::DBI> tries to write
  a message and figures out that the DB connection is no longer working
  (using DBI's ping method), it will reconnect.
  
  The reconnection process can be controlled by two parameters,
  C<reconnect_attempts> and C<reconnect_sleep>. C<reconnect_attempts>
  specifies the number of reconnections attempts the DBI appender 
  performs until it gives up and dies. C<reconnect_sleep> is the
  time between reconnection attempts, measured in seconds.
  C<reconnect_attempts> defaults to 1,  C<reconnect_sleep> to 0.
  
  Alternatively, use C<Apache::DBI> or C<Apache::DBI::Cache> and read
  CHANGING DB CONNECTIONS above.
  
  Note that C<Log::Log4perl::Appender::DBI> holds one connection open
  for every appender, which might be too many.
  
  =head1 SEE ALSO
  
  L<Log::Dispatch::DBI>
  
  L<Log::Log4perl::JavaMap::JDBCAppender>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_DBI

$fatpacked{"Log/Log4perl/Appender/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_FILE';
  ##################################################
  package Log::Log4perl::Appender::File;
  ##################################################
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  use warnings;
  use strict;
  use Log::Log4perl::Config::Watch;
  use Fcntl;
  use File::Path;
  use File::Spec::Functions qw(splitpath);
  use constant _INTERNAL_DEBUG => 0;
  
  ##################################################
  sub new {
  ##################################################
      my($class, @options) = @_;
  
      my $self = {
          name      => "unknown name",
          umask     => undef,
          owner     => undef,
          group     => undef,
          autoflush => 1,
          syswrite  => 0,
          mode      => "append",
          binmode   => undef,
          utf8      => undef,
          recreate  => 0,
          recreate_check_interval => 30,
          recreate_check_signal   => undef,
          recreate_pid_write      => undef,
          create_at_logtime       => 0,
          header_text             => undef,
          mkpath                  => 0,
          mkpath_umask            => 0,
          @options,
      };
  
      if($self->{create_at_logtime}) {
          $self->{recreate}  = 1;
      }
      for my $param ('umask', 'mkpath_umask') {
          if(defined $self->{$param} and $self->{$param} =~ /^0/) {
                  # umask value is a string, meant to be an oct value
              $self->{$param} = oct($self->{$param});
          }
      }
  
      die "Mandatory parameter 'filename' missing" unless
          exists $self->{filename};
  
      bless $self, $class;
  
      if($self->{recreate_pid_write}) {
          print "Creating pid file",
                " $self->{recreate_pid_write}\n" if _INTERNAL_DEBUG;
          open FILE, ">$self->{recreate_pid_write}" or
              die "Cannot open $self->{recreate_pid_write}";
          print FILE "$$\n";
          close FILE;
      }
  
          # This will die() if it fails
      $self->file_open() unless $self->{create_at_logtime};
  
      return $self;
  }
  
  ##################################################
  sub filename {
  ##################################################
      my($self) = @_;
  
      return $self->{filename};
  }
  
  ##################################################
  sub file_open {
  ##################################################
      my($self) = @_;
  
      my $arrows  = ">";
      my $sysmode = (O_CREAT|O_WRONLY);
  
  
      if($self->{mode} eq "append") {
          $arrows   = ">>";
          $sysmode |= O_APPEND;
      } elsif ($self->{mode} eq "pipe") {
          $arrows = "|";
      } else {
          $sysmode |= O_TRUNC;
      }
  
      my $fh = do { local *FH; *FH; };
  
  
      my $didnt_exist = ! -e $self->{filename};
      if($didnt_exist && $self->{mkpath}) {
          my ($volume, $path, $file) = splitpath($self->{filename});
          if($path ne '' && !-e $path) {
              my $old_umask = umask($self->{mkpath_umask}) if defined $self->{mkpath_umask};
              my $options = {};
              foreach my $param (qw(owner group) ) {
                  $options->{$param} = $self->{$param} if defined $self->{$param};
              }
              eval {
                  mkpath($path,$options);
              };
              umask($old_umask) if defined $old_umask;
              die "Can't create path ${path} ($!)" if $@;
          }
      }
  
      my $old_umask = umask($self->{umask}) if defined $self->{umask};
  
      eval {
          if($self->{syswrite}) {
              sysopen $fh, "$self->{filename}", $sysmode or
                  die "Can't sysopen $self->{filename} ($!)";
          } else {
              open $fh, "$arrows$self->{filename}" or
                  die "Can't open $self->{filename} ($!)";
          }
      };
      umask($old_umask) if defined $old_umask;
      die $@ if $@;
  
      if($didnt_exist and
           ( defined $self->{owner} or defined $self->{group} )
        ) {
  
          eval { $self->perms_fix() };
  
          if($@) {
                # Cleanup and re-throw
              unlink $self->{filename};
              die $@;
          }
      }
  
      if($self->{recreate}) {
          $self->{watcher} = Log::Log4perl::Config::Watch->new(
              file           => $self->{filename},
              (defined $self->{recreate_check_interval} ?
                (check_interval => $self->{recreate_check_interval}) : ()),
              (defined $self->{recreate_check_signal} ?
                (signal => $self->{recreate_check_signal}) : ()),
          );
      }
  
      $self->{fh} = $fh;
  
      if ($self->{autoflush} and ! $self->{syswrite}) {
          my $oldfh = select $self->{fh};
          $| = 1;
          select $oldfh;
      }
  
      if (defined $self->{binmode}) {
          binmode $self->{fh}, $self->{binmode};
      }
  
      if (defined $self->{utf8}) {
          binmode $self->{fh}, ":utf8";
      }
  
      if(defined $self->{header_text}) {
          if( $self->{header_text} !~ /\n\Z/ ) {
              $self->{header_text} .= "\n";
          }
          my $fh = $self->{fh};
          print $fh $self->{header_text};
      }
  }
  
  ##################################################
  sub file_close {
  ##################################################
      my($self) = @_;
  
      if(defined $self->{fh}) {
          $self->close_with_care( $self->{ fh } );
      }
  
      undef $self->{fh};
  }
  
  ##################################################
  sub perms_fix {
  ##################################################
      my($self) = @_;
  
      my ($uid_org, $gid_org) = (stat $self->{filename})[4,5];
  
      my ($uid, $gid) = ($uid_org, $gid_org);
  
      if(!defined $uid) {
          die "stat of $self->{filename} failed ($!)";
      }
  
      my $needs_fixing = 0;
  
      if(defined $self->{owner}) {
          $uid = $self->{owner};
          if($self->{owner} !~ /^\d+$/) {
              $uid = (getpwnam($self->{owner}))[2];
              die "Unknown user: $self->{owner}" unless defined $uid;
          }
      }
  
      if(defined $self->{group}) {
          $gid = $self->{group};
          if($self->{group} !~ /^\d+$/) {
              $gid = getgrnam($self->{group});
  
              die "Unknown group: $self->{group}" unless defined $gid;
          }
      }
      if($uid != $uid_org or $gid != $gid_org) {
          chown($uid, $gid, $self->{filename}) or
              die "chown('$uid', '$gid') on '$self->{filename}' failed: $!";
      }
  }
  
  ##################################################
  sub file_switch {
  ##################################################
      my($self, $new_filename) = @_;
  
      print "Switching file from $self->{filename} to $new_filename\n" if
          _INTERNAL_DEBUG;
  
      $self->file_close();
      $self->{filename} = $new_filename;
      $self->file_open();
  }
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      if($self->{recreate}) {
          if($self->{recreate_check_signal}) {
              if(!$self->{watcher} or
                 $self->{watcher}->{signal_caught}) {
                  $self->file_switch($self->{filename});
                  $self->{watcher}->{signal_caught} = 0;
              }
          } else {
              if(!$self->{watcher} or
                  $self->{watcher}->file_has_moved()) {
                  $self->file_switch($self->{filename});
              }
          }
      }
  
      my $fh = $self->{fh};
  
      if($self->{syswrite}) {
         defined (syswrite $fh, $params{message}) or
             die "Cannot syswrite to '$self->{filename}': $!";
      } else {
          print $fh $params{message} or
              die "Cannot write to '$self->{filename}': $!";
      }
  }
  
  ##################################################
  sub DESTROY {
  ##################################################
      my($self) = @_;
  
      if ($self->{fh}) {
          my $fh = $self->{fh};
          $self->close_with_care( $fh );
      }
  }
  
  ###########################################
  sub close_with_care {
  ###########################################
      my( $self, $fh ) = @_;
  
      my $prev_rc = $?;
  
      my $rc = close $fh;
  
        # [rt #84723] If a sig handler is reaping the child generated
        # by close() internally before close() gets to it, it'll
        # result in a weird (but benign) error that we don't want to
        # expose to the user.
      if( !$rc ) {
          if( $self->{ mode } eq "pipe" and
              $!{ ECHILD } ) {
              if( $Log::Log4perl::CHATTY_DESTROY_METHODS ) {
                  warn "$$: pipe closed with ECHILD error -- guess that's ok";
              }
              $? = $prev_rc;
          } else {
              warn "Can't close $self->{filename} ($!)";
          }
      }
  
      return $rc;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::File - Log to file
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Appender::File;
  
      my $app = Log::Log4perl::Appender::File->new(
        filename  => 'file.log',
        mode      => 'append',
        autoflush => 1,
        umask     => 0222,
      );
  
      $file->log(message => "Log me\n");
  
  =head1 DESCRIPTION
  
  This is a simple appender for writing to a file.
  
  The C<log()> method takes a single scalar. If a newline character
  should terminate the message, it has to be added explicitly.
  
  Upon destruction of the object, the filehandle to access the
  file is flushed and closed.
  
  If you want to switch over to a different logfile, use the
  C<file_switch($newfile)> method which will first close the old
  file handle and then open a one to the new file specified.
  
  =head2 OPTIONS
  
  =over 4
  
  =item filename
  
  Name of the log file.
  
  =item mode
  
  Messages will be append to the file if C<$mode> is set to the
  string C<"append">. Will clobber the file
  if set to C<"clobber">. If it is C<"pipe">, the file will be understood
  as executable to pipe output to. Default mode is C<"append">.
  
  =item autoflush
  
  C<autoflush>, if set to a true value, triggers flushing the data
  out to the file on every call to C<log()>. C<autoflush> is on by default.
  
  =item syswrite
  
  C<syswrite>, if set to a true value, makes sure that the appender uses
  syswrite() instead of print() to log the message. C<syswrite()> usually
  maps to the operating system's C<write()> function and makes sure that
  no other process writes to the same log file while C<write()> is busy.
  Might safe you from having to use other synchronisation measures like
  semaphores (see: Synchronized appender).
  
  =item umask
  
  Specifies the C<umask> to use when creating the file, determining
  the file's permission settings.
  If set to C<0022> (default), new
  files will be created with C<rw-r--r--> permissions.
  If set to C<0000>, new files will be created with C<rw-rw-rw-> permissions.
  
  =item owner
  
  If set, specifies that the owner of the newly created log file should
  be different from the effective user id of the running process.
  Only makes sense if the process is running as root.
  Both numerical user ids and user names are acceptable.
  Log4perl does not attempt to change the ownership of I<existing> files.
  
  =item group
  
  If set, specifies that the group of the newly created log file should
  be different from the effective group id of the running process.
  Only makes sense if the process is running as root.
  Both numerical group ids and group names are acceptable.
  Log4perl does not attempt to change the group membership of I<existing> files.
  
  =item utf8
  
  If you're printing out Unicode strings, the output filehandle needs
  to be set into C<:utf8> mode:
  
      my $app = Log::Log4perl::Appender::File->new(
        filename  => 'file.log',
        mode      => 'append',
        utf8      => 1,
      );
  
  =item binmode
  
  To manipulate the output filehandle via C<binmode()>, use the
  binmode parameter:
  
      my $app = Log::Log4perl::Appender::File->new(
        filename  => 'file.log',
        mode      => 'append',
        binmode   => ":utf8",
      );
  
  A setting of ":utf8" for C<binmode> is equivalent to specifying
  the C<utf8> option (see above).
  
  =item recreate
  
  Normally, if a file appender logs to a file and the file gets moved to
  a different location (e.g. via C<mv>), the appender's open file handle
  will automatically follow the file to the new location.
  
  This may be undesirable. When using an external logfile rotator,
  for example, the appender should create a new file under the old name
  and start logging into it. If the C<recreate> option is set to a true value,
  C<Log::Log4perl::Appender::File> will do exactly that. It defaults to
  false. Check the C<recreate_check_interval> option for performance
  optimizations with this feature.
  
  =item recreate_check_interval
  
  In C<recreate> mode, the appender has to continuously check if the
  file it is logging to is still in the same location. This check is
  fairly expensive, since it has to call C<stat> on the file name and
  figure out if its inode has changed. Doing this with every call
  to C<log> can be prohibitively expensive. Setting it to a positive
  integer value N will only check the file every N seconds. It defaults to 30.
  
  This obviously means that the appender will continue writing to
  a moved file until the next check occurs, in the worst case
  this will happen C<recreate_check_interval> seconds after the file
  has been moved or deleted. If this is undesirable,
  setting C<recreate_check_interval> to 0 will have the
  appender check the file with I<every> call to C<log()>.
  
  =item recreate_check_signal
  
  In C<recreate> mode, if this option is set to a signal name
  (e.g. "USR1"), the appender will recreate a missing logfile
  when it receives the signal. It uses less resources than constant
  polling. The usual limitation with perl's signal handling apply.
  Check the FAQ for using this option with the log rotating
  utility C<newsyslog>.
  
  =item recreate_pid_write
  
  The popular log rotating utility C<newsyslog> expects a pid file
  in order to send the application a signal when its logs have
  been rotated. This option expects a path to a file where the pid
  of the currently running application gets written to.
  Check the FAQ for using this option with the log rotating
  utility C<newsyslog>.
  
  =item create_at_logtime
  
  The file appender typically creates its logfile in its constructor, i.e.
  at Log4perl C<init()> time. This is desirable for most use cases, because
  it makes sure that file permission problems get detected right away, and
  not after days/weeks/months of operation when the appender suddenly needs
  to log something and fails because of a problem that was obvious at
  startup.
  
  However, there are rare use cases where the file shouldn't be created
  at Log4perl C<init()> time, e.g. if the appender can't be used by the current
  user although it is defined in the configuration file. If you set
  C<create_at_logtime> to a true value, the file appender will try to create
  the file at log time. Note that this setting lets permission problems
  sit undetected until log time, which might be undesirable.
  
  =item header_text
  
  If you want Log4perl to print a header into every newly opened
  (or re-opened) logfile, set C<header_text> to either a string
  or a subroutine returning a string. If the message doesn't have a newline,
  a newline at the end of the header will be provided.
  
  =item mkpath
  
  If this this option is set to true,
  the directory path will be created if it does not exist yet.
  
  =item mkpath_umask
  
  Specifies the C<umask> to use when creating the directory, determining
  the directory's permission settings.
  If set to C<0022> (default), new
  directory will be created with C<rwxr-xr-x> permissions.
  If set to C<0000>, new directory will be created with C<rwxrwxrwx> permissions.
  
  =back
  
  Design and implementation of this module has been greatly inspired by
  Dave Rolsky's C<Log::Dispatch> appender framework.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt>
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches):
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull,
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter,
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope,
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_FILE

$fatpacked{"Log/Log4perl/Appender/Limit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_LIMIT';
  ######################################################################
  # Limit.pm -- 2003, Mike Schilli <m@perlmeister.com>
  ######################################################################
  # Special composite appender limiting the number of messages relayed
  # to its appender(s).
  ######################################################################
  
  ###########################################
  package Log::Log4perl::Appender::Limit;
  ###########################################
  
  use strict;
  use warnings;
  use Storable;
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  our $CVSVERSION   = '$Revision: 1.7 $';
  our ($VERSION)    = ($CVSVERSION =~ /(\d+\.\d+)/);
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = {
          max_until_flushed   => undef,
          max_until_discarded => undef,
          appender_method_on_flush 
                              => undef,
          appender            => undef,
          accumulate          => 1,
          persistent          => undef,
          block_period        => 3600,
          buffer              => [],
          %options,
      };
  
          # Pass back the appender to be limited as a dependency
          # to the configuration file parser
      push @{$options{l4p_depends_on}}, $self->{appender};
  
          # Run our post_init method in the configurator after
          # all appenders have been defined to make sure the
          # appenders we're connecting to really exist.
      push @{$options{l4p_post_config_subs}}, sub { $self->post_init() };
  
      bless $self, $class;
  
      if(defined $self->{persistent}) {
          $self->restore();
      }
  
      return $self;
  }
  
  ###########################################
  sub log {
  ###########################################
      my($self, %params) = @_;
      
      local $Log::Log4perl::caller_depth =
          $Log::Log4perl::caller_depth + 2;
  
          # Check if message needs to be discarded
      my $discard = 0;
      if(defined $self->{max_until_discarded} and
         scalar @{$self->{buffer}} >= $self->{max_until_discarded} - 1) {
          $discard = 1;
      }
  
          # Check if we need to flush
      my $flush = 0;
      if(defined $self->{max_until_flushed} and
         scalar @{$self->{buffer}} >= $self->{max_until_flushed} - 1) {
          $flush = 1;
      }
  
      if(!$flush and
         (exists $self->{sent_last} and
          $self->{sent_last} + $self->{block_period} > time()
         )
        ) {
              # Message needs to be blocked for now.
          return if $discard;
  
              # Ask the appender to save a cached message in $cache
          $self->{app}->SUPER::log(\%params,
                               $params{log4p_category},
                               $params{log4p_level}, \my $cache);
  
              # Save message and other parameters
          push @{$self->{buffer}}, $cache if $self->{accumulate};
  
          $self->save() if $self->{persistent};
  
          return;
      }
  
      # Relay all messages we got to the SUPER class, which needs to render the
      # messages according to the appender's layout, first.
  
          # Log pending messages if we have any
      $self->flush();
  
          # Log current message as well
      $self->{app}->SUPER::log(\%params,
                               $params{log4p_category},
                               $params{log4p_level});
  
      $self->{sent_last} = time();
  
          # We need to store the timestamp persistently, if requested
      $self->save() if $self->{persistent};
  }
  
  ###########################################
  sub post_init {
  ###########################################
      my($self) = @_;
  
      if(! exists $self->{appender}) {
         die "No appender defined for " . __PACKAGE__;
      }
  
      my $appenders = Log::Log4perl->appenders();
      my $appender = Log::Log4perl->appenders()->{$self->{appender}};
  
      if(! defined $appender) {
         die "Appender $self->{appender} not defined (yet) when " .
             __PACKAGE__ . " needed it";
      }
  
      $self->{app} = $appender;
  }
  
  ###########################################
  sub save {
  ###########################################
      my($self) = @_;
  
      my $pdata = [$self->{buffer}, $self->{sent_last}];
  
          # Save the buffer if we're in persistent mode
      store $pdata, $self->{persistent} or
          die "Cannot save messages in $self->{persistent} ($!)";
  }
  
  ###########################################
  sub restore {
  ###########################################
      my($self) = @_;
  
      if(-f $self->{persistent}) {
          my $pdata = retrieve $self->{persistent} or
              die "Cannot retrieve messages from $self->{persistent} ($!)";
          ($self->{buffer}, $self->{sent_last}) = @$pdata;
      }
  }
  
  ###########################################
  sub flush {
  ###########################################
      my($self) = @_;
  
          # Log pending messages if we have any
      for(@{$self->{buffer}}) {
          $self->{app}->SUPER::log_cached($_);
      }
  
        # call flush() on the attached appender if so desired.
      if( $self->{appender_method_on_flush} ) {
          no strict 'refs';
          my $method = $self->{appender_method_on_flush};
          $self->{app}->$method();
      }
  
          # Empty buffer
      $self->{buffer} = [];
  }
  
  ###########################################
  sub DESTROY {
  ###########################################
      my($self) = @_;
  
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
      Log::Log4perl::Appender::Limit - Limit message delivery via block period
  
  =head1 SYNOPSIS
  
      use Log::Log4perl qw(:easy);
  
      my $conf = qq(
        log4perl.category = WARN, Limiter
      
            # Email appender
        log4perl.appender.Mailer          = Log::Dispatch::Email::MailSend
        log4perl.appender.Mailer.to       = drone\@pageme.com
        log4perl.appender.Mailer.subject  = Something's broken!
        log4perl.appender.Mailer.buffered = 0
        log4perl.appender.Mailer.layout   = PatternLayout
        log4perl.appender.Mailer.layout.ConversionPattern=%d %m %n
  
            # Limiting appender, using the email appender above
        log4perl.appender.Limiter              = Log::Log4perl::Appender::Limit
        log4perl.appender.Limiter.appender     = Mailer
        log4perl.appender.Limiter.block_period = 3600
      );
  
      Log::Log4perl->init(\$conf);
      WARN("This message will be sent immediately.");
      WARN("This message will be delayed by one hour.");
      sleep(3601);
      WARN("This message plus the last one will be sent now, seperately.");
  
  =head1 DESCRIPTION
  
  =over 4
  
  =item C<appender>
  
  Specifies the name of the appender used by the limiter. The
  appender specified must be defined somewhere in the configuration file,
  not necessarily before the definition of 
  C<Log::Log4perl::Appender::Limit>.
  
  =item C<block_period>
  
  Period in seconds between delivery of messages. If messages arrive in between,
  they will be either saved (if C<accumulate> is set to a true value) or
  discarded (if C<accumulate> isn't set).
  
  =item C<persistent>
  
  File name in which C<Log::Log4perl::Appender::Limit> persistently stores 
  delivery times. If omitted, the appender will have no recollection of what
  happened when the program restarts.
  
  =item C<max_until_flushed>
  
  Maximum number of accumulated messages. If exceeded, the appender flushes 
  all messages, regardless if the interval set in C<block_period> 
  has passed or not. Don't mix with C<max_until_discarded>.
  
  =item C<max_until_discarded>
  
  Maximum number of accumulated messages. If exceeded, the appender will
  simply discard additional messages, waiting for C<block_period> to expire
  to flush all accumulated messages. Don't mix with C<max_until_flushed>.
  
  =item C<appender_method_on_flush>
  
  Optional method name to be called on the appender attached to the
  limiter when messages are flushed. For example, to have the sample code 
  in the SYNOPSIS section bundle buffered emails into one, change the 
  mailer's C<buffered> parameter to C<1> and set the limiters 
  C<appender_method_on_flush> value to the string C<"flush">:
  
        log4perl.category = WARN, Limiter
      
            # Email appender
        log4perl.appender.Mailer          = Log::Dispatch::Email::MailSend
        log4perl.appender.Mailer.to       = drone\@pageme.com
        log4perl.appender.Mailer.subject  = Something's broken!
        log4perl.appender.Mailer.buffered = 1
        log4perl.appender.Mailer.layout   = PatternLayout
        log4perl.appender.Mailer.layout.ConversionPattern=%d %m %n
  
            # Limiting appender, using the email appender above
        log4perl.appender.Limiter              = Log::Log4perl::Appender::Limit
        log4perl.appender.Limiter.appender     = Mailer
        log4perl.appender.Limiter.block_period = 3600
        log4perl.appender.Limiter.appender_method_on_flush = flush
  
  This will cause the mailer to buffer messages and wait for C<flush()>
  to send out the whole batch. The limiter will then call the appender's
  C<flush()> method when it's own buffer gets flushed out.
  
  =back
  
  If the appender attached to C<Limit> uses C<PatternLayout> with a timestamp
  specifier, you will notice that the message timestamps are reflecting the
  original log event, not the time of the message rendering in the
  attached appender. Major trickery has been applied to accomplish 
  this (Cough!).
  
  =head1 DEVELOPMENT NOTES
  
  C<Log::Log4perl::Appender::Limit> is a I<composite> appender.
  Unlike other appenders, it doesn't log any messages, it just
  passes them on to its attached sub-appender.
  For this reason, it doesn't need a layout (contrary to regular appenders).
  If it defines none, messages are passed on unaltered.
  
  Custom filters are also applied to the composite appender only.
  They are I<not> applied to the sub-appender. Same applies to appender
  thresholds. This behaviour might change in the future.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_LIMIT

$fatpacked{"Log/Log4perl/Appender/RRDs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_RRDS';
  ##################################################
  package Log::Log4perl::Appender::RRDs;
  ##################################################
  our @ISA = qw(Log::Log4perl::Appender);
  
  use warnings;
  use strict;
  use RRDs;
  
  ##################################################
  sub new {
  ##################################################
      my($class, @options) = @_;
  
      my $self = {
          name             => "unknown name",
          dbname           => undef,
          rrdupd_params => [],
          @options,
      };
  
      die "Mandatory parameter 'dbname' missing" unless
          defined $self->{dbname};
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      #print "UPDATE: '$self->{dbname}' - '$params{message}'\n";
  
      RRDs::update($self->{dbname}, 
                   @{$params{rrdupd_params}},
                   $params{message}) or
          die "Cannot update rrd $self->{dbname} ",
              "with $params{message} ($!)";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::RRDs - Log to a RRDtool Archive
      
  =head1 SYNOPSIS
      
      use Log::Log4perl qw(get_logger);
      use RRDs;
      
      my $DB = "myrrddb.dat";
      
      RRDs::create(
        $DB, "--step=1",
        "DS:myvalue:GAUGE:2:U:U",
        "RRA:MAX:0.5:1:120");
      
      print time(), "\n";
      
      Log::Log4perl->init(\qq{
        log4perl.category = INFO, RRDapp
        log4perl.appender.RRDapp = Log::Log4perl::Appender::RRDs
        log4perl.appender.RRDapp.dbname = $DB
        log4perl.appender.RRDapp.layout = Log::Log4perl::Layout::PatternLayout
        log4perl.appender.RRDapp.layout.ConversionPattern = N:%m
      });
      
      my $logger = get_logger();
      
      for(10, 15, 20, 25) {
          $logger->info($_);
          sleep 1;
      }
     
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Appender::RRDs> appenders facilitate writing data
  to RRDtool round-robin archives via Log4perl. For documentation
  on RRD and its Perl interface C<RRDs> (which comes with the distribution),
  check out L<http://rrdtool.org>.
  
  Messages sent to Log4perl's RRDs appender are expected to be numerical values
  (ints or floats), which then are used to run a C<rrdtool update> command
  on an existing round-robin database. The name of this database needs to
  be set in the appender's C<dbname> configuration parameter.
  
  If there's more parameters you wish to pass to the C<update> method,
  use the C<rrdupd_params> configuration parameter:
  
      log4perl.appender.RRDapp.rrdupd_params = --template=in:out
  
  To read out the round robin database later on, use C<rrdtool fetch>
  or C<rrdtool graph> for graphic displays.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_RRDS

$fatpacked{"Log/Log4perl/Appender/Screen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SCREEN';
  ##################################################
  package Log::Log4perl::Appender::Screen;
  ##################################################
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  use warnings;
  use strict;
  
  ##################################################
  sub new {
  ##################################################
      my($class, @options) = @_;
  
      my $self = {
          name   => "unknown name",
          stderr => 1,
          utf8   => undef,
          @options,
      };
  
      if( $self->{utf8} ) {
          if( $self->{stderr} ) {
              binmode STDERR, ":utf8";
          } else {
              binmode STDOUT, ":utf8";
          }
      }
  
      bless $self, $class;
  }
      
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      if($self->{stderr}) {
          print STDERR $params{message};
      } else {
          print $params{message};
      }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::Screen - Log to STDOUT/STDERR
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Appender::Screen;
  
      my $app = Log::Log4perl::Appender::Screen->new(
        stderr    => 0,
        utf8      => 1,
      );
  
      $file->log(message => "Log me\n");
  
  =head1 DESCRIPTION
  
  This is a simple appender for writing to STDOUT or STDERR.
  
  The constructor C<new()> take an optional parameter C<stderr>,
  if set to a true value, the appender will log to STDERR. 
  The default setting for C<stderr> is 1, so messages will be logged to 
  STDERR by default.
  
  If C<stderr>
  is set to a false value, it will log to STDOUT (or, more accurately,
  whichever file handle is selected via C<select()>, STDOUT by default). 
  
  Design and implementation of this module has been greatly inspired by
  Dave Rolsky's C<Log::Dispatch> appender framework.
  
  To enable printing wide utf8 characters, set the utf8 option to a true
  value:
  
      my $app = Log::Log4perl::Appender::Screen->new(
        stderr    => 1,
        utf8      => 1,
      );
  
  This will issue the necessary binmode command to the selected output
  channel (stderr/stdout).
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_SCREEN

$fatpacked{"Log/Log4perl/Appender/ScreenColoredLevels.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SCREENCOLOREDLEVELS';
  ##################################################
  package Log::Log4perl::Appender::ScreenColoredLevels;
  ##################################################
  use Log::Log4perl::Appender::Screen;
  our @ISA = qw(Log::Log4perl::Appender::Screen);
  
  use warnings;
  use strict;
  
  use Term::ANSIColor qw();
  use Log::Log4perl::Level;
  
  BEGIN {
      $Term::ANSIColor::EACHLINE="\n";
  }
  
  ##################################################
  sub new {
  ##################################################
      my($class, %options) = @_;
  
      my %specific_options = ( color => {} );
  
      for my $option ( keys %specific_options ) {
          $specific_options{ $option } = delete $options{ $option } if
              exists $options{ $option };
      }
  
      my $self = $class->SUPER::new( %options );
      @$self{ keys %specific_options } = values %specific_options;
      bless $self, __PACKAGE__; # rebless
  
        # also accept lower/mixed case levels in config
      for my $level ( keys %{ $self->{color} } ) {
          my $uclevel = uc($level);
          $self->{color}->{$uclevel} = $self->{color}->{$level};
      }
  
      my %default_colors = (
          TRACE   => 'yellow',
          DEBUG   => '',
          INFO    => 'green',
          WARN    => 'blue',
          ERROR   => 'magenta',
          FATAL   => 'red',
      );
      for my $level ( keys %default_colors ) {
          if ( ! exists $self->{ 'color' }->{ $level } ) {
              $self->{ 'color' }->{ $level } = $default_colors{ $level };
          }
      }
  
      bless $self, $class;
  }
      
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      my $msg = $params{ 'message' };
  
      if ( my $color = $self->{ 'color' }->{ $params{ 'log4p_level' } } ) {
          $msg = Term::ANSIColor::colored( $msg, $color );
      }
      
      if($self->{stderr}) {
          print STDERR $msg;
      } else {
          print $msg;
      }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::ScreenColoredLevel - Colorize messages according to level
  
  =head1 SYNOPSIS
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init(\ <<'EOT');
        log4perl.category = DEBUG, Screen
        log4perl.appender.Screen = \
            Log::Log4perl::Appender::ScreenColoredLevels
        log4perl.appender.Screen.layout = \
            Log::Log4perl::Layout::PatternLayout
        log4perl.appender.Screen.layout.ConversionPattern = \
            %d %F{1} %L> %m %n
      EOT
  
        # Appears black
      DEBUG "Debug Message";
  
        # Appears green
      INFO  "Info Message";
  
        # Appears blue
      WARN  "Warn Message";
  
        # Appears magenta
      ERROR "Error Message";
  
        # Appears red
      FATAL "Fatal Message";
  
  =head1 DESCRIPTION
  
  This appender acts like Log::Log4perl::Appender::Screen, except that
  it colorizes its output, based on the priority of the message sent.
  
  You can configure the colors and attributes used for the different
  levels, by specifying them in your configuration:
  
      log4perl.appender.Screen.color.TRACE=cyan
      log4perl.appender.Screen.color.DEBUG=bold blue
  
  You can also specify nothing, to indicate that level should not have
  coloring applied, which means the text will be whatever the default
  color for your terminal is.  This is the default for debug messages.
  
      log4perl.appender.Screen.color.DEBUG=
  
  You can use any attribute supported by L<Term::ANSIColor> as a configuration
  option.
  
      log4perl.appender.Screen.color.FATAL=\
          bold underline blink red on_white
  
  The commonly used colors and attributes are:
  
  =over 4
  
  =item attributes
  
  BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK
  
  =item colors
  
  BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE
  
  =item background colors
  
  ON_BLACK, ON_RED, ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, ON_WHITE
  
  =back
  
  See L<Term::ANSIColor> for a complete list, and information on which are
  supported by various common terminal emulators.
  
  The default values for these options are:
  
  =over 4
  
  =item Trace
  
  Yellow
  
  =item Debug
  
  None (whatever the terminal default is)
  
  =item Info
  
  Green
  
  =item Warn
  
  Blue
  
  =item Error
  
  Magenta
  
  =item Fatal
  
  Red
  
  =back
  
  The constructor C<new()> takes an optional parameter C<stderr>,
  if set to a true value, the appender will log to STDERR. If C<stderr>
  is set to a false value, it will log to STDOUT. The default setting
  for C<stderr> is 1, so messages will be logged to STDERR by default.
  The constructor can also take an optional parameter C<color>, whose
  value is a  hashref of color configuration options, any levels that
  are not included in the hashref will be set to their default values.
  
  =head2 Using ScreenColoredLevels on Windows
  
  Note that if you're using this appender on Windows, you need to fetch
  Win32::Console::ANSI from CPAN and add
  
      use Win32::Console::ANSI;
  
  to your script.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_SCREENCOLOREDLEVELS

$fatpacked{"Log/Log4perl/Appender/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SOCKET';
  ##################################################
  package Log::Log4perl::Appender::Socket;
  ##################################################
  our @ISA = qw(Log::Log4perl::Appender);
  
  use warnings;
  use strict;
  
  use IO::Socket::INET;
  
  ##################################################
  sub new {
  ##################################################
      my($class, @options) = @_;
  
      my $self = {
          name            => "unknown name",
          silent_recovery => 0,
          no_warning      => 0,
          PeerAddr        => "localhost",
          Proto           => 'tcp',
          Timeout         => 5,
          @options,
      };
  
      bless $self, $class;
  
      unless ($self->{defer_connection}){
          unless($self->connect(@options)) {
              if($self->{silent_recovery}) {
                  if( ! $self->{no_warning}) {
                      warn "Connect to $self->{PeerAddr}:$self->{PeerPort} failed: $!";
                  }
                 return $self;
              }
              die "Connect to $self->{PeerAddr}:$self->{PeerPort} failed: $!";
          }
  
          $self->{socket}->autoflush(1); 
          #autoflush has been the default behavior since 1997
      }
  
      return $self;
  }
      
  ##################################################
  sub connect {
  ##################################################
      my($self, @options) = @_;
  
      $self->{socket} = IO::Socket::INET->new(@options);
  
      return $self->{socket};
  }
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
  
      {
              # If we were never able to establish
              # a connection, try to establish one 
              # here. If it fails, return.
          if(($self->{silent_recovery} or $self->{defer_connection}) and 
             !defined $self->{socket}) {
              if(! $self->connect(%$self)) {
                  return undef;
              }
          }
    
              # Try to send the message across
          eval { $self->{socket}->send($params{message}); 
               };
  
          if($@) {
              warn "Send to " . ref($self) . " failed ($@), retrying once...";
              if($self->connect(%$self)) {
                  redo;
              }
              if($self->{silent_recovery}) {
                  return undef;
              }
              warn "Reconnect to $self->{PeerAddr}:$self->{PeerPort} " .
                   "failed: $!";
              return undef;
          }
      };
  
      return 1;
  }
  
  ##################################################
  sub DESTROY {
  ##################################################
      my($self) = @_;
  
      undef $self->{socket};
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::Socket - Log to a socket
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Appender::Socket;
  
      my $appender = Log::Log4perl::Appender::Socket->new(
        PeerAddr => "server.foo.com",
        PeerPort => 1234,
      );
  
      $appender->log(message => "Log me\n");
  
  =head1 DESCRIPTION
  
  This is a simple appender for writing to a socket. It relies on
  L<IO::Socket::INET> and offers all parameters this module offers.
  
  Upon destruction of the object, pending messages will be flushed
  and the socket will be closed.
  
  If the appender cannot contact the server during the initialization
  phase (while running the constructor C<new>), it will C<die()>.
  
  If the appender fails to log a message because the socket's C<send()>
  method fails (most likely because the server went down), it will
  try to reconnect once. If it succeeds, the message will be sent.
  If the reconnect fails, a warning is sent to STDERR and the C<log()>
  method returns, discarding the message.
  
  If the option C<silent_recovery> is given to the constructor and
  set to a true value, the behaviour is different: If the socket connection
  can't be established at initialization time, a single warning is issued.
  Every log attempt will then try to establish the connection and 
  discard the message silently if it fails.
  If you don't even want the warning, set the C<no_warning> option to
  a true value.
  
  Connecting at initialization time may not be the best option when
  running under Apache1 Apache2/prefork, because the parent process creates
  the socket and the connections are shared among the forked children--all
  the children writing to the same socket could intermingle messages.  So instead
  of that, you can use C<defer_connection> which will put off making the
  connection until the first log message is sent.
  
  =head1 EXAMPLE
  
  Write a server quickly using the IO::Socket::INET module:
  
      use IO::Socket::INET;
  
      my $sock = IO::Socket::INET->new(
          Listen    => 5,
          LocalAddr => 'localhost',
          LocalPort => 12345,
          Proto     => 'tcp');
  
      while(my $client = $sock->accept()) {
          print "Client connected\n";
          while(<$client>) {
              print "$_\n";
          }
      }
  
  Start it and then run the following script as a client:
  
      use Log::Log4perl qw(:easy);
  
      my $conf = q{
          log4perl.category                  = WARN, Socket
          log4perl.appender.Socket           = Log::Log4perl::Appender::Socket
          log4perl.appender.Socket.PeerAddr  = localhost
          log4perl.appender.Socket.PeerPort  = 12345
          log4perl.appender.Socket.layout    = SimpleLayout
      };
  
      Log::Log4perl->init(\$conf);
  
      sleep(2);
  
      for(1..10) {
          ERROR("Quack!");
          sleep(5);
      }
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_SOCKET

$fatpacked{"Log/Log4perl/Appender/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_STRING';
  package Log::Log4perl::Appender::String;
  our @ISA = qw(Log::Log4perl::Appender);
  
  ##################################################
  # Log dispatcher writing to a string buffer
  ##################################################
  
  ##################################################
  sub new {
  ##################################################
      my $proto  = shift;
      my $class  = ref $proto || $proto;
      my %params = @_;
  
      my $self = {
          name      => "unknown name",
          string    => "",
          %params,
      };
  
      bless $self, $class;
  }
  
  ##################################################
  sub log {   
  ##################################################
      my $self = shift;
      my %params = @_;
  
      $self->{string} .= $params{message};
  }
  
  ##################################################
  sub string {   
  ##################################################
      my($self, $new) = @_;
  
      if(defined $new) {
          $self->{string} = $new;
      }
  
      return $self->{string};
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::String - Append to a string
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Appender::String;
  
    my $appender = Log::Log4perl::Appender::String->new( 
        name      => 'my string appender',
    );
  
        # Append to the string
    $appender->log( 
        message => "I'm searching the city for sci-fi wasabi\n" 
    );
  
        # Retrieve the result
    my $result = $appender->string();
  
        # Reset the buffer to the empty string
    $appender->string("");
  
  =head1 DESCRIPTION
  
  This is a simple appender used internally by C<Log::Log4perl>. It
  appends messages to a scalar instance variable.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_STRING

$fatpacked{"Log/Log4perl/Appender/Synchronized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_SYNCHRONIZED';
  ######################################################################
  # Synchronized.pm -- 2003, 2007 Mike Schilli <m@perlmeister.com>
  ######################################################################
  # Special appender employing a locking strategy to synchronize
  # access.
  ######################################################################
  
  ###########################################
  package Log::Log4perl::Appender::Synchronized;
  ###########################################
  
  use strict;
  use warnings;
  use Log::Log4perl::Util::Semaphore;
  
  our @ISA = qw(Log::Log4perl::Appender);
  
  our $CVSVERSION   = '$Revision: 1.12 $';
  our ($VERSION)    = ($CVSVERSION =~ /(\d+\.\d+)/);
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = {
          appender=> undef,
          key     => '_l4p',
          level   => 0,
          %options,
      };
  
      my @values = ();
      for my $param (qw(uid gid mode destroy key)) {
          push @values, $param, $self->{$param} if defined $self->{$param};
      }
  
      $self->{sem} = Log::Log4perl::Util::Semaphore->new(
          @values
      );
  
          # Pass back the appender to be synchronized as a dependency
          # to the configuration file parser
      push @{$options{l4p_depends_on}}, $self->{appender};
  
          # Run our post_init method in the configurator after
          # all appenders have been defined to make sure the
          # appender we're synchronizing really exists
      push @{$options{l4p_post_config_subs}}, sub { $self->post_init() };
  
      bless $self, $class;
  }
  
  ###########################################
  sub log {
  ###########################################
      my($self, %params) = @_;
      
      $self->{sem}->semlock();
  
      # Relay that to the SUPER class which needs to render the
      # message according to the appender's layout, first.
      $Log::Log4perl::caller_depth +=2;
      $self->{app}->SUPER::log(\%params, 
                               $params{log4p_category},
                               $params{log4p_level});
      $Log::Log4perl::caller_depth -=2;
  
      $self->{sem}->semunlock();
  }
  
  ###########################################
  sub post_init {
  ###########################################
      my($self) = @_;
  
      if(! exists $self->{appender}) {
         die "No appender defined for " . __PACKAGE__;
      }
  
      my $appenders = Log::Log4perl->appenders();
      my $appender = Log::Log4perl->appenders()->{$self->{appender}};
  
      if(! defined $appender) {
         die "Appender $self->{appender} not defined (yet) when " .
             __PACKAGE__ . " needed it";
      }
  
      $self->{app} = $appender;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
      Log::Log4perl::Appender::Synchronized - Synchronizing other appenders
  
  =head1 SYNOPSIS
  
      use Log::Log4perl qw(:easy);
  
      my $conf = qq(
      log4perl.category                   = WARN, Syncer
      
          # File appender (unsynchronized)
      log4perl.appender.Logfile           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.autoflush = 1
      log4perl.appender.Logfile.filename  = test.log
      log4perl.appender.Logfile.mode      = truncate
      log4perl.appender.Logfile.layout    = SimpleLayout
      
          # Synchronizing appender, using the file appender above
      log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer.appender   = Logfile
  );
  
      Log::Log4perl->init(\$conf);
      WARN("This message is guaranteed to be complete.");
  
  =head1 DESCRIPTION
  
  If multiple processes are using the same C<Log::Log4perl> appender 
  without synchronization, overwrites might happen. A typical scenario
  for this would be a process spawning children, each of which inherits
  the parent's Log::Log4perl configuration.
  
  In most cases, you won't need an external synchronisation tool like
  Log::Log4perl::Appender::Synchronized at all. Log4perl's file appender, 
  Log::Log4perl::Appender::File, for example, provides the C<syswrite>
  mechanism for making sure that even long log lines won't interleave.
  Short log lines won't interleave anyway, because the operating system
  makes sure the line gets written before a task switch occurs.
  
  In cases where you need additional synchronization, however, you can use
  C<Log::Log4perl::Appender::Synchronized> as a gateway between your
  loggers and your appenders. An appender itself, 
  C<Log::Log4perl::Appender::Synchronized> just takes two additional
  arguments:
  
  =over 4
  
  =item C<appender>
  
  Specifies the name of the appender it synchronizes access to. The
  appender specified must be defined somewhere in the configuration file,
  not necessarily before the definition of 
  C<Log::Log4perl::Appender::Synchronized>.
  
  =item C<key>
  
  This optional argument specifies the key for the semaphore that
  C<Log::Log4perl::Appender::Synchronized> uses internally to ensure
  atomic operations. It defaults to C<_l4p>. If you define more than
  one C<Log::Log4perl::Appender::Synchronized> appender, it is 
  important to specify different keys for them, as otherwise every
  new C<Log::Log4perl::Appender::Synchronized> appender will nuke
  previously defined semaphores. The maximum key length is four
  characters, longer keys will be truncated to 4 characters -- 
  C<mylongkey1> and C<mylongkey2> are interpreted to be the same:
  C<mylo> (thanks to David Viner E<lt>dviner@yahoo-inc.comE<gt> for
  pointing this out).
  
  =back
  
  C<Log::Log4perl::Appender::Synchronized> uses Log::Log4perl::Util::Semaphore
  internally to perform locking with semaphores provided by the
  operating system used.
  
  =head2 Performance tips
  
  The C<Log::Log4perl::Appender::Synchronized> serializes access to a
  protected resource globally, slowing down actions otherwise performed in
  parallel.
  
  Unless specified otherwise, all instances of 
  C<Log::Log4perl::Appender::Synchronized> objects in the system will
  use the same global IPC key C<_l4p>.
  
  To control access to different appender instances, it often makes sense
  to define different keys for different synchronizing appenders. In this
  way, Log::Log4perl serializes access to each appender instance separately:
  
      log4perl.category                   = WARN, Syncer1, Syncer2
      
          # File appender 1 (unsynchronized)
      log4perl.appender.Logfile1           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile1.filename  = test1.log
      log4perl.appender.Logfile1.layout    = SimpleLayout
      
          # File appender 2 (unsynchronized)
      log4perl.appender.Logfile2           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile2.filename  = test2.log
      log4perl.appender.Logfile2.layout    = SimpleLayout
      
          # Synchronizing appender, using the file appender above
      log4perl.appender.Syncer1            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer1.appender   = Logfile1
      log4perl.appender.Syncer1.key        = l4p1
  
          # Synchronizing appender, using the file appender above
      log4perl.appender.Syncer2            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer2.appender   = Logfile2
      log4perl.appender.Syncer2.key        = l4p2
  
  Without the C<.key = l4p1> and C<.key = l4p2> lines, both Synchronized 
  appenders would be using the default C<_l4p> key, causing unnecessary
  serialization of output written to different files.
  
  =head2 Advanced configuration
  
  To configure the underlying Log::Log4perl::Util::Semaphore module in 
  a different way than with the default settings provided by 
  Log::Log4perl::Appender::Synchronized, use the following parameters:
  
      log4perl.appender.Syncer1.destroy  = 1
      log4perl.appender.Syncer1.mode     = sub { 0775 }
      log4perl.appender.Syncer1.uid      = hugo
      log4perl.appender.Syncer1.gid      = 100
  
  Valid options are 
  C<destroy> (Remove the semaphore on exit), 
  C<mode> (permissions on the semaphore), 
  C<uid> (uid or user name the semaphore is owned by), 
  and
  C<gid> (group id the semaphore is owned by), 
  
  Note that C<mode> is usually given in octal and therefore needs to be
  specified as a perl sub {}, unless you want to calculate what 0755 means
  in decimal.
  
  Changing ownership or group settings for a semaphore will obviously only
  work if the current user ID owns the semaphore already or if the current
  user is C<root>. The C<destroy> option causes the current process to 
  destroy the semaphore on exit. Spawned children of the process won't
  inherit this behavior.
  
  =head2 Semaphore user and group IDs with mod_perl
  
  Setting user and group IDs is especially important when the Synchronized
  appender is used with mod_perl. If Log4perl gets initialized by a startup
  handler, which runs as root, and not as the user who will later use
  the semaphore, the settings for uid, gid, and mode can help establish 
  matching semaphore ownership and access rights.
  
  =head1 DEVELOPMENT NOTES
  
  C<Log::Log4perl::Appender::Synchronized> is a I<composite> appender.
  Unlike other appenders, it doesn't log any messages, it just
  passes them on to its attached sub-appender.
  For this reason, it doesn't need a layout (contrary to regular appenders).
  If it defines none, messages are passed on unaltered.
  
  Custom filters are also applied to the composite appender only.
  They are I<not> applied to the sub-appender. Same applies to appender
  thresholds. This behaviour might change in the future.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_SYNCHRONIZED

$fatpacked{"Log/Log4perl/Appender/TestArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTARRAYBUFFER';
  ##################################################
  package Log::Log4perl::Appender::TestArrayBuffer;
  ##################################################
  # Like Log::Log4perl::Appender::TestBuffer, just with 
  # array capability.
  # For testing only.
  ##################################################
  
  use base qw( Log::Log4perl::Appender::TestBuffer );
  
  ##################################################
  sub log {   
  ##################################################
      my $self = shift;
      my %params = @_;
  
      $self->{buffer} .= "[$params{level}]: " if $LOG_PRIORITY;
  
      if(ref($params{message}) eq "ARRAY") {
          $self->{buffer} .= "[" . join(',', @{$params{message}}) . "]";
      } else {
          $self->{buffer} .= $params{message};
      }
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::TestArrayBuffer - Subclass of Appender::TestBuffer
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Appender::TestArrayBuffer;
  
    my $appender = Log::Log4perl::Appender::TestArrayBuffer->new( 
        name      => 'buffer',
    );
  
        # Append to the buffer
    $appender->log( 
        level =  > 'alert', 
        message => ['first', 'second', 'third'],
    );
  
        # Retrieve the result
    my $result = $appender->buffer();
  
        # Reset the buffer to the empty string
    $appender->reset();
  
  =head1 DESCRIPTION
  
  This class is a subclass of Log::Log4perl::Appender::TestBuffer and
  just provides message array refs as an additional feature. 
  
  Just like Log::Log4perl::Appender::TestBuffer, 
  Log::Log4perl::Appender::TestArrayBuffer is used for internal
  Log::Log4perl testing only.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_TESTARRAYBUFFER

$fatpacked{"Log/Log4perl/Appender/TestBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTBUFFER';
  package Log::Log4perl::Appender::TestBuffer;
  our @ISA = qw(Log::Log4perl::Appender);
  
  ##################################################
  # Log dispatcher writing to a string buffer
  # For testing.
  # This is like having a Log::Log4perl::Appender::TestBuffer
  ##################################################
  
  our %POPULATION       = ();
  our $LOG_PRIORITY     = 0;
  our $DESTROY_MESSAGES = "";
  
  ##################################################
  sub new {
  ##################################################
      my $proto  = shift;
      my $class  = ref $proto || $proto;
      my %params = @_;
  
      my $self = {
          name      => "unknown name",
          %params,
      };
  
      bless $self, $class;
  
      $self->{stderr} = exists $params{stderr} ? $params{stderr} : 1;
      $self->{buffer} = "";
  
      $POPULATION{$self->{name}} = $self;
  
      return $self;
  }
  
  ##################################################
  sub log {   
  ##################################################
      my $self = shift;
      my %params = @_;
  
      if( !defined $params{level} ) {
          die "No level defined in log() call of " . __PACKAGE__;
      }
      $self->{buffer} .= "[$params{level}]: " if $LOG_PRIORITY;
      $self->{buffer} .= $params{message};
  }
  
  ###########################################
  sub clear {
  ###########################################
      my($self) = @_;
  
      $self->{buffer} = "";
  }
  
  ##################################################
  sub buffer {   
  ##################################################
      my($self, $new) = @_;
  
      if(defined $new) {
          $self->{buffer} = $new;
      }
  
      return $self->{buffer};
  }
  
  ##################################################
  sub reset {   
  ##################################################
      my($self) = @_;
  
      %POPULATION = ();
      $self->{buffer} = "";
  }
  
  ##################################################
  sub DESTROY {   
  ##################################################
      my($self) = @_;
  
      $DESTROY_MESSAGES .= __PACKAGE__ . " destroyed";
  
      #this delete() along with &reset() above was causing
      #Attempt to free unreferenced scalar at 
      #blib/lib/Log/Log4perl/TestBuffer.pm line 69.
      #delete $POPULATION{$self->name};
  }
  
  ##################################################
  sub by_name {   
  ##################################################
      my($self, $name) = @_;
  
      # Return a TestBuffer by appender name. This is useful if
      # test buffers are created behind our back (e.g. via the
      # Log4perl config file) and later on we want to 
      # retrieve an instance to query its content.
  
      die "No name given"  unless defined $name;
  
      return $POPULATION{$name};
  
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::TestBuffer - Appender class for testing
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Appender::TestBuffer;
  
    my $appender = Log::Log4perl::Appender::TestBuffer->new( 
        name      => 'mybuffer',
    );
  
        # Append to the buffer
    $appender->log( 
        level =  > 'alert', 
        message => "I'm searching the city for sci-fi wasabi\n" 
    );
  
        # Retrieve the result
    my $result = $appender->buffer();
  
        # Clear the buffer to the empty string
    $appender->clear();
  
  =head1 DESCRIPTION
  
  This class is used for internal testing of C<Log::Log4perl>. It
  is a C<Log::Dispatch>-style appender, which writes to a buffer 
  in memory, from where actual results can be easily retrieved later
  to compare with expected results.
  
  Every buffer created is stored in an internal global array, and can
  later be referenced by name:
  
      my $app = Log::Log4perl::Appender::TestBuffer->by_name("mybuffer");
  
  retrieves the appender object of a previously created buffer "mybuffer".
  To reset this global array and have it forget all of the previously 
  created testbuffer appenders (external references to those appenders
  nonwithstanding), use
  
      Log::Log4perl::Appender::TestBuffer->reset();
  
  =head1 SEE ALSO
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_TESTBUFFER

$fatpacked{"Log/Log4perl/Appender/TestFileCreeper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_APPENDER_TESTFILECREEPER';
  ##################################################
  package Log::Log4perl::Appender::TestFileCreeper;
  ##################################################
  # Test appender, intentionally slow. It writes 
  # out one byte at a time to provoke sync errors.
  # Don't use it, unless for testing.
  ##################################################
  
  use warnings;
  use strict;
  
  use Log::Log4perl::Appender::File;
  
  our @ISA = qw(Log::Log4perl::Appender::File);
  
  ##################################################
  sub log {
  ##################################################
      my($self, %params) = @_;
  
      my $fh = $self->{fh};
  
      for (split //, $params{message}) {
          print $fh $_;
          my $oldfh = select $self->{fh}; 
          $| = 1; 
          select $oldfh;
      }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Appender::TestFileCreeper - Intentionally slow test appender
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Appender::TestFileCreeper;
  
      my $app = Log::Log4perl::Appender::TestFileCreeper->new(
        filename  => 'file.log',
        mode      => 'append',
      );
  
      $file->log(message => "Log me\n");
  
  =head1 DESCRIPTION
  
  This is a test appender, and it is intentionally slow. It writes 
  out one byte at a time to provoke sync errors. Don't use it, unless 
  for testing.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_APPENDER_TESTFILECREEPER

$fatpacked{"Log/Log4perl/Catalyst.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CATALYST';
  package Log::Log4perl::Catalyst;
  
  use strict;
  use Log::Log4perl qw(:levels);
  use Log::Log4perl::Logger;
  
  our $VERSION                  = $Log::Log4perl::VERSION;
  our $CATALYST_APPENDER_SUFFIX = "catalyst_buffer";
  our $LOG_LEVEL_ADJUSTMENT     = 1;
  
  init();
  
  ##################################################
  sub init {
  ##################################################
  
      my @levels = qw[ trace debug info warn error fatal ];
  
      Log::Log4perl->wrapper_register(__PACKAGE__);
  
      for my $level (@levels) {
          no strict 'refs';
  
          *{$level} = sub {
              my ( $self, @message ) = @_;
  
              local $Log::Log4perl::caller_depth =
                    $Log::Log4perl::caller_depth +
                       $LOG_LEVEL_ADJUSTMENT;
  
              my $logger = Log::Log4perl->get_logger();
              $logger->$level(@message);
              return 1;
          };
  
          *{"is_$level"} = sub {
              my ( $self, @message ) = @_;
  
              local $Log::Log4perl::caller_depth =
                    $Log::Log4perl::caller_depth +
                       $LOG_LEVEL_ADJUSTMENT;
  
              my $logger = Log::Log4perl->get_logger();
              my $func   = "is_" . $level;
              return $logger->$func;
          };
      }
  }
  
  ##################################################
  sub new {
  ##################################################
      my($class, $config, %options) = @_;
  
      my $self = {
          autoflush   => 0,
          abort       => 0,
          watch_delay => 0,
          %options,
      };
  
      if( !Log::Log4perl->initialized() ) {
          if( defined $config ) {
              if( $self->{watch_delay} ) {
                  Log::Log4perl::init_and_watch( $config, $self->{watch_delay} );
              } else {
                  Log::Log4perl::init( $config );
              }
          } else {
               Log::Log4perl->easy_init({
                   level  => $DEBUG,
                   layout => "[%d] [catalyst] [%p] %m%n",
               });
          }
      }
  
        # Unless we have autoflush, Catalyst likes to buffer all messages
        # until it calls flush(). This is somewhat unusual for Log4perl,
        # but we just put an army of buffer appenders in front of all 
        # appenders defined in the system.
  
      if(! $options{autoflush} ) {
          for my $appender (values %Log::Log4perl::Logger::APPENDER_BY_NAME) {
              next if $appender->{name} =~ /_$CATALYST_APPENDER_SUFFIX$/;
  
              # put a buffering appender in front of every appender
              # defined so far
  
              my $buf_app_name = "$appender->{name}_$CATALYST_APPENDER_SUFFIX";
  
              my $buf_app = Log::Log4perl::Appender->new(
                  'Log::Log4perl::Appender::Buffer',
                  name       => $buf_app_name,
                  appender   => $appender->{name},
                  trigger    => sub { 0 },    # only trigger on explicit flush()
              );
  
              Log::Log4perl->add_appender($buf_app);
              $buf_app->post_init();
              $buf_app->composite(1);
  
              # Point all loggers currently connected to the previously defined
              # appenders to the chained buffer appenders instead.
  
              foreach my $logger (
                             values %$Log::Log4perl::Logger::LOGGERS_BY_NAME){
                  if(defined $logger->remove_appender( $appender->{name}, 0, 1)) {
                      $logger->add_appender( $buf_app );
                  }
              }
          }
      }
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub _flush {
  ##################################################
      my ($self) = @_;
  
      for my $appender (values %Log::Log4perl::Logger::APPENDER_BY_NAME) {
          next if $appender->{name} !~ /_$CATALYST_APPENDER_SUFFIX$/;
  
          if ($self->abort) {
              $appender->{appender}{buffer} = [];
          }
          else {
              $appender->flush();
          }
      }
  
      $self->abort(undef);
  }
  
  ##################################################
  sub abort {
  ##################################################
      my $self = shift;
  
      $self->{abort} = $_[0] if @_;
  
      return $self->{abort};
  }
  
  ##################################################
  sub levels {
  ##################################################
        # stub function, until we have something meaningful
      return 0;
  }
  
  ##################################################
  sub enable {
  ##################################################
        # stub function, until we have something meaningful
      return 0;
  }
  
  ##################################################
  sub disable {
  ##################################################
        # stub function, until we have something meaningful
      return 0;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Catalyst - Log::Log4perl Catalyst Module
  
  =head1 SYNOPSIS
  
  In your main Catalyst application module:
  
    use Log::Log4perl::Catalyst;
  
      # Either make Log4perl act like the Catalyst default logger:
    __PACKAGE__->log(Log::Log4perl::Catalyst->new());
  
      # or use a Log4perl configuration file, utilizing the full 
      # functionality of Log4perl
    __PACKAGE__->log(Log::Log4perl::Catalyst->new('l4p.conf'));
    
  ... and then sprinkle logging statements all over any code executed
  by Catalyst:
  
      $c->log->debug("This is using log4perl!");
  
  =head1 DESCRIPTION
  
  This module provides Log4perl functions to Catalyst applications. It was
  inspired by Catalyst::Log::Log4perl on CPAN, but has been completely 
  rewritten and uses a different approach to unite Catalyst and Log4perl.
  
  Log4perl provides loggers, usually associated with the current
  package, which can then be remote-controlled by a central
  configuration. This means that if you have a controller function like
  
      package MyApp::Controller::User;
  
      sub add : Chained('base'): PathPart('add'): Args(0) {
          my ( $self, $c ) = @_;
  
          $c->log->info("Adding a user");
          # ...
      }
  
  Level-based control is available via the following methods:
  
     $c->log->debug("Reading configuration");
     $c->log->info("Adding a user");
     $c->log->warn("Can't read configuration ($!)");
     $c->log->error("Can't add user ", $user);
     $c->log->fatal("Database down, aborting request");
  
  But that's not all, Log4perl is much more powerful.
  
  The logging statement can be suppressed or activated based on a Log4perl
  file that looks like
  
        # All MyApp loggers opened up for DEBUG and above
      log4perl.logger.MyApp = DEBUG, Screen
      # ...
  
  or 
  
        # All loggers block messages below INFO
      log4perl.logger=INFO, Screen
      # ...
  
  respectively. See the Log4perl manpage on how to perform fine-grained 
  log-level and location filtering, and how to forward messages not only
  to the screen or to log files, but also to databases, email appenders,
  and much more.
  
  Also, you can change the message layout. For example if you want
  to know where a particular statement was logged, turn on file names and 
  line numbers:
  
      # Log4perl configuration file
      # ...
      log4perl.appender.Screen.layout.ConversionPattern = \
            %F{1}-%L: %p %m%n
  
  Messages will then look like
  
      MyApp.pm-1869: INFO Saving user profile for user "wonko"
  
  Or want to log a request's IP address with every log statement? No problem 
  with Log4perl, just call
  
      Log::Log4perl::MDC->put( "ip", $c->req->address() );
  
  at the beginning of the request cycle and use
  
      # Log4perl configuration file
      # ...
      log4perl.appender.Screen.layout.ConversionPattern = \
            [%d]-%X{ip} %F{1}-%L: %p %m%n
  
  as a Log4perl layout. Messages will look like
  
      [2010/02/22 23:25:55]-123.122.108.10 MyApp.pm-1953: INFO Reading profile for user "wonko"
  
  Again, check the Log4perl manual page, there's a plethora of configuration
  options.
  
  =head1 METHODS
  
  =over 4
  
  =item new($config, [%options])
  
  If called without parameters, new() initializes Log4perl in a way 
  so that messages are logged similarly to Catalyst's default logging
  mechanism. If you provide a configuration, either the name of a configuration
  file or a reference to a scalar string containing the configuration, it
  will call Log4perl with these parameters.
  
  The second (optional) parameter is a list of key/value pairs:
  
    'autoflush'   =>  1   # Log without buffering ('abort' not supported)
    'watch_delay' => 30   # If set, use L<Log::Log4perl>'s init_and_watch
  
  =item _flush()
  
  Flushes the cache.
  
  =item abort($abort)
  
  Clears the logging system's internal buffers without logging anything.
  
  =back
  
  =head2 Using :easy Macros with Catalyst
  
  If you're tired of typing
  
      $c->log->debug("...");
  
  and would prefer to use Log4perl's convenient :easy mode macros like
  
      DEBUG "...";
  
  then just pull those macros in via Log::Log4perl's :easy mode and start
  cranking:
  
      use Log::Log4perl qw(:easy);
  
        # ... use macros later on
      sub base :Chained('/') :PathPart('apples') :CaptureArgs(0) {
          my ( $self, $c ) = @_;
  
          DEBUG "Handling apples";
      }
  
  Note the difference between Log4perl's initialization in Catalyst, which
  uses the Catalyst-specific Log::Log4perl::Catalyst module (top of this
  page), and making use of Log4perl's loggers with the standard 
  Log::Log4perl loggers and macros. While initialization requires Log4perl
  to perform dark magic to conform to Catalyst's different logging strategy,
  obtaining Log4perl's logger objects or calling its macros are unchanged.
  
  Instead of using Catalyst's way of referencing the "context" object $c to 
  obtain logger references via its log() method, you can just as well use 
  Log4perl's get_logger() or macros to access Log4perl's logger singletons. 
  The result is the same.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CATALYST

$fatpacked{"Log/Log4perl/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG';
  ##################################################
  package Log::Log4perl::Config;
  ##################################################
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl::Logger;
  use Log::Log4perl::Level;
  use Log::Log4perl::Config::PropertyConfigurator;
  use Log::Log4perl::JavaMap;
  use Log::Log4perl::Filter;
  use Log::Log4perl::Filter::Boolean;
  use Log::Log4perl::Config::Watch;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $CONFIG_FILE_READS       = 0;
  our $CONFIG_INTEGRITY_CHECK  = 1;
  our $CONFIG_INTEGRITY_ERROR  = undef;
  
  our $WATCHER;
  our $DEFAULT_WATCH_DELAY = 60; # seconds
  our $OPTS = {};
  our $OLD_CONFIG;
  our $LOGGERS_DEFINED;
  our $UTF8 = 0;
  
  ###########################################
  sub init {
  ###########################################
      Log::Log4perl::Logger->reset();
  
      undef $WATCHER; # just in case there's a one left over (e.g. test cases)
  
      return _init(@_);
  }
  
  ###########################################
  sub utf8 {
  ###########################################
      my( $class, $flag ) = @_;
  
      $UTF8 = $flag if defined $flag;
  
      return $UTF8;
  }
  
  ###########################################
  sub watcher {
  ###########################################
      return $WATCHER;
  }
  
  ###########################################
  sub init_and_watch {
  ###########################################
      my ($class, $config, $delay, $opts) = @_;
          # delay can be a signal name - in this case we're gonna
          # set up a signal handler.
  
      if(defined $WATCHER) {
          $config = $WATCHER->file();
          if(defined $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT) {
              $delay  = $WATCHER->signal();
          } else {
              $delay  = $WATCHER->check_interval();
          }
      }
  
      print "init_and_watch ($config-$delay). Resetting.\n" if _INTERNAL_DEBUG;
  
      Log::Log4perl::Logger->reset();
  
      defined ($delay) or $delay = $DEFAULT_WATCH_DELAY;  
  
      if (ref $config) {
          die "Log4perl can only watch a file, not a string of " .
              "configuration information";
      }elsif ($config =~ m!^(https?|ftp|wais|gopher|file):!){
          die "Log4perl can only watch a file, not a url like $config";
      }
  
      if($delay =~ /\D/) {
          $WATCHER = Log::Log4perl::Config::Watch->new(
                            file         => $config,
                            signal       => $delay,
                            l4p_internal => 1,
                     );
      } else {
          $WATCHER = Log::Log4perl::Config::Watch->new(
                            file           => $config,
                            check_interval => $delay,
                            l4p_internal   => 1,
                     );
      }
  
      if(defined $opts) {
          die "Parameter $opts needs to be a hash ref" if ref($opts) ne "HASH";
          $OPTS = $opts;
      }
  
      eval { _init($class, $config); };
  
      if($@) {
          die "$@" unless defined $OLD_CONFIG;
              # Call _init with a pre-parsed config to go back to old setting
          _init($class, undef, $OLD_CONFIG);
          warn "Loading new config failed, reverted to old one\n";
      }
  }
  
  ##################################################
  sub _init {
  ##################################################
      my($class, $config, $data) = @_;
  
      my %additivity = ();
  
      $LOGGERS_DEFINED = 0;
  
      print "Calling _init\n" if _INTERNAL_DEBUG;
  
      #keep track so we don't create the same one twice
      my %appenders_created = ();
  
      #some appenders need to run certain subroutines right at the
      #end of the configuration phase, when all settings are in place.
      my @post_config_subs  = ();
  
      # This logic is probably suited to win an obfuscated programming
      # contest. It desperately needs to be rewritten.
      # Basically, it works like this:
      # config_read() reads the entire config file into a hash of hashes:
      #     log4j.logger.foo.bar.baz: WARN, A1
      # gets transformed into
      #     $data->{log4j}->{logger}->{foo}->{bar}->{baz} = "WARN, A1";
      # The code below creates the necessary loggers, sets the appenders
      # and the layouts etc.
      # In order to transform parts of this tree back into identifiers
      # (like "foo.bar.baz"), we're using the leaf_paths functions below.
      # Pretty scary. But it allows the lines of the config file to be
      # in *arbitrary* order.
  
      $data = config_read($config) unless defined $data;
      
      if(_INTERNAL_DEBUG) {
          require Data::Dumper;
          Data::Dumper->import();
          print Data::Dumper::Dumper($data);
      }
  
      my @loggers      = ();
      my %filter_names = ();
  
      my $system_wide_threshold;
  
        # Autocorrect the rootlogger/rootLogger typo
      if(exists $data->{rootlogger} and 
         ! exists $data->{rootLogger}) {
           $data->{rootLogger} = $data->{rootlogger};
      }
  
          # Find all logger definitions in the conf file. Start
          # with root loggers.
      if(exists $data->{rootLogger}) {
          $LOGGERS_DEFINED++;
          push @loggers, ["", $data->{rootLogger}->{value}];
      }
          
          # Check if we've got a system-wide threshold setting
      if(exists $data->{threshold}) {
              # yes, we do.
          $system_wide_threshold = $data->{threshold}->{value};
      }
  
      if (exists $data->{oneMessagePerAppender}){
                      $Log::Log4perl::one_message_per_appender = 
                          $data->{oneMessagePerAppender}->{value};
      }
  
      if(exists $data->{utcDateTimes}) {
          require Log::Log4perl::DateFormat;
          $Log::Log4perl::DateFormat::GMTIME = !!$data->{utcDateTimes}->{value};
      }
  
          # Boolean filters 
      my %boolean_filters = ();
  
          # Continue with lower level loggers. Both 'logger' and 'category'
          # are valid keywords. Also 'additivity' is one, having a logger
          # attached. We'll differentiate between the two further down.
      for my $key (qw(logger category additivity PatternLayout filter)) {
  
          if(exists $data->{$key}) {
  
              for my $path (@{leaf_paths($data->{$key})}) {
  
                  print "Path before: @$path\n" if _INTERNAL_DEBUG;
  
                  my $value = boolean_to_perlish(pop @$path);
  
                  pop @$path; # Drop the 'value' keyword part
  
                  if($key eq "additivity") {
                      # This isn't a logger but an additivity setting.
                      # Save it in a hash under the logger's name for later.
                      $additivity{join('.', @$path)} = $value;
  
                      #a global user-defined conversion specifier (cspec)
                  }elsif ($key eq "PatternLayout"){
                      &add_global_cspec(@$path[-1], $value);
  
                  }elsif ($key eq "filter"){
                      print "Found entry @$path\n" if _INTERNAL_DEBUG;
                      $filter_names{@$path[0]}++;
                  } else {
  
                      if (ref($value) eq "ARRAY") {
                        die "Multiple definitions of logger ".join('.',@$path)." in log4perl config";
                      }
  
                      # This is a regular logger
                      $LOGGERS_DEFINED++;
                      push @loggers, [join('.', @$path), $value];
                  }
              }
          }
      }
  
          # Now go over all filters found by name
      for my $filter_name (keys %filter_names) {
  
          print "Checking filter $filter_name\n" if _INTERNAL_DEBUG;
  
              # The boolean filter needs all other filters already
              # initialized, defer its initialization
          if($data->{filter}->{$filter_name}->{value} eq
             "Log::Log4perl::Filter::Boolean") {
              print "Boolean filter ($filter_name)\n" if _INTERNAL_DEBUG;
              $boolean_filters{$filter_name}++;
              next;
          }
  
          my $type = $data->{filter}->{$filter_name}->{value};
          if(my $code = compile_if_perl($type)) {
              $type = $code;
          }
          
          print "Filter $filter_name is of type $type\n" if _INTERNAL_DEBUG;
  
          my $filter;
  
          if(ref($type) eq "CODE") {
                  # Subroutine - map into generic Log::Log4perl::Filter class
              $filter = Log::Log4perl::Filter->new($filter_name, $type);
          } else {
                  # Filter class
                  die "Filter class '$type' doesn't exist" unless
                       Log::Log4perl::Util::module_available($type);
                  eval "require $type" or die "Require of $type failed ($!)";
  
                  # Invoke with all defined parameter
                  # key/values (except the key 'value' which is the entry 
                  # for the class)
              $filter = $type->new(name => $filter_name,
                  map { $_ => $data->{filter}->{$filter_name}->{$_}->{value} } 
                  grep { $_ ne "value" } 
                  keys %{$data->{filter}->{$filter_name}});
          }
              # Register filter with the global filter registry
          $filter->register();
      }
  
          # Initialize boolean filters (they need the other filters to be
          # initialized to be able to compile their logic)
      for my $name (keys %boolean_filters) {
          my $logic = $data->{filter}->{$name}->{logic}->{value};
          die "No logic defined for boolean filter $name" unless defined $logic;
          my $filter = Log::Log4perl::Filter::Boolean->new(
                           name  => $name, 
                           logic => $logic);
          $filter->register();
      }
  
      for (@loggers) {
          my($name, $value) = @$_;
  
          my $logger = Log::Log4perl::Logger->get_logger($name);
          my ($level, @appnames) = split /\s*,\s*/, $value;
  
          $logger->level(
              Log::Log4perl::Level::to_priority($level),
              'dont_reset_all');
  
          if(exists $additivity{$name}) {
              $logger->additivity($additivity{$name}, 1);
          }
  
          for my $appname (@appnames) {
  
              my $appender = create_appender_instance(
                  $data, $appname, \%appenders_created, \@post_config_subs,
                  $system_wide_threshold);
  
              $logger->add_appender($appender, 'dont_reset_all');
              set_appender_by_name($appname, $appender, \%appenders_created);
          }
      }
  
      #run post_config subs
      for(@post_config_subs) {
          $_->();
      }
  
      #now we're done, set up all the output methods (e.g. ->debug('...'))
      Log::Log4perl::Logger::reset_all_output_methods();
  
      #Run a sanity test on the config not disabled
      if($Log::Log4perl::Config::CONFIG_INTEGRITY_CHECK and
         !config_is_sane()) {
          warn "Log::Log4perl configuration looks suspicious: ",
               "$CONFIG_INTEGRITY_ERROR";
      }
  
          # Successful init(), save config for later
      $OLD_CONFIG = $data;
  
      $Log::Log4perl::Logger::INITIALIZED = 1;
  }
  
  ##################################################
  sub config_is_sane {
  ##################################################
      if(! $LOGGERS_DEFINED) {
          $CONFIG_INTEGRITY_ERROR = "No loggers defined";
          return 0;
      }    
  
      if(scalar keys %Log::Log4perl::Logger::APPENDER_BY_NAME == 0) {
          $CONFIG_INTEGRITY_ERROR = "No appenders defined";
          return 0;
      }
  
      return 1;
  }
  
  ##################################################
  sub create_appender_instance {
  ##################################################
      my($data, $appname, $appenders_created, $post_config_subs,
         $system_wide_threshold) = @_;
  
      my $appenderclass = get_appender_by_name(
              $data, $appname, $appenders_created);
  
      print "appenderclass=$appenderclass\n" if _INTERNAL_DEBUG;
  
      my $appender;
  
      if (ref $appenderclass) {
          $appender = $appenderclass;
      } else {
          die "ERROR: you didn't tell me how to " .
              "implement your appender '$appname'"
                  unless $appenderclass;
  
          if (Log::Log4perl::JavaMap::translate($appenderclass)){
              # It's Java. Try to map
              print "Trying to map Java $appname\n" if _INTERNAL_DEBUG;
              $appender = Log::Log4perl::JavaMap::get($appname, 
                                          $data->{appender}->{$appname});
  
          }else{
              # It's Perl
              my @params = grep { $_ ne "layout" and
                                  $_ ne "value"
                                } keys %{$data->{appender}->{$appname}};
      
              my %param = ();
              foreach my $pname (@params){
                  #this could be simple value like 
                  #{appender}{myAppender}{file}{value} => 'log.txt'
                  #or a structure like
                  #{appender}{myAppender}{login} => 
                  #                         { name => {value => 'bob'},
                  #                           pwd  => {value => 'xxx'},
                  #                         }
                  #in the latter case we send a hashref to the appender
                  if (exists $data->{appender}{$appname}
                                    {$pname}{value}      ) {
                      $param{$pname} = $data->{appender}{$appname}
                                              {$pname}{value};
                  }else{
                      $param{$pname} = {map {$_ => $data->{appender}
                                                          {$appname}
                                                          {$pname}
                                                          {$_}
                                                          {value}} 
                                       keys %{$data->{appender}
                                                     {$appname}
                                                     {$pname}}
                                       };
                  }
      
              }
  
              my $depends_on = [];
      
              $appender = Log::Log4perl::Appender->new(
                  $appenderclass, 
                  name                 => $appname,
                  l4p_post_config_subs => $post_config_subs,
                  l4p_depends_on       => $depends_on,
                  %param,
              ); 
      
              for my $dependency (@$depends_on) {
                  # If this appender indicates that it needs other appenders
                  # to exist (e.g. because it's a composite appender that
                  # relays messages on to its appender-refs) then we're 
                  # creating their instances here. Reason for this is that 
                  # these appenders are not attached to any logger and are
                  # therefore missed by the config parser which goes through
                  # the defined loggers and just creates *their* attached
                  # appenders.
                  $appender->composite(1);
                  next if exists $appenders_created->{$appname};
                  my $app = create_appender_instance($data, $dependency, 
                               $appenders_created,
                               $post_config_subs);
                  # If the appender appended a subroutine to $post_config_subs
                  # (a reference to an array of subroutines)
                  # here, the configuration parser will later execute this
                  # method. This is used by a composite appender which needs
                  # to make sure all of its appender-refs are available when
                  # all configuration settings are done.
  
                  # Smuggle this sub-appender into the hash of known appenders 
                  # without attaching it to any logger directly.
                  $
                  Log::Log4perl::Logger::APPENDER_BY_NAME{$dependency} = $app;
              }
          }
      }
  
      add_layout_by_name($data, $appender, $appname) unless
          $appender->composite();
  
         # Check for appender thresholds
      my $threshold = 
         $data->{appender}->{$appname}->{Threshold}->{value};
  
      if(defined $system_wide_threshold and
         !defined $threshold) {
          $threshold = $system_wide_threshold;
      }
  
      if(defined $threshold) {
              # Need to split into two lines because of CVS
          $appender->threshold($
              Log::Log4perl::Level::PRIORITY{$threshold});
      }
  
          # Check for custom filters attached to the appender
      my $filtername = 
         $data->{appender}->{$appname}->{Filter}->{value};
      if(defined $filtername) {
              # Need to split into two lines because of CVS
          my $filter = Log::Log4perl::Filter::by_name($filtername);
          die "Filter $filtername doesn't exist" unless defined $filter;
          $appender->filter($filter);
      }
  
      if(defined $system_wide_threshold and
         defined $threshold and
         $
          Log::Log4perl::Level::PRIORITY{$system_wide_threshold} > 
         $
           Log::Log4perl::Level::PRIORITY{$threshold}
        ) {
          $appender->threshold($
              Log::Log4perl::Level::PRIORITY{$system_wide_threshold});
      }
  
      if(exists $data->{appender}->{$appname}->{threshold}) {
          die "invalid keyword 'threshold' - perhaps you meant 'Threshold'?";
      }
  
      return $appender;
  }
  
  ###########################################
  sub add_layout_by_name {
  ###########################################
      my($data, $appender, $appender_name) = @_;
  
      my $layout_class = $data->{appender}->{$appender_name}->{layout}->{value};
  
      die "Layout not specified for appender $appender_name" unless $layout_class;
  
      $layout_class =~ s/org.apache.log4j./Log::Log4perl::Layout::/;
  
          # Check if we have this layout class
      if(!Log::Log4perl::Util::module_available($layout_class)) {
          if(Log::Log4perl::Util::module_available(
             "Log::Log4perl::Layout::$layout_class")) {
              # Someone used the layout shortcut, use the fully qualified
              # module name instead.
              $layout_class = "Log::Log4perl::Layout::$layout_class";
          } else {
              die "ERROR: trying to set layout for $appender_name to " .
                  "'$layout_class' failed";
          }
      }
  
      eval "require $layout_class" or 
          die "Require to $layout_class failed ($!)";
  
      $appender->layout($layout_class->new(
          $data->{appender}->{$appender_name}->{layout},
          ));
  }
  
  ###########################################
  sub get_appender_by_name {
  ###########################################
      my($data, $name, $appenders_created) = @_;
  
      if (exists $appenders_created->{$name}) {
          return $appenders_created->{$name};
      } else {
          return $data->{appender}->{$name}->{value};
      }
  }
  
  ###########################################
  sub set_appender_by_name {
  ###########################################
  # keep track of appenders we've already created
  ###########################################
      my($appname, $appender, $appenders_created) = @_;
  
      $appenders_created->{$appname} ||= $appender;
  }
  
  ##################################################
  sub add_global_cspec {
  ##################################################
  # the config file said
  # log4j.PatternLayout.cspec.Z=sub {return $$*2}
  ##################################################
      my ($letter, $perlcode) = @_;
  
      die "error: only single letters allowed in log4j.PatternLayout.cspec.$letter"
          unless ($letter =~ /^[a-zA-Z]$/);
  
      Log::Log4perl::Layout::PatternLayout::add_global_cspec($letter, $perlcode);
  }
  
  my $LWP_USER_AGENT;
  sub set_LWP_UserAgent
  {
      $LWP_USER_AGENT = shift;
  }
  
  
  ###########################################
  sub config_read {
  ###########################################
  # Read the lib4j configuration and store the
  # values into a nested hash structure.
  ###########################################
      my($config) = @_;
  
      die "Configuration not defined" unless defined $config;
  
      my @text;
      my $parser;
  
      $CONFIG_FILE_READS++;  # Count for statistical purposes
  
      my $base_configurator = Log::Log4perl::Config::BaseConfigurator->new(
          utf8 => $UTF8,
      );
  
      my $data = {};
  
      if (ref($config) eq 'HASH') {   # convert the hashref into a list 
                                      # of name/value pairs
          print "Reading config from hash\n" if _INTERNAL_DEBUG;
          @text = ();
          for my $key ( keys %$config ) {
              if( ref( $config->{$key} ) eq "CODE" ) {
                  $config->{$key} = $config->{$key}->();
              }
              push @text, $key . '=' . $config->{$key} . "\n";
          }
      } elsif (ref $config eq 'SCALAR') {
          print "Reading config from scalar\n" if _INTERNAL_DEBUG;
          @text = split(/\n/,$$config);
  
      } elsif (ref $config eq 'GLOB' or 
               ref $config eq 'IO::File') {
              # If we have a file handle, just call the reader
          print "Reading config from file handle\n" if _INTERNAL_DEBUG;
          @text = @{ $base_configurator->file_h_read( $config ) };
  
      } elsif (ref $config) {
              # Caller provided a config parser object, which already
              # knows which file (or DB or whatever) to parse.
          print "Reading config from parser object\n" if _INTERNAL_DEBUG;
          $data = $config->parse();
          return $data;
  
      } elsif ($config =~ m|^ldap://|){
         if(! Log::Log4perl::Util::module_available("Net::LDAP")) {
             die "Log4perl: missing Net::LDAP needed to parse LDAP urls\n$@\n";
         }
  
         require Net::LDAP;
         require Log::Log4perl::Config::LDAPConfigurator;
  
         return Log::Log4perl::Config::LDAPConfigurator->new->parse($config);
  
      } else {
  
          if ($config =~ /^(https?|ftp|wais|gopher|file):/){
              my ($result, $ua);
      
              die "LWP::UserAgent not available" unless
                  Log::Log4perl::Util::module_available("LWP::UserAgent");
  
              require LWP::UserAgent;
              unless (defined $LWP_USER_AGENT) {
                  $LWP_USER_AGENT = LWP::UserAgent->new;
      
                  # Load proxy settings from environment variables, i.e.:
                  # http_proxy, ftp_proxy, no_proxy etc (see LWP::UserAgent)
                  # You need these to go thru firewalls.
                  $LWP_USER_AGENT->env_proxy;
              }
              $ua = $LWP_USER_AGENT;
  
              my $req = new HTTP::Request GET => $config;
              my $res = $ua->request($req);
  
              if ($res->is_success) {
                  @text = split(/\n/, $res->content);
              } else {
                  die "Log4perl couln't get $config, ".
                       $res->message." ";
              }
          } else {
              print "Reading config from file '$config'\n" if _INTERNAL_DEBUG;
              print "Reading ", -s $config, " bytes.\n" if _INTERNAL_DEBUG;
                # Use the BaseConfigurator's file reader to avoid duplicating
                # utf8 handling here.
              $base_configurator->file( $config );
              @text = @{ $base_configurator->text() };
          }
      }
      
      print "Reading $config: [@text]\n" if _INTERNAL_DEBUG;
  
      if(! grep /\S/, @text) {
          return $data;
      }
  
      if ($text[0] =~ /^<\?xml /) {
  
          die "XML::DOM not available" unless
                  Log::Log4perl::Util::module_available("XML::DOM");
  
          require XML::DOM; 
          require Log::Log4perl::Config::DOMConfigurator;
  
          XML::DOM->VERSION($Log::Log4perl::DOM_VERSION_REQUIRED);
          $parser = Log::Log4perl::Config::DOMConfigurator->new();
          $data = $parser->parse(\@text);
      } else {
          $parser = Log::Log4perl::Config::PropertyConfigurator->new();
          $data = $parser->parse(\@text);
      }
  
      $data = $parser->parse_post_process( $data, leaf_paths($data) );
  
      return $data;
  }
  
  ###########################################
  sub unlog4j {
  ###########################################
      my ($string) = @_;
  
      $string =~ s#^org\.apache\.##;
      $string =~ s#^log4j\.##;
      $string =~ s#^l4p\.##;
      $string =~ s#^log4perl\.##i;
  
      $string =~ s#\.#::#g;
  
      return $string;
  }
  
  ############################################################
  sub leaf_paths {
  ############################################################
  # Takes a reference to a hash of hashes structure of 
  # arbitrary depth, walks the tree and returns a reference
  # to an array of all possible leaf paths (each path is an 
  # array again).
  # Example: { a => { b => { c => d }, e => f } } would generate
  #          [ [a, b, c, d], [a, e, f] ]
  ############################################################
      my ($root) = @_;
  
      my @stack  = ();
      my @result = ();
  
      push @stack, [$root, []];  
      
      while(@stack) {
          my $item = pop @stack;
  
          my($node, $path) = @$item;
  
          if(ref($node) eq "HASH") { 
              for(keys %$node) {
                  push @stack, [$node->{$_}, [@$path, $_]];
              }
          } else {
              push @result, [@$path, $node];
          }
      }
      return \@result;
  }
  
  ###########################################
  sub leaf_path_to_hash {
  ###########################################
      my($leaf_path, $data) = @_;
  
      my $ref = \$data;
  
      for my $part ( @$leaf_path[0..$#$leaf_path-1] ) {
          $ref = \$$ref->{ $part };
      }
  
      return $ref;
  }
  
  ###########################################
  sub eval_if_perl {
  ###########################################
      my($value) = @_;
  
      if(my $cref = compile_if_perl($value)) {
          return $cref->();
      }
  
      return $value;
  }
  
  ###########################################
  sub compile_if_perl {
  ###########################################
      my($value) = @_;
  
      if($value =~ /^\s*sub\s*{/ ) {
          my $mask;
          unless( Log::Log4perl::Config->allow_code() ) {
              die "\$Log::Log4perl::Config->allow_code() setting " .
                  "prohibits Perl code in config file";
          }
          if( defined( $mask = Log::Log4perl::Config->allowed_code_ops() ) ) {
              return compile_in_safe_cpt($value, $mask );
          }
          elsif( $mask = Log::Log4perl::Config->allowed_code_ops_convenience_map(
                               Log::Log4perl::Config->allow_code()
                            ) ) {
              return compile_in_safe_cpt($value, $mask );
          }
          elsif( Log::Log4perl::Config->allow_code() == 1 ) {
  
              # eval without restriction
              my $cref = eval "package main; $value" or 
                  die "Can't evaluate '$value' ($@)";
              return $cref;
          }
          else {
              die "Invalid value for \$Log::Log4perl::Config->allow_code(): '".
                  Log::Log4perl::Config->allow_code() . "'";
          }
      }
  
      return undef;
  }
  
  ###########################################
  sub compile_in_safe_cpt {
  ###########################################
      my($value, $allowed_ops) = @_;
  
      # set up a Safe compartment
      require Safe;
      my $safe = Safe->new();
      $safe->permit_only( @{ $allowed_ops } );
   
      # share things with the compartment
      for( keys %{ Log::Log4perl::Config->vars_shared_with_safe_compartment() } ) {
          my $toshare = Log::Log4perl::Config->vars_shared_with_safe_compartment($_);
          $safe->share_from( $_, $toshare )
              or die "Can't share @{ $toshare } with Safe compartment";
      }
      
      # evaluate with restrictions
      my $cref = $safe->reval("package main; $value") or
          die "Can't evaluate '$value' in Safe compartment ($@)";
      return $cref;
      
  }
  
  ###########################################
  sub boolean_to_perlish {
  ###########################################
      my($value) = @_;
  
          # Translate boolean to perlish
      $value = 1 if $value =~ /^true$/i;
      $value = 0 if $value =~ /^false$/i;
  
      return $value;
  }
  
  ###########################################
  sub vars_shared_with_safe_compartment {
  ###########################################
      my($class, @args) = @_;
  
          # Allow both for ...::Config::foo() and ...::Config->foo()
      if(defined $class and $class ne __PACKAGE__) {
          unshift @args, $class;
      }
     
      # handle different invocation styles
      if(@args == 1 && ref $args[0] eq 'HASH' ) {
          # replace entire hash of vars
          %Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT = %{$args[0]};
      }
      elsif( @args == 1 ) {
          # return vars for given package
          return $Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT{
                 $args[0]};
      }
      elsif( @args == 2 ) {
          # add/replace package/var pair
          $Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT{
             $args[0]} = $args[1];
      }
  
      return wantarray ? %Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT
                       : \%Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT;
      
  }
  
  ###########################################
  sub allowed_code_ops {
  ###########################################
      my($class, @args) = @_;
  
          # Allow both for ...::Config::foo() and ...::Config->foo()
      if(defined $class and $class ne __PACKAGE__) {
          unshift @args, $class;
      }
     
      if(@args) {
          @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE = @args;
      }
      else {
          # give back 'undef' instead of an empty arrayref
          unless( @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE ) {
              return;
          }
      }
  
      return wantarray ? @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE
                       : \@Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE;
  }
  
  ###########################################
  sub allowed_code_ops_convenience_map {
  ###########################################
      my($class, @args) = @_;
  
          # Allow both for ...::Config::foo() and ...::Config->foo()
      if(defined $class and $class ne __PACKAGE__) {
          unshift @args, $class;
      }
  
      # handle different invocation styles
      if( @args == 1 && ref $args[0] eq 'HASH' ) {
          # replace entire map
          %Log::Log4perl::ALLOWED_CODE_OPS = %{$args[0]};
      }
      elsif( @args == 1 ) {
          # return single opcode mask
          return $Log::Log4perl::ALLOWED_CODE_OPS{
                     $args[0]};
      }
      elsif( @args == 2 ) {
          # make sure the mask is an array ref
          if( ref $args[1] ne 'ARRAY' ) {
              die "invalid mask (not an array ref) for convenience name '$args[0]'";
          }
          # add name/mask pair
          $Log::Log4perl::ALLOWED_CODE_OPS{
              $args[0]} = $args[1];
      }
  
      return wantarray ? %Log::Log4perl::ALLOWED_CODE_OPS
                       : \%Log::Log4perl::ALLOWED_CODE_OPS
  }
  
  ###########################################
  sub allow_code {
  ###########################################
      my($class, @args) = @_;
  
          # Allow both for ...::Config::foo() and ...::Config->foo()
      if(defined $class and $class ne __PACKAGE__) {
          unshift @args, $class;
      }
     
      if(@args) {
          $Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE = 
              $args[0];
      }
  
      return $Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE;
  }
  
  ################################################
  sub var_subst {
  ################################################
      my($varname, $subst_hash) = @_;
  
          # Throw out blanks
      $varname =~ s/\s+//g;
  
      if(exists $subst_hash->{$varname}) {
          print "Replacing variable: '$varname' => '$subst_hash->{$varname}'\n" 
              if _INTERNAL_DEBUG;
          return $subst_hash->{$varname};
  
      } elsif(exists $ENV{$varname}) {
          print "Replacing ENV variable: '$varname' => '$ENV{$varname}'\n" 
              if _INTERNAL_DEBUG;
          return $ENV{$varname};
  
      }
  
      die "Undefined Variable '$varname'";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config - Log4perl configuration file syntax
  
  =head1 DESCRIPTION
  
  In C<Log::Log4perl>, configuration files are used to describe how the
  system's loggers ought to behave. 
  
  The format is the same as the one as used for C<log4j>, just with
  a few perl-specific extensions, like enabling the C<Bar::Twix>
  syntax instead of insisting on the Java-specific C<Bar.Twix>.
  
  Comment lines and blank lines (all whitespace or empty) are ignored.
  
  Comment lines may start with arbitrary whitespace followed by one of:
  
  =over 4
  
  =item # - Common comment delimiter
  
  =item ! - Java .properties file comment delimiter accepted by log4j
  
  =item ; - Common .ini file comment delimiter
  
  =back
  
  Comments at the end of a line are not supported. So if you write
  
      log4perl.appender.A1.filename=error.log #in current dir
  
  you will find your messages in a file called C<error.log #in current dir>.
  
  Also, blanks between syntactical entities are ignored, it doesn't 
  matter if you write
  
      log4perl.logger.Bar.Twix=WARN,Screen
  
  or 
  
      log4perl.logger.Bar.Twix = WARN, Screen
  
  C<Log::Log4perl> will strip the blanks while parsing your input.
  
  Assignments need to be on a single line. However, you can break the
  line if you want to by using a continuation character at the end of the
  line. Instead of writing
  
      log4perl.appender.A1.layout=Log::Log4perl::Layout::SimpleLayout
  
  you can break the line at any point by putting a backslash at the very (!)
  end of the line to be continued:
  
      log4perl.appender.A1.layout=\
          Log::Log4perl::Layout::SimpleLayout
  
  Watch out for trailing blanks after the backslash, which would prevent
  the line from being properly concatenated.
  
  =head2 Loggers
  
  Loggers are addressed by category:
  
      log4perl.logger.Bar.Twix      = WARN, Screen
  
  This sets all loggers under the C<Bar::Twix> hierarchy on priority
  C<WARN> and attaches a later-to-be-defined C<Screen> appender to them.
  Settings for the root appender (which doesn't have a name) can be
  accomplished by simply omitting the name:
  
      log4perl.logger = FATAL, Database, Mailer 
  
  This sets the root appender's level to C<FATAL> and also attaches the 
  later-to-be-defined appenders C<Database> and C<Mailer> to it.
  
  The additivity flag of a logger is set or cleared via the 
  C<additivity> keyword:
  
      log4perl.additivity.Bar.Twix = 0|1
  
  (Note the reversed order of keyword and logger name, resulting
  from the dilemma that a logger name could end in C<.additivity>
  according to the log4j documentation).
  
  =head2 Appenders and Layouts
  
  Appender names used in Log4perl configuration file
  lines need to be resolved later on, in order to
  define the appender's properties and its layout. To specify properties
  of an appender, just use the C<appender> keyword after the
  C<log4perl> intro and the appender's name:
  
          # The Bar::Twix logger and its appender
      log4perl.logger.Bar.Twix = DEBUG, A1
      log4perl.appender.A1=Log::Log4perl::Appender::File
      log4perl.appender.A1.filename=test.log
      log4perl.appender.A1.mode=append
      log4perl.appender.A1.layout=Log::Log4perl::Layout::SimpleLayout
  
  This sets a priority of C<DEBUG> for loggers in the C<Bar::Twix>
  hierarchy and assigns the C<A1> appender to it, which is later on
  resolved to be an appender of type C<Log::Log4perl::Appender::File>, simply
  appending to a log file. According to the C<Log::Log4perl::Appender::File>
  manpage, the C<filename> parameter specifies the name of the log file
  and the C<mode> parameter can be set to C<append> or C<write> (the
  former will append to the logfile if one with the specified name
  already exists while the latter would clobber and overwrite it).
  
  The order of the entries in the configuration file is not important,
  C<Log::Log4perl> will read in the entire file first and try to make
  sense of the lines after it knows the entire context.
  
  You can very well define all loggers first and then their appenders
  (you could even define your appenders first and then your loggers,
  but let's not go there):
  
      log4perl.logger.Bar.Twix = DEBUG, A1
      log4perl.logger.Bar.Snickers = FATAL, A2
  
      log4perl.appender.A1=Log::Log4perl::Appender::File
      log4perl.appender.A1.filename=test.log
      log4perl.appender.A1.mode=append
      log4perl.appender.A1.layout=Log::Log4perl::Layout::SimpleLayout
  
      log4perl.appender.A2=Log::Log4perl::Appender::Screen
      log4perl.appender.A2.stderr=0
      log4perl.appender.A2.layout=Log::Log4perl::Layout::PatternLayout
      log4perl.appender.A2.layout.ConversionPattern = %d %m %n
  
  Note that you have to specify the full path to the layout class
  and that C<ConversionPattern> is the keyword to specify the printf-style
  formatting instructions.
  
  =head1 Configuration File Cookbook
  
  Here's some examples of often-used Log4perl configuration files:
  
  =head2 Append to STDERR
  
      log4perl.category.Bar.Twix      = WARN, Screen
      log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Screen.layout.ConversionPattern = %d %m %n
  
  =head2 Append to STDOUT
  
      log4perl.category.Bar.Twix      = WARN, Screen
      log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.stderr = 0
      log4perl.appender.Screen.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Screen.layout.ConversionPattern = %d %m %n
  
  =head2 Append to a log file
  
      log4perl.logger.Bar.Twix = DEBUG, A1
      log4perl.appender.A1=Log::Log4perl::Appender::File
      log4perl.appender.A1.filename=test.log
      log4perl.appender.A1.mode=append
      log4perl.appender.A1.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.A1.layout.ConversionPattern = %d %m %n
  
  Note that you could even leave out 
  
      log4perl.appender.A1.mode=append
  
  and still have the logger append to the logfile by default, although
  the C<Log::Log4perl::Appender::File> module does exactly the opposite.
  This is due to some nasty trickery C<Log::Log4perl> performs behind 
  the scenes to make sure that beginner's CGI applications don't clobber 
  the log file every time they're called.
  
  =head2 Write a log file from scratch
  
  If you loathe the Log::Log4perl's append-by-default strategy, you can
  certainly override it:
  
      log4perl.logger.Bar.Twix = DEBUG, A1
      log4perl.appender.A1=Log::Log4perl::Appender::File
      log4perl.appender.A1.filename=test.log
      log4perl.appender.A1.mode=write
      log4perl.appender.A1.layout=Log::Log4perl::Layout::SimpleLayout
  
  C<write> is the C<mode> that has C<Log::Log4perl::Appender::File>
  explicitly clobber the log file if it exists.
  
  =head2 Configuration files encoded in utf-8
  
  If your configuration file is encoded in utf-8 (which matters if you 
  e.g. specify utf8-encoded appender filenames in it), then you need to 
  tell Log4perl before running init():
  
      use Log::Log4perl::Config;
      Log::Log4perl::Config->utf( 1 );
  
      Log::Log4perl->init( ... );
  
  This makes sure Log4perl interprets utf8-encoded config files correctly.
  This setting might become the default at some point.
  
  =head1 SEE ALSO
  
  Log::Log4perl::Config::PropertyConfigurator
  
  Log::Log4perl::Config::DOMConfigurator
  
  Log::Log4perl::Config::LDAPConfigurator (coming soon!)
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG

$fatpacked{"Log/Log4perl/Config/BaseConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_BASECONFIGURATOR';
  package Log::Log4perl::Config::BaseConfigurator;
  
  use warnings;
  use strict;
  use constant _INTERNAL_DEBUG => 0;
  
  *eval_if_perl      = \&Log::Log4perl::Config::eval_if_perl;
  *compile_if_perl   = \&Log::Log4perl::Config::compile_if_perl;
  *leaf_path_to_hash = \&Log::Log4perl::Config::leaf_path_to_hash;
  
  ################################################
  sub new {
  ################################################
      my($class, %options) = @_;
  
      my $self = { 
          utf8 => 0,
          %options,
      };
  
      bless $self, $class;
  
      $self->file($self->{file}) if exists $self->{file};
      $self->text($self->{text}) if exists $self->{text};
  
      return $self;
  }
  
  ################################################
  sub text {
  ################################################
      my($self, $text) = @_;
  
          # $text is an array of scalars (lines)
      if(defined $text) {
          if(ref $text eq "ARRAY") {
              $self->{text} = $text;
          } else {
              $self->{text} = [split "\n", $text];
          }
      }
  
      return $self->{text};
  }
  
  ################################################
  sub file {
  ################################################
      my($self, $filename) = @_;
  
      open my $fh, "$filename" or die "Cannot open $filename ($!)";
  
      if( $self->{ utf8 } ) {
          binmode $fh, ":utf8";
      }
  
      $self->file_h_read( $fh );
      close $fh;
  }
  
  ################################################
  sub file_h_read {
  ################################################
      my($self, $fh) = @_;
  
          # Dennis Gregorovic <dgregor@redhat.com> added this
          # to protect apps which are tinkering with $/ globally.
      local $/ = "\n";
  
      $self->{text} = [<$fh>];
  }
  
  ################################################
  sub parse {
  ################################################
      die __PACKAGE__ . "::parse() is a virtual method. " .
          "It must be implemented " .
          "in a derived class (currently: ", ref(shift), ")";
  }
  
  ################################################
  sub parse_post_process {
  ################################################
      my($self, $data, $leaf_paths) = @_;
      
      #   [
      #     'category',
      #     'value',
      #     'WARN, Logfile'
      #   ],
      #   [
      #     'appender',
      #     'Logfile',
      #     'value',
      #     'Log::Log4perl::Appender::File'
      #   ],
      #   [
      #     'appender',
      #     'Logfile',
      #     'filename',
      #     'value',
      #     'test.log'
      #   ],
      #   [
      #     'appender',
      #     'Logfile',
      #     'layout',
      #     'value',
      #     'Log::Log4perl::Layout::PatternLayout'
      #   ],
      #   [
      #     'appender',
      #     'Logfile',
      #     'layout',
      #     'ConversionPattern',
      #     'value',
      #     '%d %F{1} %L> %m %n'
      #   ]
  
      for my $path ( @{ Log::Log4perl::Config::leaf_paths( $data )} ) {
  
          print "path=@$path\n" if _INTERNAL_DEBUG;
  
          if(0) {
          } elsif( 
              $path->[0] eq "appender" and
              $path->[2] eq "trigger"
            ) {
              my $ref = leaf_path_to_hash( $path, $data );
              my $code = compile_if_perl( $$ref );
  
              if(_INTERNAL_DEBUG) {
                  if($code) {
                      print "Code compiled: $$ref\n";
                  } else {
                      print "Not compiled: $$ref\n";
                  }
              }
  
              $$ref = $code if defined $code;
          } elsif (
              $path->[0] eq "filter"
            ) {
              # do nothing
          } elsif (
              $path->[0] eq "appender" and
              $path->[2] eq "warp_message"
            ) {
              # do nothing
          } elsif (
              $path->[0] eq "appender" and
              $path->[3] eq "cspec" or
              $path->[1] eq "cspec"
            ) {
                # could be either
                #    appender appndr layout cspec
                # or 
                #    PatternLayout cspec U value ...
                #
              # do nothing
          } else {
              my $ref = leaf_path_to_hash( $path, $data );
  
              if(_INTERNAL_DEBUG) {
                  print "Calling eval_if_perl on $$ref\n";
              }
  
              $$ref = eval_if_perl( $$ref );
          }
      }
  
      return $data;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config::BaseConfigurator - Configurator Base Class
  
  =head1 SYNOPSIS
  
  This is a virtual base class, all configurators should be derived from it.
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item C<< new >>
  
  Constructor, typically called like
  
      my $config_parser = SomeConfigParser->new(
          file => $file,
      );
  
      my $data = $config_parser->parse();
  
  Instead of C<file>, the derived class C<SomeConfigParser> may define any 
  type of configuration input medium (e.g. C<url =E<gt> 'http://foobar'>).
  It just has to make sure its C<parse()> method will later pull the input
  data from the medium specified.
  
  The base class accepts a filename or a reference to an array
  of text lines:
  
  =over 4
  
  =item C<< file >>
  
  Specifies a file which the C<parse()> method later parses.
  
  =item C<< text >>
  
  Specifies a reference to an array of scalars, representing configuration
  records (typically lines of a file). Also accepts a simple scalar, which it 
  splits at its newlines and transforms it into an array:
  
      my $config_parser = MyYAMLParser->new(
          text => ['foo: bar',
                   'baz: bam',
                  ],
      );
  
      my $data = $config_parser->parse();
  
  =back
  
  If either C<file> or C<text> parameters have been specified in the 
  constructor call, a later call to the configurator's C<text()> method
  will return a reference to an array of configuration text lines.
  This will typically be used by the C<parse()> method to process the 
  input.
  
  =item C<< parse >>
  
  Virtual method, needs to be defined by the derived class.
  
  =back
  
  =head2 Parser requirements
  
  =over 4
  
  =item *
  
  If the parser provides variable substitution functionality, it has
  to implement it.
  
  =item *
  
  The parser's C<parse()> method returns a reference to a hash of hashes (HoH). 
  The top-most hash contains the
  top-level keywords (C<category>, C<appender>) as keys, associated
  with values which are references to more deeply nested hashes.
  
  =item *
  
  The C<log4perl.> prefix (e.g. as used in the PropertyConfigurator class)
  is stripped, it's not part in the HoH structure.
  
  =item *
  
  Each Log4perl config value is indicated by the C<value> key, as in
  
      $data->{category}->{Bar}->{Twix}->{value} = "WARN, Logfile"
  
  =back
  
  =head2 EXAMPLES
  
  The following Log::Log4perl configuration:
  
      log4perl.category.Bar.Twix        = WARN, Screen
      log4perl.appender.Screen          = Log::Log4perl::Appender::File
      log4perl.appender.Screen.filename = test.log
      log4perl.appender.Screen.layout   = Log::Log4perl::Layout::SimpleLayout
  
  needs to be transformed by the parser's C<parse()> method 
  into this data structure:
  
      { appender => {
          Screen  => {
            layout => { 
              value  => "Log::Log4perl::Layout::SimpleLayout" },
              value  => "Log::Log4perl::Appender::Screen",
          },
        },
        category => { 
          Bar => { 
            Twix => { 
              value => "WARN, Screen" } 
          } }
      }
  
  For a full-fledged example, check out the sample YAML parser implementation 
  in C<eg/yamlparser>. It uses a simple YAML syntax to specify the Log4perl 
  configuration to illustrate the concept.
  
  =head1 SEE ALSO
  
  Log::Log4perl::Config::PropertyConfigurator
  
  Log::Log4perl::Config::DOMConfigurator
  
  Log::Log4perl::Config::LDAPConfigurator (tbd!)
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG_BASECONFIGURATOR

$fatpacked{"Log/Log4perl/Config/DOMConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_DOMCONFIGURATOR';
  package Log::Log4perl::Config::DOMConfigurator;
  use Log::Log4perl::Config::BaseConfigurator;
  
  our @ISA = qw(Log::Log4perl::Config::BaseConfigurator);
  
  #todo
  # DONE(param-text) some params not attrs but values, like <sql>...</sql>
  # DONE see DEBUG!!!  below
  # NO, (really is only used for AsyncAppender) appender-ref in <appender>
  # DONE check multiple appenders in a category
  # DONE in Config.pm re URL loading, steal from XML::DOM
  # DONE, OK see PropConfigurator re importing unlog4j, eval_if_perl
  # NO (is specified in DTD) - need to handle 0/1, true/false?
  # DONE see Config, need to check version of XML::DOM
  # OK user defined levels? see parse_level
  # OK make sure 2nd test is using log4perl constructs, not log4j
  # OK handle new filter stuff
  # make sure sample code actually works
  # try removing namespace prefixes in the xml
  
  use XML::DOM;
  use Log::Log4perl::Level;
  use strict;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $VERSION = 0.03;
  
  our $APPENDER_TAG = qr/^((log4j|log4perl):)?appender$/;
  
  our $FILTER_TAG = qr/^(log4perl:)?filter$/;
  our $FILTER_REF_TAG = qr/^(log4perl:)?filter-ref$/;
  
  #can't use ValParser here because we're using namespaces? 
  #doesn't seem to work - kg 3/2003 
  our $PARSER_CLASS = 'XML::DOM::Parser';
  
  our $LOG4J_PREFIX = 'log4j';
  our $LOG4PERL_PREFIX = 'log4perl';
      
  
  #poor man's export
  *eval_if_perl = \&Log::Log4perl::Config::eval_if_perl;
  *unlog4j      = \&Log::Log4perl::Config::unlog4j;
  
  
  ###################################################
  sub parse {
  ###################################################
      my($self, $newtext) = @_;
  
      $self->text($newtext) if defined $newtext;
      my $text = $self->{text};
  
      my $parser = $PARSER_CLASS->new;
      my $doc = $parser->parse (join('',@$text));
  
  
      my $l4p_tree = {};
      
      my $config = $doc->getElementsByTagName("$LOG4J_PREFIX:configuration")->item(0)||
                   $doc->getElementsByTagName("$LOG4PERL_PREFIX:configuration")->item(0);
  
      my $threshold = uc(subst($config->getAttribute('threshold')));
      if ($threshold) {
          $l4p_tree->{threshold}{value} = $threshold;
      }
  
      if (subst($config->getAttribute('oneMessagePerAppender')) eq 'true') {
          $l4p_tree->{oneMessagePerAppender}{value} = 1;
      }
  
      for my $kid ($config->getChildNodes){
  
          next unless $kid->getNodeType == ELEMENT_NODE;
  
          my $tag_name = $kid->getTagName;
  
          if ($tag_name =~ $APPENDER_TAG) {
              &parse_appender($l4p_tree, $kid);
  
          }elsif ($tag_name eq 'category' || $tag_name eq 'logger'){
              &parse_category($l4p_tree, $kid);
              #Treating them the same is not entirely accurate, 
              #the dtd says 'logger' doesn't accept
              #a 'class' attribute while 'category' does.
              #But that's ok, log4perl doesn't do anything with that attribute
  
          }elsif ($tag_name eq 'root'){
              &parse_root($l4p_tree, $kid);
  
          }elsif ($tag_name =~ $FILTER_TAG){
              #parse log4perl's chainable boolean filters
              &parse_l4p_filter($l4p_tree, $kid);
  
          }elsif ($tag_name eq 'renderer'){
              warn "Log4perl: ignoring renderer tag in config, unimplemented";
              #"log4j will render the content of the log message according to 
              # user specified criteria. For example, if you frequently need 
              # to log Oranges, an object type used in your current project, 
              # then you can register an OrangeRenderer that will be invoked 
              # whenever an orange needs to be logged. "
           
          }elsif ($tag_name eq 'PatternLayout'){#log4perl only
              &parse_patternlayout($l4p_tree, $kid);
          }
      }
      $doc->dispose;
  
      return $l4p_tree;
  }
  
  #this is just for toplevel log4perl.PatternLayout tags
  #holding the custom cspecs
  sub parse_patternlayout {
      my ($l4p_tree, $node) = @_;
  
      my $l4p_branch = {};
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
  
          my $name = subst($child->getAttribute('name'));
          my $value;
  
          foreach my $grandkid ($child->getChildNodes){
              if ($grandkid->getNodeType == TEXT_NODE) {
                  $value .= $grandkid->getData;
              }
          }
          $value =~ s/^ +//;  #just to make the unit tests pass
          $value =~ s/ +$//;
          $l4p_branch->{$name}{value} = subst($value);
      }
      $l4p_tree->{PatternLayout}{cspec} = $l4p_branch;
  }
  
  
  #for parsing the root logger, if any
  sub parse_root {
      my ($l4p_tree, $node) = @_;
  
      my $l4p_branch = {};
  
      &parse_children_of_logger_element($l4p_branch, $node);
  
      $l4p_tree->{category}{value} = $l4p_branch->{value};
  
  }
  
  
  #this parses a custom log4perl-specific filter set up under
  #the root element, as opposed to children of the appenders
  sub parse_l4p_filter {
      my ($l4p_tree, $node) = @_;
  
      my $l4p_branch = {};
  
      my $name = subst($node->getAttribute('name'));
  
      my $class = subst($node->getAttribute('class'));
      my $value = subst($node->getAttribute('value'));
  
      if ($class && $value) {
          die "Log4perl: only one of class or value allowed, not both, "
              ."in XMLConfig filter '$name'";
      }elsif ($class || $value){
          $l4p_branch->{value} = ($value || $class);
  
      }
  
      for my $child ($node->getChildNodes) {
  
          if ($child->getNodeType == ELEMENT_NODE){
  
              my $tag_name = $child->getTagName();
  
              if ($tag_name =~ /^(param|param-nested|param-text)$/) {
                  &parse_any_param($l4p_branch, $child);
              }
          }elsif ($child->getNodeType == TEXT_NODE){
              my $text = $child->getData;
              next unless $text =~ /\S/;
              if ($class && $value) {
                  die "Log4perl: only one of class, value or PCDATA allowed, "
                      ."in XMLConfig filter '$name'";
              }
              $l4p_branch->{value} .= subst($text); 
          }
      }
  
      $l4p_tree->{filter}{$name} = $l4p_branch;
  }
  
     
  #for parsing a category/logger element
  sub parse_category {
      my ($l4p_tree, $node) = @_;
  
      my $name = subst($node->getAttribute('name'));
  
      $l4p_tree->{category} ||= {};
   
      my $ptr = $l4p_tree->{category};
  
      for my $part (split /\.|::/, $name) {
          $ptr->{$part} = {} unless exists $ptr->{$part};
          $ptr = $ptr->{$part};
      }
  
      my $l4p_branch = $ptr;
  
      my $class = subst($node->getAttribute('class'));
      $class                       && 
         $class ne 'Log::Log4perl' &&
         $class ne 'org.apache.log4j.Logger' &&
         warn "setting category $name to class $class ignored, only Log::Log4perl implemented";
  
      #this is kind of funky, additivity has its own spot in the tree
      my $additivity = subst(subst($node->getAttribute('additivity')));
      if (length $additivity > 0) {
          $l4p_tree->{additivity} ||= {};
          my $add_ptr = $l4p_tree->{additivity};
  
          for my $part (split /\.|::/, $name) {
              $add_ptr->{$part} = {} unless exists $add_ptr->{$part};
              $add_ptr = $add_ptr->{$part};
          }
          $add_ptr->{value} = &parse_boolean($additivity);
      }
  
      &parse_children_of_logger_element($l4p_branch, $node);
  }
  
  # parses the children of a category element
  sub parse_children_of_logger_element {
      my ($l4p_branch, $node) = @_;
  
      my (@appenders, $priority);
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
              
          my $tag_name = $child->getTagName();
  
          if ($tag_name eq 'param') {
              my $name = subst($child->getAttribute('name'));
              my $value = subst($child->getAttribute('value'));
              if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)^/) {
                  $value = uc $value;
              }
              $l4p_branch->{$name} = {value => $value};
          
          }elsif ($tag_name eq 'appender-ref'){
              push @appenders, subst($child->getAttribute('ref'));
              
          }elsif ($tag_name eq 'level' || $tag_name eq 'priority'){
              $priority = &parse_level($child);
          }
      }
      $l4p_branch->{value} = $priority.', '.join(',', @appenders);
      
      return;
  }
  
  
  sub parse_level {
      my $node = shift;
  
      my $level = uc (subst($node->getAttribute('value')));
  
      die "Log4perl: invalid level in config: $level"
          unless Log::Log4perl::Level::is_valid($level);
  
      return $level;
  }
  
  
  
  sub parse_appender {
      my ($l4p_tree, $node) = @_;
  
      my $name = subst($node->getAttribute("name"));
  
      my $l4p_branch = {};
  
      my $class = subst($node->getAttribute("class"));
  
      $l4p_branch->{value} = $class;
  
      print "looking at $name----------------------\n"  if _INTERNAL_DEBUG;
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
  
          my $tag_name = $child->getTagName();
  
          my $name = unlog4j(subst($child->getAttribute('name')));
  
          if ($tag_name =~ /^(param|param-nested|param-text)$/) {
  
              &parse_any_param($l4p_branch, $child);
  
              my $value;
  
          }elsif ($tag_name =~ /($LOG4PERL_PREFIX:)?layout/){
              $l4p_branch->{layout} = parse_layout($child);
  
          }elsif ($tag_name =~  $FILTER_TAG){
              $l4p_branch->{Filter} = parse_filter($child);
  
          }elsif ($tag_name =~ $FILTER_REF_TAG){
              $l4p_branch->{Filter} = parse_filter_ref($child);
  
          }elsif ($tag_name eq 'errorHandler'){
              die "errorHandlers not supported yet";
  
          }elsif ($tag_name eq 'appender-ref'){
              #dtd: Appenders may also reference (or include) other appenders. 
              #This feature in log4j is only for appenders who implement the 
              #AppenderAttachable interface, and the only one that does that
              #is the AsyncAppender, which writes logs in a separate thread.
              #I don't see the need to support this on the perl side any 
              #time soon.  --kg 3/2003
              die "Log4perl: in config file, <appender-ref> tag is unsupported in <appender>";
          }else{
              die "Log4perl: in config file, <$tag_name> is unsupported\n";
          }
      }
      $l4p_tree->{appender}{$name} = $l4p_branch;
  }
  
  sub parse_any_param {
      my ($l4p_branch, $child) = @_;
  
      my $tag_name = $child->getTagName();
      my $name = subst($child->getAttribute('name'));
      my $value;
  
      print "parse_any_param: <$tag_name name=$name\n" if _INTERNAL_DEBUG;
  
      #<param-nested>
      #note we don't set it to { value => $value }
      #and we don't test for multiple values
      if ($tag_name eq 'param-nested'){
          
          if ($l4p_branch->{$name}){
              die "Log4perl: in config file, multiple param-nested tags for $name not supported";
          }
          $l4p_branch->{$name} = &parse_param_nested($child); 
  
          return;
  
      #<param>
      }elsif ($tag_name eq 'param') {
  
           $value = subst($child->getAttribute('value'));
  
           print "parse_param_nested: got param $name = $value\n"  
               if _INTERNAL_DEBUG;
          
           if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)$/) {
               $value = uc $value;
           }
  
           if ($name !~ /warp_message|filter/ &&
              $child->getParentNode->getAttribute('name') ne 'cspec') {
              $value = eval_if_perl($value);
           }
      #<param-text>
      }elsif ($tag_name eq 'param-text'){
  
          foreach my $grandkid ($child->getChildNodes){
              if ($grandkid->getNodeType == TEXT_NODE) {
                  $value .= $grandkid->getData;
              }
          }
          if ($name !~ /warp_message|filter/ &&
              $child->getParentNode->getAttribute('name') ne 'cspec') {
              $value = eval_if_perl($value);
          }
      }
  
      $value = subst($value);
  
       #multiple values for the same param name
       if (defined $l4p_branch->{$name}{value} ) {
           if (ref $l4p_branch->{$name}{value} ne 'ARRAY'){
               my $temp = $l4p_branch->{$name}{value};
               $l4p_branch->{$name}{value} = [$temp];
           }
           push @{$l4p_branch->{$name}{value}}, $value;
       }else{
           $l4p_branch->{$name} = {value => $value};
       }
  }
  
  #handles an appender's <param-nested> elements
  sub parse_param_nested {
      my ($node) = shift;
  
      my $l4p_branch = {};
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
  
          my $tag_name = $child->getTagName();
  
          if ($tag_name =~ /^param|param-nested|param-text$/) {
              &parse_any_param($l4p_branch, $child);
          }
      }
  
      return $l4p_branch;
  }
  
  #this handles filters that are children of appenders, as opposed
  #to the custom filters that go under the root element
  sub parse_filter {
      my $node = shift;
  
      my $filter_tree = {};
  
      my $class_name = subst($node->getAttribute('class'));
  
      $filter_tree->{value} = $class_name;
  
      print "\tparsing filter on class $class_name\n"  if _INTERNAL_DEBUG;  
  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
  
          my $tag_name = $child->getTagName();
  
          if ($tag_name =~ 'param|param-nested|param-text') {
              &parse_any_param($filter_tree, $child);
          
          }else{
              die "Log4perl: don't know what to do with a ".$child->getTagName()
                  ."inside a filter element";
          }
      }
      return $filter_tree;
  }
  
  sub parse_filter_ref {
      my $node = shift;
  
      my $filter_tree = {};
  
      my $filter_id = subst($node->getAttribute('id'));
  
      $filter_tree->{value} = $filter_id;
  
      return $filter_tree;
  }
  
  
  
  sub parse_layout {
      my $node = shift;
  
      my $layout_tree = {};
  
      my $class_name = subst($node->getAttribute('class'));
      
      $layout_tree->{value} = $class_name;
      #
      print "\tparsing layout $class_name\n"  if _INTERNAL_DEBUG;  
      for my $child ($node->getChildNodes) {
          next unless $child->getNodeType == ELEMENT_NODE;
          if ($child->getTagName() eq 'param') {
              my $name = subst($child->getAttribute('name'));
              my $value = subst($child->getAttribute('value'));
              if ($value =~ /^(all|debug|info|warn|error|fatal|off|null)$/) {
                  $value = uc $value;
              }
              print "\tparse_layout: got param $name = $value\n"
                  if _INTERNAL_DEBUG;
              $layout_tree->{$name}{value} = $value;  
  
          }elsif ($child->getTagName() eq 'cspec') {
              my $name = subst($child->getAttribute('name'));
              my $value;
              foreach my $grandkid ($child->getChildNodes){
                  if ($grandkid->getNodeType == TEXT_NODE) {
                      $value .= $grandkid->getData;
                  }
              }
              $value =~ s/^ +//;
              $value =~ s/ +$//;
              $layout_tree->{cspec}{$name}{value} = subst($value);  
          }
      }
      return $layout_tree;
  }
  
  sub parse_boolean {
      my $a = shift;
  
      if ($a eq '0' || lc $a eq 'false') {
          return '0';
      }elsif ($a eq '1' || lc $a eq 'true'){
          return '1';
      }else{
          return $a; #probably an error, punt
      }
  }
  
  
  #this handles variable substitution
  sub subst {
      my $val = shift;
  
      $val =~ s/\$\{(.*?)}/
                        Log::Log4perl::Config::var_subst($1, {})/gex;
      return $val;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config::DOMConfigurator - reads xml config files
  
  =head1 SYNOPSIS
  
      --------------------------
      --using the log4j DTD--
      --------------------------
  
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
  
      <log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
  
      <appender name="FileAppndr1" class="org.apache.log4j.FileAppender">
          <layout class="Log::Log4perl::Layout::PatternLayout">
                  <param name="ConversionPattern"
                         value="%d %4r [%t] %-5p %c %t - %m%n"/>
          </layout>
          <param name="File" value="t/tmp/DOMtest"/>
          <param name="Append" value="false"/>
      </appender>
  
      <category name="a.b.c.d" additivity="false">
          <level value="warn"/>  <!-- note lowercase! -->
          <appender-ref ref="FileAppndr1"/>
      </category>
  
     <root>
          <priority value="warn"/>
          <appender-ref ref="FileAppndr1"/>
     </root>
  
     </log4j:configuration>
     
     
     
     --------------------------
     --using the log4perl DTD--
     --------------------------
     
     <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE log4perl:configuration SYSTEM "log4perl.dtd">
  
      <log4perl:configuration xmlns:log4perl="http://log4perl.sourceforge.net/"
          threshold="debug" oneMessagePerAppender="true">
  
      <log4perl:appender name="jabbender" class="Log::Dispatch::Jabber">
  
              <param-nested name="login">
                     <param name="hostname" value="a.jabber.server"/>
                     <param name="password" value="12345"/>
                     <param name="port"     value="5222"/>
                     <param name="resource" value="logger"/>
                     <param name="username" value="bobjones"/>
              </param-nested>
  
              <param name="to" value="bob@a.jabber.server"/>
  
              <param-text name="to">
                    mary@another.jabber.server
              </param-text>
  
              <log4perl:layout class="org.apache.log4j.PatternLayout">
                  <param name="ConversionPattern" value = "%K xx %G %U"/>
                  <cspec name="K">
                      sub { return sprintf "%1x", $$}
                  </cspec>
                  <cspec name="G">
                      sub {return 'thisistheGcspec'}
                  </cspec>
              </log4perl:layout>
      </log4perl:appender>
  
      <log4perl:appender name="DBAppndr2" class="Log::Log4perl::Appender::DBI">
                <param name="warp_message" value="0"/>
                <param name="datasource" value="DBI:CSV:f_dir=t/tmp"/>
                <param name="bufferSize" value="2"/>
                <param name="password" value="sub { $ENV{PWD} }"/>
                <param name="username" value="bobjones"/>
  
                <param-text name="sql">
                    INSERT INTO log4perltest
                              (loglevel, message, shortcaller, thingid,
                              category, pkg, runtime1, runtime2)
                    VALUES
                               (?,?,?,?,?,?,?,?)
                </param-text>
  
                 <param-nested name="params">
                      <param name="1" value="%p"/>
                      <param name="3" value="%5.5l"/>
                      <param name="5" value="%c"/>
                      <param name="6" value="%C"/>
                 </param-nested>
  
                 <layout class="Log::Log4perl::Layout::NoopLayout"/>
      </log4perl:appender>
  
      <category name="animal.dog">
                 <priority value="info"/>
                 <appender-ref ref="jabbender"/>
                 <appender-ref ref="DBAppndr2"/>
      </category>
  
      <category name="plant">
              <priority value="debug"/>
              <appender-ref ref="DBAppndr2"/>
      </category>
  
      <PatternLayout>
          <cspec name="U"><![CDATA[
              sub {
                  return "UID $< GID $(";
              }
          ]]></cspec>
      </PatternLayout>
  
      </log4perl:configuration>
      
  
  
  
  =head1 DESCRIPTION
  
  This module implements an XML config, complementing the properties-style
  config described elsewhere.
  
  =head1 WHY
  
  "Why would I want my config in XML?" you ask.  Well, there are a couple
  reasons you might want to.  Maybe you have a personal preference
  for XML.  Maybe you manage your config with other tools that have an
  affinity for XML, like XML-aware editors or automated config
  generators.  Or maybe (and this is the big one) you don't like
  having to run your application just to check the syntax of your
  config file.
  
  By using an XML config and referencing a DTD, you can use a namespace-aware
  validating parser to see if your XML config at least follows the rules set 
  in the DTD. 
  
  =head1 HOW
  
  To reference a DTD, drop this in after the <?xml...> declaration
  in your config file:
  
      <!DOCTYPE log4perl:configuration SYSTEM "log4perl.dtd">
  
  That tells the parser to validate your config against the DTD in
  "log4perl.dtd", which is available in the xml/ directory of
  the log4perl distribution.  Note that you'll also need to grab
  the log4j-1.2.dtd from there as well, since the it's included
  by log4perl.dtd.
  
  Namespace-aware validating parsers are not the norm in Perl.  
  But the Xerces project 
  (http://xml.apache.org/xerces-c/index.html --lots of binaries available, 
  even rpm's)  does provide just such a parser
  that you can use like this:
  
      StdInParse -ns -v < my-log4perl-config.xml
  
  This module itself does not use a validating parser, the obvious
  one XML::DOM::ValParser doesn't seem to handle namespaces.
  
  =head1 WHY TWO DTDs
  
  The log4j DTD is from the log4j project, they designed it to 
  handle their needs.  log4perl has added some extensions to the 
  original log4j functionality which needed some extensions to the
  log4j DTD.  If you aren't using these features then you can validate
  your config against the log4j dtd and know that you're using
  unadulterated log4j config tags.   
  
  The features added by the log4perl dtd are:
  
  =over 4
  
  =item 1 oneMessagePerAppender global setting
  
      log4perl.oneMessagePerAppender=1
  
  =item 2 globally defined user conversion specifiers
  
      log4perl.PatternLayout.cspec.G=sub { return "UID $< GID $("; }
  
  =item 3 appender-local custom conversion specifiers
  
       log4j.appender.appndr1.layout.cspec.K = sub {return sprintf "%1x", $$ }
  
  =item 4 nested options
  
       log4j.appender.jabbender          = Log::Dispatch::Jabber
       #(note how these are nested under 'login')
       log4j.appender.jabbender.login.hostname = a.jabber.server
       log4j.appender.jabbender.login.port     = 5222
       log4j.appender.jabbender.login.username = bobjones
  
  =item 5 the log4perl-specific filters, see L<Log::Log4perl::Filter>,
  lots of examples in t/044XML-Filter.t, here's a short one:
  
  
    <?xml version="1.0" encoding="UTF-8"?> 
    <!DOCTYPE log4perl:configuration SYSTEM "log4perl.dtd">
  
    <log4perl:configuration xmlns:log4perl="http://log4perl.sourceforge.net/">
     
    <appender name="A1" class="Log::Log4perl::Appender::TestBuffer">
          <layout class="Log::Log4perl::Layout::SimpleLayout"/>
          <filter class="Log::Log4perl::Filter::Boolean">
              <param name="logic" value="!Match3 &amp;&amp; (Match1 || Match2)"/> 
          </filter>
    </appender>   
    
    <appender name="A2" class="Log::Log4perl::Appender::TestBuffer">
          <layout class="Log::Log4perl::Layout::SimpleLayout"/>
          <filter-ref id="Match1"/>
    </appender>   
    
    <log4perl:filter name="Match1" value="sub { /let this through/ }" />
    
    <log4perl:filter name="Match2">
          sub { 
              /and that, too/ 
          }
     </log4perl:filter>
    
    <log4perl:filter name="Match3" class="Log::Log4perl::Filter::StringMatch">
      <param name="StringToMatch" value="suppress"/>
      <param name="AcceptOnMatch" value="true"/>
    </log4perl:filter>
    
    <log4perl:filter name="MyBoolean" class="Log::Log4perl::Filter::Boolean">
      <param name="logic" value="!Match3 &amp;&amp; (Match1 || Match2)"/>
    </log4perl:filter>
    
     
     <root>
             <priority value="info"/>
             <appender-ref ref="A1"/>
     </root>
     
     </log4perl:configuration>
  
  
  =back
  
  
  So we needed to extend the log4j dtd to cover these additions.
  Now I could have just taken a 'steal this code' approach and mixed
  parts of the log4j dtd into a log4perl dtd, but that would be
  cut-n-paste programming.  So I've used namespaces and
  
  =over 4
  
  =item * 
  
  replaced three elements:
  
  =over 4
  
  =item <log4perl:configuration>
  
  handles #1) and accepts <PatternLayout>
  
  =item <log4perl:appender> 
  
  accepts <param-nested> and <param-text>
  
  =item <log4perl:layout> 
  
  accepts custom cspecs for #3)
  
  =back
  
  =item * 
  
  added a <param-nested> element (complementing the <param> element)
      to handle #4)
  
  =item * 
  
  added a root <PatternLayout> element to handle #2)
  
  =item * 
  
  added <param-text> which lets you put things like perl code
      into escaped CDATA between the tags, so you don't have to worry
      about escaping characters and quotes
  
  =item * 
  
  added <cspec>
  
  =back
  
  See the examples up in the L<"SYNOPSIS"> for how all that gets used.
  
  =head1 WHY NAMESPACES
  
  I liked the idea of using the log4j DTD I<in situ>, so I used namespaces
  to extend it.  If you really don't like having to type <log4perl:appender>
  instead of just <appender>, you can make your own DTD combining
  the two DTDs and getting rid of the namespace prefixes.  Then you can
  validate against that, and log4perl should accept it just fine.
  
  =head1 VARIABLE SUBSTITUTION
  
  This supports variable substitution like C<${foobar}> in text and in 
  attribute values except for appender-ref.  If an environment variable is defined
  for that name, its value is substituted. So you can do stuff like
  
          <param name="${hostname}" value="${hostnameval}.foo.com"/>
          <param-text name="to">${currentsysadmin}@foo.com</param-text>
  
  
  =head1 REQUIRES
  
  To use this module you need XML::DOM installed.  
  
  To use the log4perl.dtd, you'll have to reference it in your XML config,
  and you'll also need to note that log4perl.dtd references the 
  log4j dtd as "log4j-1.2.dtd", so your validator needs to be able
  to find that file as well.  If you don't like having to schlep two
  files around, feel free
  to dump the contents of "log4j-1.2.dtd" into your "log4perl.dtd" file.
  
  =head1 CAVEATS
  
  You can't mix a multiple param-nesteds with the same name, I'm going to
  leave that for now, there's presently no need for a list of structs
  in the config.
  
  =head1 CHANGES
  
  0.03 2/26/2003 Added support for log4perl extensions to the log4j dtd
  
  =head1 SEE ALSO
  
  t/038XML-DOM1.t, t/039XML-DOM2.t for examples
  
  xml/log4perl.dtd, xml/log4j-1.2.dtd
  
  Log::Log4perl::Config
  
  Log::Log4perl::Config::PropertyConfigurator
  
  Log::Log4perl::Config::LDAPConfigurator (coming soon!)
  
  The code is brazenly modeled on log4j's DOMConfigurator class, (by 
  Christopher Taylor, Ceki Gülcü, and Anders Kristensen) and any
  perceived similarity is not coincidental.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG_DOMCONFIGURATOR

$fatpacked{"Log/Log4perl/Config/PropertyConfigurator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_PROPERTYCONFIGURATOR';
  package Log::Log4perl::Config::PropertyConfigurator;
  use Log::Log4perl::Config::BaseConfigurator;
  
  use warnings;
  use strict;
  
  our @ISA = qw(Log::Log4perl::Config::BaseConfigurator);
  
  our %NOT_A_MULT_VALUE = map { $_ => 1 }
      qw(conversionpattern);
  
  #poor man's export
  *eval_if_perl = \&Log::Log4perl::Config::eval_if_perl;
  *compile_if_perl = \&Log::Log4perl::Config::compile_if_perl;
  *unlog4j      = \&Log::Log4perl::Config::unlog4j;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $COMMENT_REGEX = qr/[#;!]/;
  
  ################################################
  sub parse {
  ################################################
      my($self, $newtext) = @_;
  
      $self->text($newtext) if defined $newtext;
  
      my $text = $self->{text};
  
      die "Config parser has nothing to parse" unless defined $text;
  
      my $data = {};
      my %var_subst = ();
  
      while (@$text) {
          local $_ = shift @$text;
          s/^\s*$COMMENT_REGEX.*//;
          next unless /\S/;
      
          my @parts = ();
  
          while (/(.+?)\\\s*$/) {
              my $prev = $1;
              my $next = shift(@$text);
              $next =~ s/^ +//g;  #leading spaces
              $next =~ s/^$COMMENT_REGEX.*//;
              $_ = $prev. $next;
              chomp;
          }
  
          if(my($key, $val) = /(\S+?)\s*=\s*(.*)/) {
  
              my $key_org = $key;
  
              $val =~ s/\s+$//;
  
                  # Everything could potentially be a variable assignment
              $var_subst{$key} = $val;
  
                  # Substitute any variables
              $val =~ s/\$\{(.*?)\}/
                        Log::Log4perl::Config::var_subst($1, \%var_subst)/gex;
  
              $key = unlog4j($key);
  
              my $how_deep = 0;
              my $ptr = $data;
              for my $part (split /\.|::/, $key) {
                  push @parts, $part;
                  $ptr->{$part} = {} unless exists $ptr->{$part};
                  $ptr = $ptr->{$part};
                  ++$how_deep;
              }
  
              #here's where we deal with turning multiple values like this:
              # log4j.appender.jabbender.to = him@a.jabber.server
              # log4j.appender.jabbender.to = her@a.jabber.server
              #into an arrayref like this:
              #to => { value => 
              #       ["him\@a.jabber.server", "her\@a.jabber.server"] },
              # 
              # This only is allowed for properties of appenders
              # not listed in %NOT_A_MULT_VALUE (see top of file).
              if (exists $ptr->{value} && 
                  $how_deep > 2 &&
                  defined $parts[0] && lc($parts[0]) eq "appender" && 
                  defined $parts[2] && ! exists $NOT_A_MULT_VALUE{lc($parts[2])}
                 ) {
                  if (ref ($ptr->{value}) ne 'ARRAY') {
                      my $temp = $ptr->{value};
                      $ptr->{value} = [];
                      push (@{$ptr->{value}}, $temp);
                  }
                  push (@{$ptr->{value}}, $val);
              }else{
                  if(defined $ptr->{value}) {
                      if(! $Log::Log4perl::Logger::NO_STRICT) {
                          die "$key_org redefined";
                      }
                  }
                  $ptr->{value} = $val;
              }
          }
      }
      $self->{data} = $data;
      return $data;
  }
  
  ################################################
  sub value {
  ################################################
    my($self, $path) = @_;
  
    $path = unlog4j($path);
  
    my @p = split /::/, $path;
  
    my $found = 0;
    my $r = $self->{data};
  
    while (my $n = shift @p) {
        if (exists $r->{$n}) {
            $r = $r->{$n};
            $found = 1;
        } else {
            $found = 0;
        }
    }
  
    if($found and exists $r->{value}) {
        return $r->{value};
    } else {
        return undef;
    }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config::PropertyConfigurator - reads properties file
  
  =head1 SYNOPSIS
  
      # This class is used internally by Log::Log4perl
  
      use Log::Log4perl::Config::PropertyConfigurator;
  
      my $conf = Log::Log4perl::Config::PropertyConfigurator->new();
      $conf->file("l4p.conf");
      $conf->parse(); # will die() on error
  
      my $value = $conf->value("log4perl.appender.LOGFILE.filename");
     
      if(defined $value) {
          printf("The appender's file name is $value\n");
      } else {
          printf("The appender's file name is not defined.\n");
      }
  
  =head1 DESCRIPTION
  
  Initializes log4perl from a properties file, stuff like
  
      log4j.category.a.b.c.d = WARN, A1
      log4j.category.a.b = INFO, A1
  
  It also understands variable substitution, the following
  configuration is equivalent to the previous one:
  
      settings = WARN, A1
      log4j.category.a.b.c.d = ${settings}
      log4j.category.a.b = INFO, A1
  
  =head1 SEE ALSO
  
  Log::Log4perl::Config
  
  Log::Log4perl::Config::BaseConfigurator
  
  Log::Log4perl::Config::DOMConfigurator
  
  Log::Log4perl::Config::LDAPConfigurator (tbd!)
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG_PROPERTYCONFIGURATOR

$fatpacked{"Log/Log4perl/Config/Watch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_CONFIG_WATCH';
  package Log::Log4perl::Config::Watch;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our $NEXT_CHECK_TIME;
  our $SIGNAL_CAUGHT;
  
  our $L4P_TEST_CHANGE_DETECTED;
  our $L4P_TEST_CHANGE_CHECKED;
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = { file            => "",
                   check_interval  => 30,
                   l4p_internal    => 0,
                   signal          => undef,
                   %options,
                   _last_checked_at => 0,
                   _last_timestamp  => 0,
                 };
  
      bless $self, $class;
  
      if($self->{signal}) {
              # We're in signal mode, set up the handler
          print "Setting up signal handler for '$self->{signal}'\n" if
              _INTERNAL_DEBUG;
  
          # save old signal handlers; they belong to other appenders or
          # possibly something else in the consuming application
          my $old_sig_handler = $SIG{$self->{signal}};
          $SIG{$self->{signal}} = sub { 
              print "Caught $self->{signal} signal\n" if _INTERNAL_DEBUG;
              $self->force_next_check();
              $old_sig_handler->(@_) if $old_sig_handler and ref $old_sig_handler eq 'CODE';
          };
              # Reset the marker. The handler is going to modify it.
          $self->{signal_caught} = 0;
          $SIGNAL_CAUGHT = 0 if $self->{l4p_internal};
      } else {
              # Just called to initialize
          $self->change_detected(undef, 1);
          $self->file_has_moved(undef, 1);
      }
  
      return $self;
  }
  
  ###########################################
  sub force_next_check {
  ###########################################
      my($self) = @_;
  
      $self->{signal_caught}   = 1;
      $self->{next_check_time} = 0;
  
      if( $self->{l4p_internal} ) {
          $SIGNAL_CAUGHT = 1;
          $NEXT_CHECK_TIME = 0;
      }
  }
  
  ###########################################
  sub force_next_check_reset {
  ###########################################
      my($self) = @_;
  
      $self->{signal_caught} = 0;
      $SIGNAL_CAUGHT = 0 if $self->{l4p_internal};
  }
  
  ###########################################
  sub file {
  ###########################################
      my($self) = @_;
  
      return $self->{file};
  }
  
  ###########################################
  sub signal {
  ###########################################
      my($self) = @_;
  
      return $self->{signal};
  }
  
  ###########################################
  sub check_interval {
  ###########################################
      my($self) = @_;
  
      return $self->{check_interval};
  }
  
  ###########################################
  sub file_has_moved {
  ###########################################
      my($self, $time, $force) = @_;
  
      my $task = sub {
          my @stat = stat($self->{file});
  
          my $has_moved = 0;
  
          if(! $stat[0]) {
              # The file's gone, obviously it got moved or deleted.
              print "File is gone\n" if _INTERNAL_DEBUG;
              return 1;
          }
  
          my $current_inode = "$stat[0]:$stat[1]";
          print "Current inode: $current_inode\n" if _INTERNAL_DEBUG;
  
          if(exists $self->{_file_inode} and 
              $self->{_file_inode} ne $current_inode) {
              print "Inode changed from $self->{_file_inode} to ",
                    "$current_inode\n" if _INTERNAL_DEBUG;
              $has_moved = 1;
          }
  
          $self->{_file_inode} = $current_inode;
          return $has_moved;
      };
  
      return $self->check($time, $task, $force);
  }
  
  ###########################################
  sub change_detected {
  ###########################################
      my($self, $time, $force) = @_;
  
      my $task = sub {
          my @stat = stat($self->{file});
          my $new_timestamp = $stat[9];
  
          $L4P_TEST_CHANGE_CHECKED = 1;
  
          if(! defined $new_timestamp) {
              if($self->{l4p_internal}) {
                  # The file is gone? Let it slide, we don't want L4p to re-read
                  # the config now, it's gonna die.
                  return undef;
              }
              $L4P_TEST_CHANGE_DETECTED = 1;
              return 1;
          }
  
          if($new_timestamp > $self->{_last_timestamp}) {
              $self->{_last_timestamp} = $new_timestamp;
              print "Change detected (file=$self->{file} store=$new_timestamp)\n"
                    if _INTERNAL_DEBUG;
              $L4P_TEST_CHANGE_DETECTED = 1;
              return 1; # Has changed
          }
             
          print "$self->{file} unchanged (file=$new_timestamp ",
                "stored=$self->{_last_timestamp})!\n" if _INTERNAL_DEBUG;
          return "";  # Hasn't changed
      };
  
      return $self->check($time, $task, $force);
  }
  
  ###########################################
  sub check {
  ###########################################
      my($self, $time, $task, $force) = @_;
  
      $time = time() unless defined $time;
  
      if( $self->{signal_caught} or $SIGNAL_CAUGHT ) {
         $force = 1;
         $self->force_next_check_reset();
         print "Caught signal, forcing check\n" if _INTERNAL_DEBUG;
  
      }
  
      print "Soft check (file=$self->{file} time=$time)\n" if _INTERNAL_DEBUG;
  
          # Do we need to check?
      if(!$force and
         $self->{_last_checked_at} + 
         $self->{check_interval} > $time) {
          print "No need to check\n" if _INTERNAL_DEBUG;
          return ""; # don't need to check, return false
      }
         
      $self->{_last_checked_at} = $time;
  
      # Set global var for optimizations in case we just have one watcher
      # (like in Log::Log4perl)
      $self->{next_check_time} = $time + $self->{check_interval};
      $NEXT_CHECK_TIME = $self->{next_check_time} if $self->{l4p_internal};
  
      print "Hard check (file=$self->{file} time=$time)\n" if _INTERNAL_DEBUG;
      return $task->($time);
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Config::Watch - Detect file changes
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Config::Watch;
  
      my $watcher = Log::Log4perl::Config::Watch->new(
                            file            => "/data/my.conf",
                            check_interval  => 30,
                    );
  
      while(1) {
          if($watcher->change_detected()) {
              print "Change detected!\n";
          }
          sleep(1);
      }
  
  =head1 DESCRIPTION
  
  This module helps detecting changes in files. Although it comes with the
  C<Log::Log4perl> distribution, it can be used independently.
  
  The constructor defines the file to be watched and the check interval 
  in seconds. Subsequent calls to C<change_detected()> will 
  
  =over 4
  
  =item *
  
  return a false value immediately without doing physical file checks
  if C<check_interval> hasn't elapsed.
  
  =item *
  
  perform a physical test on the specified file if the number
  of seconds specified in C<check_interval> 
  have elapsed since the last physical check. If the file's modification
  date has changed since the last physical check, it will return a true 
  value, otherwise a false value is returned.
  
  =back
  
  Bottom line: C<check_interval> allows you to call the function
  C<change_detected()> as often as you like, without paying the performing
  a significant performance penalty because file system operations 
  are being performed (however, you pay the price of not knowing about
  file changes until C<check_interval> seconds have elapsed).
  
  The module clearly distinguishes system time from file system time. 
  If your (e.g. NFS mounted) file system is off by a constant amount
  of time compared to the executing computer's clock, it'll just
  work fine.
  
  To disable the resource-saving delay feature, just set C<check_interval> 
  to 0 and C<change_detected()> will run a physical file test on
  every call.
  
  If you already have the current time available, you can pass it
  on to C<change_detected()> as an optional parameter, like in
  
      change_detected($time)
  
  which then won't trigger a call to C<time()>, but use the value
  provided.
  
  =head2 SIGNAL MODE
  
  Instead of polling time and file changes, C<new()> can be instructed 
  to set up a signal handler. If you call the constructor like
  
      my $watcher = Log::Log4perl::Config::Watch->new(
                            file    => "/data/my.conf",
                            signal  => 'HUP'
                    );
  
  then a signal handler will be installed, setting the object's variable 
  C<$self-E<gt>{signal_caught}> to a true value when the signal arrives.
  Comes with all the problems that signal handlers go along with.
  
  =head2 TRIGGER CHECKS
  
  To trigger a physical file check on the next call to C<change_detected()>
  regardless if C<check_interval> has expired or not, call
  
      $watcher->force_next_check();
  
  on the watcher object.
  
  =head2 DETECT MOVED FILES
  
  The watcher can also be used to detect files that have moved. It will 
  not only detect if a watched file has disappeared, but also if it has
  been replaced by a new file in the meantime.
  
      my $watcher = Log::Log4perl::Config::Watch->new(
          file           => "/data/my.conf",
          check_interval => 30,
      );
  
      while(1) {
          if($watcher->file_has_moved()) {
              print "File has moved!\n";
          }
          sleep(1);
      }
  
  The parameters C<check_interval> and C<signal> limit the number of physical 
  file system checks, similarily as with C<change_detected()>.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_CONFIG_WATCH

$fatpacked{"Log/Log4perl/DateFormat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_DATEFORMAT';
  ###########################################
  package Log::Log4perl::DateFormat;
  ###########################################
  use warnings;
  use strict;
  
  use Carp qw( croak );
  
  our $GMTIME = 0;
  
  my @MONTH_NAMES = qw(
  January February March April May June July
  August September October November December);
  
  my @WEEK_DAYS = qw(
  Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
  
  ###########################################
  sub new {
  ###########################################
      my($class, $format) = @_;
  
      my $self = { 
                    stack => [],
                    fmt   => undef,
                 };
  
      bless $self, $class;
  
          # Predefined formats
      if($format eq "ABSOLUTE") {
          $format = "HH:mm:ss,SSS";
      } elsif($format eq "DATE") {
          $format = "dd MMM yyyy HH:mm:ss,SSS";
      } elsif($format eq "ISO8601") {
          $format = "yyyy-MM-dd HH:mm:ss,SSS";
      } elsif($format eq "APACHE") {
          $format = "[EEE MMM dd HH:mm:ss yyyy]";
      }
  
      if($format) { 
          $self->prepare($format);
      }
  
      return $self;
  }
  
  ###########################################
  sub prepare {
  ###########################################
      my($self, $format) = @_;
  
      # the actual DateTime spec allows for literal text delimited by
      # single quotes; a single quote can be embedded in the literal
      # text by using two single quotes.
      #
      # my strategy here is to split the format into active and literal
      # "chunks"; active chunks are prepared using $self->rep() as
      # before, while literal chunks get transformed to accommodate
      # single quotes and to protect percent signs.
      #
      # motivation: the "recommended" ISO-8601 date spec for a time in
      # UTC is actually:
      #
      #     YYYY-mm-dd'T'hh:mm:ss.SSS'Z'
  
      my $fmt = "";
  
      foreach my $chunk ( split /('(?:''|[^'])*')/, $format ) {
          if ( $chunk =~ /\A'(.*)'\z/ ) {
                # literal text
              my $literal = $1;
              $literal =~ s/''/'/g;
              $literal =~ s/\%/\%\%/g;
              $fmt .= $literal;
          } elsif ( $chunk =~ /'/ ) {
                # single quotes should always be in a literal
              croak "bad date format \"$format\": " .
                    "unmatched single quote in chunk \"$chunk\"";
          } else {
              # handle active chunks just like before
              $chunk =~ s/(([GyMdhHmsSEeDFwWakKzZ])\2*)/$self->rep($1)/ge;
              $fmt .= $chunk;
          }
      }
  
      return $self->{fmt} = $fmt;
  }
  
  ###########################################
  sub rep {
  ###########################################
      my ($self, $string) = @_;
  
      my $first = substr $string, 0, 1;
      my $len   = length $string;
  
      my $time=time();
      my @g = gmtime($time);
      my @t = localtime($time);
      my $z = $t[1]-$g[1]+($t[2]-$g[2])*60+($t[7]-$g[7])*1440+
              ($t[5]-$g[5])*(525600+(abs($t[7]-$g[7])>364)*1440);
      my $offset = sprintf("%+.2d%.2d", $z/60, "00");
  
      #my ($s,$mi,$h,$d,$mo,$y,$wd,$yd,$dst) = localtime($time);
  
      # Here's how this works:
      # Detect what kind of parameter we're dealing with and determine
      # what type of sprintf-placeholder to return (%d, %02d, %s or whatever).
      # Then, we're setting up an array, specific to the current format,
      # that can be used later on to compute the components of the placeholders
      # one by one when we get the components of the current time later on
      # via localtime.
      
      # So, we're parsing the "yyyy/MM" format once, replace it by, say
      # "%04d:%02d" and store an array that says "for the first placeholder,
      # get the localtime-parameter on index #5 (which is years since the
      # epoch), add 1900 to it and pass it on to sprintf(). For the 2nd 
      # placeholder, get the localtime component at index #2 (which is hours)
      # and pass it on unmodified to sprintf.
      
      # So, the array to compute the time format at logtime contains
      # as many elements as the original SimpleDateFormat contained. Each
      # entry is a array ref, holding an array with 2 elements: The index
      # into the localtime to obtain the value and a reference to a subroutine
      # to do computations eventually. The subroutine expects the original
      # localtime() time component (like year since the epoch) and returns
      # the desired value for sprintf (like y+1900).
  
      # This way, we're parsing the original format only once (during system
      # startup) and during runtime all we do is call localtime *once* and
      # run a number of blazingly fast computations, according to the number
      # of placeholders in the format.
  
  ###########
  #G - epoch#
  ###########
      if($first eq "G") {
          # Always constant
          return "AD";
  
  ###################
  #e - epoch seconds#
  ###################
      } elsif($first eq "e") {
            # index (0) irrelevant, but we return time() which 
            # comes in as 2nd parameter
          push @{$self->{stack}}, [0, sub { return $_[1] }];
          return "%d";
  
  ##########
  #y - year#
  ##########
      } elsif($first eq "y") {
          if($len >= 4) {
              # 4-digit year
              push @{$self->{stack}}, [5, sub { return $_[0] + 1900 }];
              return "%04d";
          } else {
              # 2-digit year
              push @{$self->{stack}}, [5, sub { $_[0] % 100 }];
              return "%02d";
          }
  
  ###########
  #M - month#
  ###########
      } elsif($first eq "M") {
          if($len >= 3) {
              # Use month name
              push @{$self->{stack}}, [4, sub { return $MONTH_NAMES[$_[0]] }];
             if($len >= 4) {
                  return "%s";
              } else {
                 return "%.3s";
              }
          } elsif($len == 2) {
              # Use zero-padded month number
              push @{$self->{stack}}, [4, sub { $_[0]+1 }];
              return "%02d";
          } else {
              # Use zero-padded month number
              push @{$self->{stack}}, [4, sub { $_[0]+1 }];
              return "%d";
          }
  
  ##################
  #d - day of month#
  ##################
      } elsif($first eq "d") {
          push @{$self->{stack}}, [3, sub { return $_[0] }];
          return "%0" . $len . "d";
  
  ##################
  #h - am/pm hour#
  ##################
      } elsif($first eq "h") {
          push @{$self->{stack}}, [2, sub { ($_[0] % 12) || 12 }];
          return "%0" . $len . "d";
  
  ##################
  #H - 24 hour#
  ##################
      } elsif($first eq "H") {
          push @{$self->{stack}}, [2, sub { return $_[0] }];
          return "%0" . $len . "d";
  
  ##################
  #m - minute#
  ##################
      } elsif($first eq "m") {
          push @{$self->{stack}}, [1, sub { return $_[0] }];
          return "%0" . $len . "d";
  
  ##################
  #s - second#
  ##################
      } elsif($first eq "s") {
          push @{$self->{stack}}, [0, sub { return $_[0] }];
          return "%0" . $len . "d";
  
  ##################
  #E - day of week #
  ##################
      } elsif($first eq "E") {
          push @{$self->{stack}}, [6, sub { $WEEK_DAYS[$_[0]] }];
         if($len >= 4) {
              return "%${len}s";
          } else {
             return "%.3s";
          }
  
  ######################
  #D - day of the year #
  ######################
      } elsif($first eq "D") {
          push @{$self->{stack}}, [7, sub { $_[0] + 1}];
          return "%0" . $len . "d";
  
  ######################
  #a - am/pm marker    #
  ######################
      } elsif($first eq "a") {
          push @{$self->{stack}}, [2, sub { $_[0] < 12 ? "AM" : "PM" }];
          return "%${len}s";
  
  ######################
  #S - milliseconds    #
  ######################
      } elsif($first eq "S") {
          push @{$self->{stack}}, 
               [9, sub { substr sprintf("%06d", $_[0]), 0, $len }];
          return "%s";
  
  ###############################
  #Z - RFC 822 time zone  -0800 #
  ###############################
      } elsif($first eq "Z") {
          push @{$self->{stack}}, [10, sub { $offset }];
          return "$offset";
  
  #############################
  #Something that's not defined
  #(F=day of week in month
  # w=week in year W=week in month
  # k=hour in day K=hour in am/pm
  # z=timezone
  #############################
      } else {
          return "-- '$first' not (yet) implemented --";
      }
  
      return $string;
  }
  
  ###########################################
  sub format {
  ###########################################
      my($self, $secs, $msecs) = @_;
  
      $msecs = 0 unless defined $msecs;
  
      my @time; 
  
      if($GMTIME) {
          @time = gmtime($secs);
      } else {
          @time = localtime($secs);
      }
  
          # add milliseconds
      push @time, $msecs;
  
      my @values = ();
  
      for(@{$self->{stack}}) {
          my($val, $code) = @$_;
          if($code) {
              push @values, $code->($time[$val], $secs);
          } else {
              push @values, $time[$val];
          }
      }
  
      return sprintf($self->{fmt}, @values);
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::DateFormat - Log4perl advanced date formatter helper class
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::DateFormat;
  
      my $format = Log::Log4perl::DateFormat->new("HH:mm:ss,SSS");
  
      # Simple time, resolution in seconds
      my $time = time();
      print $format->format($time), "\n";
          # => "17:02:39,000"
  
      # Advanced time, resultion in milliseconds
      use Time::HiRes;
      my ($secs, $msecs) = Time::HiRes::gettimeofday();
      print $format->format($secs, $msecs), "\n";
          # => "17:02:39,959"
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::DateFormat> is a low-level helper class for the 
  advanced date formatting functions in C<Log::Log4perl::Layout::PatternLayout>.
  
  Unless you're writing your own Layout class like
  L<Log::Log4perl::Layout::PatternLayout>, there's probably not much use
  for you to read this.
  
  C<Log::Log4perl::DateFormat> is a formatter which allows dates to be
  formatted according to the log4j spec on
  
      http://download.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html
  
  which allows the following placeholders to be recognized and processed:
  
      Symbol Meaning              Presentation    Example
      ------ -------              ------------    -------
      G      era designator       (Text)          AD
      e      epoch seconds        (Number)        1315011604
      y      year                 (Number)        1996
      M      month in year        (Text & Number) July & 07
      d      day in month         (Number)        10
      h      hour in am/pm (1~12) (Number)        12
      H      hour in day (0~23)   (Number)        0
      m      minute in hour       (Number)        30
      s      second in minute     (Number)        55
      S      millisecond          (Number)        978
      E      day in week          (Text)          Tuesday
      D      day in year          (Number)        189
      F      day of week in month (Number)        2 (2nd Wed in July)
      w      week in year         (Number)        27
      W      week in month        (Number)        2
      a      am/pm marker         (Text)          PM
      k      hour in day (1~24)   (Number)        24
      K      hour in am/pm (0~11) (Number)        0
      z      time zone            (Text)          Pacific Standard Time
      Z      RFC 822 time zone    (Text)          -0800
      '      escape for text      (Delimiter)
      ''     single quote         (Literal)       '
  
  For example, if you want to format the current Unix time in 
  C<"MM/dd HH:mm"> format, all you have to do is this:
  
      use Log::Log4perl::DateFormat;
  
      my $format = Log::Log4perl::DateFormat->new("MM/dd HH:mm");
  
      my $time = time();
      print $format->format($time), "\n";
  
  While the C<new()> method is expensive, because it parses the format
  strings and sets up all kinds of structures behind the scenes, 
  followup calls to C<format()> are fast, because C<DateFormat> will
  just call C<localtime()> and C<sprintf()> once to return the formatted
  date/time string.
  
  So, typically, you would initialize the formatter once and then reuse
  it over and over again to display all kinds of time values.
  
  Also, for your convenience, 
  the following predefined formats are available, just as outlined in the
  log4j spec:
  
      Format   Equivalent                     Example
      ABSOLUTE "HH:mm:ss,SSS"                 "15:49:37,459"
      DATE     "dd MMM yyyy HH:mm:ss,SSS"     "06 Nov 1994 15:49:37,459"
      ISO8601  "yyyy-MM-dd HH:mm:ss,SSS"      "1999-11-27 15:49:37,459"
      APACHE   "[EEE MMM dd HH:mm:ss yyyy]"   "[Wed Mar 16 15:49:37 2005]"
  
  So, instead of passing 
  
      Log::Log4perl::DateFormat->new("HH:mm:ss,SSS");
  
  you could just as well say
  
      Log::Log4perl::DateFormat->new("ABSOLUTE");
  
  and get the same result later on.
  
  =head2 Known Shortcomings
   
  The following placeholders are currently I<not> recognized, unless
  someone (and that could be you :) implements them:
  
      F day of week in month
      w week in year 
      W week in month
      k hour in day 
      K hour in am/pm
      z timezone (but we got 'Z' for the numeric time zone value)
  
  Also, C<Log::Log4perl::DateFormat> just knows about English week and
  month names, internationalization support has to be added.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_DATEFORMAT

$fatpacked{"Log/Log4perl/FAQ.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FAQ';
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::FAQ - Frequently Asked Questions on Log::Log4perl
  
  =head1 DESCRIPTION
  
  This FAQ shows a wide variety of
  commonly encountered logging tasks and how to solve them
  in the most elegant way with Log::Log4perl. Most of the time, this will
  be just a matter of smartly configuring your Log::Log4perl configuration files.
  
  =head2 Why use Log::Log4perl instead of any other logging module on CPAN?
  
  That's a good question. There's dozens of logging modules on CPAN.
  When it comes to logging, people typically think: "Aha. Writing out
  debug and error messages. Debug is lower than error. Easy. I'm gonna
  write my own." Writing a logging module is like a rite of passage for
  every Perl programmer, just like writing your own templating system.
  
  Of course, after getting the basics right, features need to
  be added. You'd like to write a timestamp with every message. Then
  timestamps with microseconds. Then messages need to be written to both
  the screen and a log file.
  
  And, as your application grows in size you might wonder: Why doesn't
  my logging system scale along with it? You would like to switch on
  logging in selected parts of the application, and not all across the
  board, because this kills performance. This is when people turn to
  Log::Log4perl, because it handles all of that.
  
  Avoid this costly switch.
  
  Use C<Log::Log4perl> right from the start. C<Log::Log4perl>'s C<:easy>
  mode supports easy logging in simple scripts:
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      DEBUG "A low-level message";
      ERROR "Won't make it until level gets increased to ERROR";
  
  And when your application inevitably grows, your logging system grows
  with it without you having to change any code.
  
  Please, don't re-invent logging. C<Log::Log4perl> is here, it's easy
  to use, it scales, and covers many areas you haven't thought of yet,
  but will enter soon.
  
  =head2 What's the easiest way to use Log4perl?
  
  If you just want to get all the comfort of logging, without much
  overhead, use I<Stealth Loggers>. If you use Log::Log4perl in
  C<:easy> mode like
  
      use Log::Log4perl qw(:easy);
  
  you'll have the following functions available in the current package:
  
      DEBUG("message");
      INFO("message");
      WARN("message");
      ERROR("message");
      FATAL("message");
  
  Just make sure that every package of your code where you're using them in
  pulls in C<use Log::Log4perl qw(:easy)> first, then you're set.
  Every stealth logger's category will be equivalent to the name of the
  package it's located in.
  
  These stealth loggers
  will be absolutely silent until you initialize Log::Log4perl in
  your main program with either
  
          # Define any Log4perl behavior
      Log::Log4perl->init("foo.conf");
  
  (using a full-blown Log4perl config file) or the super-easy method
  
          # Just log to STDERR
      Log::Log4perl->easy_init($DEBUG);
  
  or the parameter-style method with a complexity somewhat in between:
  
          # Append to a log file
      Log::Log4perl->easy_init( { level   => $DEBUG,
                                  file    => ">>test.log" } );
  
  For more info, please check out L<Log::Log4perl/"Stealth Loggers">.
  
  =head2 How can I simply log all my ERROR messages to a file?
  
  After pulling in the C<Log::Log4perl> module, just initialize its
  behavior by passing in a configuration to its C<init> method as a string
  reference. Then, obtain a logger instance and write out a message
  with its C<error()> method:
  
      use Log::Log4perl qw(get_logger);
  
          # Define configuration
      my $conf = q(
          log4perl.logger                    = ERROR, FileApp
          log4perl.appender.FileApp          = Log::Log4perl::Appender::File
          log4perl.appender.FileApp.filename = test.log
          log4perl.appender.FileApp.layout   = PatternLayout
          log4perl.appender.FileApp.layout.ConversionPattern = %d> %m%n
      );
  
          # Initialize logging behavior
      Log::Log4perl->init( \$conf );
  
          # Obtain a logger instance
      my $logger = get_logger("Bar::Twix");
      $logger->error("Oh my, a dreadful error!");
      $logger->warn("Oh my, a dreadful warning!");
  
  This will append something like
  
      2002/10/29 20:11:55> Oh my, a dreadful error!
  
  to the log file C<test.log>. How does this all work?
  
  While the Log::Log4perl C<init()> method typically
  takes the name of a configuration file as its input parameter like
  in
  
      Log::Log4perl->init( "/path/mylog.conf" );
  
  the example above shows how to pass in a configuration as text in a
  scalar reference.
  
  The configuration as shown
  defines a logger of the root category, which has an appender of type
  C<Log::Log4perl::Appender::File> attached. The line
  
      log4perl.logger = ERROR, FileApp
  
  doesn't list a category, defining a root logger. Compare that with
  
      log4perl.logger.Bar.Twix = ERROR, FileApp
  
  which would define a logger for the category C<Bar::Twix>,
  showing probably different behavior. C<FileApp> on
  the right side of the assignment is
  an arbitrarily defined variable name, which is only used to somehow
  reference an appender defined later on.
  
  Appender settings in the configuration are defined as follows:
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
  
  It selects the file appender of the C<Log::Log4perl::Appender>
  hierarchy, which will append to the file C<test.log> if it already
  exists. If we wanted to overwrite a potentially existing file, we would
  have to explicitly set the appropriate C<Log::Log4perl::Appender::File>
  parameter C<mode>:
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
      log4perl.appender.FileApp.mode     = write
  
  Also, the configuration defines a PatternLayout format, adding
  the nicely formatted current date and time, an arrow (E<gt>) and
  a space before the messages, which is then followed by a newline:
  
      log4perl.appender.FileApp.layout   = PatternLayout
      log4perl.appender.FileApp.layout.ConversionPattern = %d> %m%n
  
  Obtaining a logger instance and actually logging something is typically
  done in a different system part as the Log::Log4perl initialisation section,
  but in this example, it's just done right after init for the
  sake of compactness:
  
          # Obtain a logger instance
      my $logger = get_logger("Bar::Twix");
      $logger->error("Oh my, a dreadful error!");
  
  This retrieves an instance of the logger of the category C<Bar::Twix>,
  which, as all other categories, inherits behavior from the root logger if no
  other loggers are defined in the initialization section.
  
  The C<error()>
  method fires up a message, which the root logger catches. Its
  priority is equal to
  or higher than the root logger's priority (ERROR), which causes the root logger
  to forward it to its attached appender. By contrast, the following
  
      $logger->warn("Oh my, a dreadful warning!");
  
  doesn't make it through, because the root logger sports a higher setting
  (ERROR and up) than the WARN priority of the message.
  
  =head2 How can I install Log::Log4perl on Microsoft Windows?
  
  You can install Log::Log4perl using the CPAN client.
  
  Alternatively you can install it using
  
      ppm install Log-Log4perl
  
  if you're using ActiveState perl.
  
  
  That's it! Afterwards, just create a Perl script like
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      my $logger = get_logger("Twix::Bar");
      $logger->debug("Watch me!");
  
  and run it. It should print something like
  
      2002/11/06 01:22:05 Watch me!
  
  If you find that something doesn't work, please let us know at
  log4perl-devel@lists.sourceforge.net -- we'll appreciate it. Have fun!
  
  =head2 How can I include global (thread-specific) data in my log messages?
  
  Say, you're writing a web application and want all your
  log messages to include the current client's IP address. Most certainly,
  you don't want to include it in each and every log message like in
  
      $logger->debug( $r->connection->remote_ip,
                      " Retrieving user data from DB" );
  
  do you? Instead, you want to set it in a global data structure and
  have Log::Log4perl include it automatically via a PatternLayout setting
  in the configuration file:
  
      log4perl.appender.FileApp.layout.ConversionPattern = %X{ip} %m%n
  
  The conversion specifier C<%X{ip}> references an entry under the key
  C<ip> in the global C<MDC> (mapped diagnostic context) table, which
  you've set once via
  
      Log::Log4perl::MDC->put("ip", $r->connection->remote_ip);
  
  at the start of the request handler. Note that this is a
  I<static> (class) method, there's no logger object involved.
  You can use this method with as many key/value pairs as you like as long
  as you reference them under different names.
  
  The mappings are stored in a global hash table within Log::Log4perl.
  Luckily, because the thread
  model in 5.8.0 doesn't share global variables between threads unless
  they're explicitly marked as such, there's no problem with multi-threaded
  environments.
  
  For more details on the MDC, please refer to
  L<Log::Log4perl/"Mapped Diagnostic Context (MDC)"> and
  L<Log::Log4perl::MDC>.
  
  =head2 My application is already logging to a file. How can I duplicate all messages to also go to the screen?
  
  Assuming that you already have a Log4perl configuration file like
  
      log4perl.logger                    = DEBUG, FileApp
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
      log4perl.appender.FileApp.layout   = PatternLayout
      log4perl.appender.FileApp.layout.ConversionPattern = %d> %m%n
  
  and log statements all over your code,
  it's very easy with Log4perl to have the same messages both printed to
  the logfile and the screen. No reason to change your code, of course,
  just add another appender to the configuration file and you're done:
  
      log4perl.logger                    = DEBUG, FileApp, ScreenApp
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
      log4perl.appender.FileApp.layout   = PatternLayout
      log4perl.appender.FileApp.layout.ConversionPattern = %d> %m%n
  
      log4perl.appender.ScreenApp          = Log::Log4perl::Appender::Screen
      log4perl.appender.ScreenApp.stderr   = 0
      log4perl.appender.ScreenApp.layout   = PatternLayout
      log4perl.appender.ScreenApp.layout.ConversionPattern = %d> %m%n
  
  The configuration file above is assuming that both appenders are
  active in the same logger hierarchy, in this case the C<root> category.
  But even if you've got file loggers defined in several parts of your system,
  belonging to different logger categories,
  each logging to different files, you can gobble up all logged messages
  by defining a root logger with a screen appender, which would duplicate
  messages from all your file loggers to the screen due to Log4perl's
  appender inheritance. Check
  
      http://www.perl.com/pub/a/2002/09/11/log4perl.html
  
  for details. Have fun!
  
  =head2 How can I make sure my application logs a message when it dies unexpectedly?
  
  Whenever you encounter a fatal error in your application, instead of saying
  something like
  
      open FILE, "<blah" or die "Can't open blah -- bailing out!";
  
  just use Log::Log4perl's fatal functions instead:
  
      my $log = get_logger("Some::Package");
      open FILE, "<blah" or $log->logdie("Can't open blah -- bailing out!");
  
  This will both log the message with priority FATAL according to your current
  Log::Log4perl configuration and then call Perl's C<die()>
  afterwards to terminate the program. It works the same with
  stealth loggers (see L<Log::Log4perl/"Stealth Loggers">),
  all you need to do is call
  
      use Log::Log4perl qw(:easy);
      open FILE, "<blah" or LOGDIE "Can't open blah -- bailing out!";
  
  What can you do if you're using some library which doesn't use Log::Log4perl
  and calls C<die()> internally if something goes wrong? Use a
  C<$SIG{__DIE__}> pseudo signal handler
  
      use Log::Log4perl qw(get_logger);
  
      $SIG{__DIE__} = sub {
          if($^S) {
              # We're in an eval {} and don't want log
              # this message but catch it later
              return;
          }
          local $Log::Log4perl::caller_depth =
                $Log::Log4perl::caller_depth + 1;
          my $logger = get_logger("");
          $logger->fatal(@_);
          die @_; # Now terminate really
      };
  
  This will catch every C<die()>-Exception of your
  application or the modules it uses. In case you want to
  It
  will fetch a root logger and pass on the C<die()>-Message to it.
  If you make sure you've configured with a root logger like this:
  
      Log::Log4perl->init(\q{
          log4perl.category         = FATAL, Logfile
          log4perl.appender.Logfile = Log::Log4perl::Appender::File
          log4perl.appender.Logfile.filename = fatal_errors.log
          log4perl.appender.Logfile.layout = \
                     Log::Log4perl::Layout::PatternLayout
          log4perl.appender.Logfile.layout.ConversionPattern = %F{1}-%L (%M)> %m%n
      });
  
  then all C<die()> messages will be routed to a file properly. The line
  
       local $Log::Log4perl::caller_depth =
             $Log::Log4perl::caller_depth + 1;
  
  in the pseudo signal handler above merits a more detailed explanation. With
  the setup above, if a module calls C<die()> in one of its functions,
  the fatal message will be logged in the signal handler and not in the
  original function -- which will cause the %F, %L and %M placeholders
  in the pattern layout to be replaced by the filename, the line number
  and the function/method name of the signal handler, not the error-throwing
  module. To adjust this, Log::Log4perl has the C<$caller_depth> variable,
  which defaults to 0, but can be set to positive integer values
  to offset the caller level. Increasing
  it by one will cause it to log the calling function's parameters, not
  the ones of the signal handler.
  See L<Log::Log4perl/"Using Log::Log4perl from wrapper classes"> for more
  details.
  
  =head2 How can I hook up the LWP library with Log::Log4perl?
  
  Or, to put it more generally: How can you utilize a third-party
  library's embedded logging and debug statements in Log::Log4perl?
  How can you make them print
  to configurable appenders, turn them on and off, just as if they
  were regular Log::Log4perl logging statements?
  
  The easiest solution is to map the third-party library logging statements
  to Log::Log4perl's stealth loggers via a typeglob assignment.
  
  As an example, let's take LWP, one of the most popular Perl modules,
  which makes handling WWW requests and responses a breeze.
  Internally, LWP uses its own logging and debugging system,
  utilizing the following calls
  inside the LWP code (from the LWP::Debug man page):
  
          # Function tracing
      LWP::Debug::trace('send()');
  
          # High-granular state in functions
      LWP::Debug::debug('url ok');
  
          # Data going over the wire
      LWP::Debug::conns("read $n bytes: $data");
  
  First, let's assign Log::Log4perl priorities
  to these functions: I'd suggest that
  C<debug()> messages have priority C<INFO>,
  C<trace()> uses C<DEBUG> and C<conns()> also logs with C<DEBUG> --
  although your mileage may certainly vary.
  
  Now, in order to transparently hook up LWP::Debug with Log::Log4perl,
  all we have to do is say
  
      package LWP::Debug;
      use Log::Log4perl qw(:easy);
  
      *trace = *INFO;
      *conns = *DEBUG;
      *debug = *DEBUG;
  
      package main;
      # ... go on with your regular program ...
  
  at the beginning of our program. In this way, every time the, say,
  C<LWP::UserAgent> module calls C<LWP::Debug::trace()>, it will implicitly
  call INFO(), which is the C<info()> method of a stealth logger defined for
  the Log::Log4perl category C<LWP::Debug>. Is this cool or what?
  
  Here's a complete program:
  
      use LWP::UserAgent;
      use HTTP::Request::Common;
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init(
          { category => "LWP::Debug",
            level    => $DEBUG,
            layout   => "%r %p %M-%L %m%n",
          });
  
      package LWP::Debug;
      use Log::Log4perl qw(:easy);
      *trace = *INFO;
      *conns = *DEBUG;
      *debug = *DEBUG;
  
      package main;
      my $ua = LWP::UserAgent->new();
      my $resp = $ua->request(GET "http://amazon.com");
  
      if($resp->is_success()) {
          print "Success: Received ",
                length($resp->content()), "\n";
      } else {
          print "Error: ", $resp->code(), "\n";
      }
  
  This will generate the following output on STDERR:
  
      174 INFO LWP::UserAgent::new-164 ()
      208 INFO LWP::UserAgent::request-436 ()
      211 INFO LWP::UserAgent::send_request-294 GET http://amazon.com
      212 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied
      405 INFO LWP::Protocol::http::request-122 ()
      859 DEBUG LWP::Protocol::collect-206 read 233 bytes
      863 DEBUG LWP::UserAgent::request-443 Simple response: Found
      869 INFO LWP::UserAgent::request-436 ()
      871 INFO LWP::UserAgent::send_request-294
       GET http://www.amazon.com:80/exec/obidos/gateway_redirect
      872 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied
      873 INFO LWP::Protocol::http::request-122 ()
      1016 DEBUG LWP::UserAgent::request-443 Simple response: Found
      1020 INFO LWP::UserAgent::request-436 ()
      1022 INFO LWP::UserAgent::send_request-294
       GET http://www.amazon.com/exec/obidos/subst/home/home.html/
      1023 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied
      1024 INFO LWP::Protocol::http::request-122 ()
      1382 DEBUG LWP::Protocol::collect-206 read 632 bytes
      ...
      2605 DEBUG LWP::Protocol::collect-206 read 77 bytes
      2607 DEBUG LWP::UserAgent::request-443 Simple response: OK
      Success: Received 42584
  
  Of course, in this way, the embedded logging and debug statements within
  LWP can be utilized in any Log::Log4perl way you can think of. You can
  have them sent to different appenders, block them based on the
  category and everything else Log::Log4perl has to offer.
  
  Only drawback of this method: Steering logging behavior via category
  is always based on the C<LWP::Debug> package. Although the logging
  statements reflect the package name of the issuing module properly,
  the stealth loggers in C<LWP::Debug> are all of the category C<LWP::Debug>.
  This implies that you can't control the logging behavior based on the
  package that's I<initiating> a log request (e.g. LWP::UserAgent) but only
  based on the package that's actually I<executing> the logging statement,
  C<LWP::Debug> in this case.
  
  To work around this conundrum, we need to write a wrapper function and
  plant it into the C<LWP::Debug> package. It will determine the caller and
  create a logger bound to a category with the same name as the caller's
  package:
  
      package LWP::Debug;
  
      use Log::Log4perl qw(:levels get_logger);
  
      sub l4p_wrapper {
          my($prio, @message) = @_;
          $Log::Log4perl::caller_depth += 2;
          get_logger(scalar caller(1))->log($prio, @message);
          $Log::Log4perl::caller_depth -= 2;
      }
  
      no warnings 'redefine';
      *trace = sub { l4p_wrapper($INFO, @_); };
      *debug = *conns = sub { l4p_wrapper($DEBUG, @_); };
  
      package main;
      # ... go on with your main program ...
  
  This is less performant than the previous approach, because every
  log request will request a reference to a logger first, then call
  the wrapper, which will in turn call the appropriate log function.
  
  This hierarchy shift has to be compensated for by increasing
  C<$Log::Log4perl::caller_depth> by 2 before calling the log function
  and decreasing it by 2 right afterwards. Also, the C<l4p_wrapper>
  function shown above calls C<caller(1)> which determines the name
  of the package I<two> levels down the calling hierarchy (and
  therefore compensates for both the wrapper function and the
  anonymous subroutine calling it).
  
  C<no warnings 'redefine'> suppresses a warning Perl would generate
  otherwise
  upon redefining C<LWP::Debug>'s C<trace()>, C<debug()> and C<conns()>
  functions. In case you use a perl prior to 5.6.x, you need
  to manipulate C<$^W> instead.
  
  To make things easy for you when dealing with LWP, Log::Log4perl 0.47
  introduces C<Log::Log4perl-E<gt>infiltrate_lwp()> which does exactly the
  above.
  
  =head2 What if I need dynamic values in a static Log4perl configuration file?
  
  Say, your application uses Log::Log4perl for logging and
  therefore comes with a Log4perl configuration file, specifying the logging
  behavior.
  But, you also want it to take command line parameters to set values
  like the name of the log file.
  How can you have
  both a static Log4perl configuration file and a dynamic command line
  interface?
  
  As of Log::Log4perl 0.28, every value in the configuration file
  can be specified as a I<Perl hook>. So, instead of saying
  
      log4perl.appender.Logfile.filename = test.log
  
  you could just as well have a Perl subroutine deliver the value
  dynamically:
  
      log4perl.appender.Logfile.filename = sub { logfile(); };
  
  given that C<logfile()> is a valid function in your C<main> package
  returning a string containing the path to the log file.
  
  Or, think about using the value of an environment variable:
  
      log4perl.appender.DBI.user = sub { $ENV{USERNAME} };
  
  When C<Log::Log4perl-E<gt>init()> parses the configuration
  file, it will notice the assignment above because of its
  C<sub {...}> pattern and treat it in a special way:
  It will evaluate the subroutine (which can contain
  arbitrary Perl code) and take its return value as the right side
  of the assignment.
  
  A typical application would be called like this on the command line:
  
      app                # log file is "test.log"
      app -l mylog.txt   # log file is "mylog.txt"
  
  Here's some sample code implementing the command line interface above:
  
      use Log::Log4perl qw(get_logger);
      use Getopt::Std;
  
      getopt('l:', \our %OPTS);
  
      my $conf = q(
      log4perl.category.Bar.Twix         = WARN, Logfile
      log4perl.appender.Logfile          = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.filename = sub { logfile(); };
      log4perl.appender.Logfile.layout   = SimpleLayout
      );
  
      Log::Log4perl::init(\$conf);
  
      my $logger = get_logger("Bar::Twix");
      $logger->error("Blah");
  
      ###########################################
      sub logfile {
      ###########################################
          if(exists $OPTS{l}) {
              return $OPTS{l};
          } else {
              return "test.log";
          }
      }
  
  Every Perl hook may contain arbitrary perl code,
  just make sure to fully qualify eventual variable names
  (e.g. C<%main::OPTS> instead of C<%OPTS>).
  
  B<SECURITY NOTE>: this feature means arbitrary perl code
  can be embedded in the config file.  In the rare case
  where the people who have access to your config file
  are different from the people who write your code and
  shouldn't have execute rights, you might want to call
  
      $Log::Log4perl::Config->allow_code(0);
  
  before you call init(). This will prevent Log::Log4perl from
  executing I<any> Perl code in the config file (including
  code for custom conversion specifiers
  (see L<Log::Log4perl::Layout::PatternLayout/"Custom cspecs">).
  
  =head2 How can I roll over my logfiles automatically at midnight?
  
  Long-running applications tend to produce ever-increasing logfiles.
  For backup and cleanup purposes, however, it is often desirable to move
  the current logfile to a different location from time to time and
  start writing a new one.
  
  This is a non-trivial task, because it has to happen in sync with
  the logging system in order not to lose any messages in the process.
  
  Luckily, I<Mark Pfeiffer>'s C<Log::Dispatch::FileRotate> appender
  works well with Log::Log4perl to rotate your logfiles in a variety of ways.
  
  Note, however, that having the application deal with rotating a log
  file is not cheap. Among other things, it requires locking the log file
  with every write to avoid race conditions.
  There are good reasons to use external rotators like C<newsyslog>
  instead.
  See the entry C<How can I rotate a logfile with newsyslog?> in the
  FAQ for more information on how to configure it.
  
  When using C<Log::Dispatch::FileRotate>,
  all you have to do is specify it in your Log::Log4perl configuration file
  and your logfiles will be rotated automatically.
  
  You can choose between rolling based on a maximum size ("roll if greater
  than 10 MB") or based on a date pattern ("roll everyday at midnight").
  In both cases, C<Log::Dispatch::FileRotate> allows you to define a
  number C<max> of saved files to keep around until it starts overwriting
  the oldest ones. If you set the C<max> parameter to 2 and the name of
  your logfile is C<test.log>, C<Log::Dispatch::FileRotate> will
  move C<test.log> to C<test.log.1> on the first rollover. On the second
  rollover, it will move C<test.log.1> to C<test.log.2> and then C<test.log>
  to C<test.log.1>. On the third rollover, it will move C<test.log.1> to
  C<test.log.2> (therefore discarding the old C<test.log.2>) and
  C<test.log> to C<test.log.1>. And so forth. This way, there's always
  going to be a maximum of 2 saved log files around.
  
  Here's an example of a Log::Log4perl configuration file, defining a
  daily rollover at midnight (date pattern C<yyyy-MM-dd>), keeping
  a maximum of 5 saved logfiles around:
  
      log4perl.category         = WARN, Logfile
      log4perl.appender.Logfile = Log::Dispatch::FileRotate
      log4perl.appender.Logfile.filename    = test.log
      log4perl.appender.Logfile.max         = 5
      log4perl.appender.Logfile.DatePattern = yyyy-MM-dd
      log4perl.appender.Logfile.TZ          = PST
      log4perl.appender.Logfile.layout = \
          Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = %d %m %n
  
  Please see the C<Log::Dispatch::FileRotate> documentation for details.
  C<Log::Dispatch::FileRotate> is available on CPAN.
  
  =head2 What's the easiest way to turn off all logging, even with a lengthy Log4perl configuration file?
  
  In addition to category-based levels and appender thresholds,
  Log::Log4perl supports system-wide logging thresholds. This is the
  minimum level the system will require of any logging events in order for them
  to make it through to any configured appenders.
  
  For example, putting the line
  
      log4perl.threshold = ERROR
  
  anywhere in your configuration file will limit any output to any appender
  to events with priority of ERROR or higher (ERROR or FATAL that is).
  
  However, in order to suppress all logging entirely, you need to use a
  priority that's higher than FATAL: It is simply called C<OFF>, and it is never
  used by any logger. By definition, it is higher than the highest
  defined logger level.
  
  Therefore, if you keep the line
  
      log4perl.threshold = OFF
  
  somewhere in your Log::Log4perl configuration, the system will be quiet
  as a graveyard. If you deactivate the line (e.g. by commenting it out),
  the system will, upon config reload, snap back to normal operation, providing
  logging messages according to the rest of the configuration file again.
  
  =head2 How can I log DEBUG and above to the screen and INFO and above to a file?
  
  You need one logger with two appenders attached to it:
  
      log4perl.logger = DEBUG, Screen, File
  
      log4perl.appender.Screen   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
  
      log4perl.appender.File   = Log::Log4perl::Appender::File
      log4perl.appender.File.filename = test.log
      log4perl.appender.File.layout = SimpleLayout
      log4perl.appender.Screen.Threshold = INFO
  
  Since the file logger isn't supposed to get any messages with a priority
  less than INFO, the appender's C<Threshold> setting blocks those out,
  although the logger forwards them.
  
  It's a common mistake to think you can define two loggers for this, but
  it won't work unless those two loggers have different categories. If you
  wanted to log all DEBUG and above messages from the Foo::Bar module to a file
  and all INFO and above messages from the Quack::Schmack module to the
  screen, then you could have defined two loggers with different levels
  C<log4perl.logger.Foo.Bar> (level INFO)
  and C<log4perl.logger.Quack.Schmack> (level DEBUG) and assigned the file
  appender to the former and the screen appender to the latter. But what we
  wanted to accomplish was to route all messages, regardless of which module
  (or category) they came from, to both appenders. The only
  way to accomplish this is to define the root logger with the lower
  level (DEBUG), assign both appenders to it, and block unwanted messages at
  the file appender (C<Threshold> set to INFO).
  
  =head2 I keep getting duplicate log messages! What's wrong?
  
  Having several settings for related categories in the Log4perl
  configuration file sometimes leads to a phenomenon called
  "message duplication". It can be very confusing at first,
  but if thought through properly, it turns out that Log4perl behaves
  as advertised. But, don't despair, of course there's a number of
  ways to avoid message duplication in your logs.
  
  Here's a sample Log4perl configuration file that produces the
  phenomenon:
  
      log4perl.logger.Cat        = ERROR, Screen
      log4perl.logger.Cat.Subcat = WARN, Screen
  
      log4perl.appender.Screen   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
  
  It defines two loggers, one for category C<Cat> and one for
  C<Cat::Subcat>, which is obviously a subcategory of C<Cat>.
  The parent logger has a priority setting of ERROR, the child
  is set to the lower C<WARN> level.
  
  Now imagine the following code in your program:
  
      my $logger = get_logger("Cat.Subcat");
      $logger->warn("Warning!");
  
  What do you think will happen? An unexperienced Log4perl user
  might think: "Well, the message is being sent with level WARN, so the
  C<Cat::Subcat> logger will accept it and forward it to the
  attached C<Screen> appender. Then, the message will percolate up
  the logger hierarchy, find
  the C<Cat> logger, which will suppress the message because of its
  ERROR setting."
  But, perhaps surprisingly, what you'll get with the
  code snippet above is not one but two log messages written
  to the screen:
  
      WARN - Warning!
      WARN - Warning!
  
  What happened? The culprit is that once the logger C<Cat::Subcat>
  decides to fire, it will forward the message I<unconditionally>
  to all directly or indirectly attached appenders. The C<Cat> logger
  will never be asked if it wants the message or not -- the message
  will just be pushed through to the appender attached to C<Cat>.
  
  One way to prevent the message from bubbling up the logger
  hierarchy is to set the C<additivity> flag of the subordinate logger to
  C<0>:
  
      log4perl.logger.Cat            = ERROR, Screen
      log4perl.logger.Cat.Subcat     = WARN, Screen
      log4perl.additivity.Cat.Subcat = 0
  
      log4perl.appender.Screen   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
  
  The message will now be accepted by the C<Cat::Subcat> logger,
  forwarded to its appender, but then C<Cat::Subcat> will suppress
  any further action. While this setting avoids duplicate messages
  as seen before, it is often not the desired behavior. Messages
  percolating up the hierarchy are a useful Log4perl feature.
  
  If you're defining I<different> appenders for the two loggers,
  one other option is to define an appender threshold for the
  higher-level appender. Typically it is set to be
  equal to the logger's level setting:
  
      log4perl.logger.Cat           = ERROR, Screen1
      log4perl.logger.Cat.Subcat    = WARN, Screen2
  
      log4perl.appender.Screen1   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen1.layout = SimpleLayout
      log4perl.appender.Screen1.Threshold = ERROR
  
      log4perl.appender.Screen2   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen2.layout = SimpleLayout
  
  Since the C<Screen1> appender now blocks every message with
  a priority less than ERROR, even if the logger in charge
  lets it through, the message percolating up the hierarchy is
  being blocked at the last minute and I<not> appended to C<Screen1>.
  
  So far, we've been operating well within the boundaries of the
  Log4j standard, which Log4perl adheres to. However, if
  you would really, really like to use a single appender
  and keep the message percolation intact without having to deal
  with message duplication, there's a non-standard solution for you:
  
      log4perl.logger.Cat        = ERROR, Screen
      log4perl.logger.Cat.Subcat = WARN, Screen
  
      log4perl.appender.Screen   = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.layout = SimpleLayout
  
      log4perl.oneMessagePerAppender = 1
  
  The C<oneMessagePerAppender> flag will suppress duplicate messages
  to the same appender. Again, that's non-standard. But way cool :).
  
  =head2 How can I configure Log::Log4perl to send me email if something happens?
  
  Some incidents require immediate action. You can't wait until someone
  checks the log files, you need to get notified on your pager right away.
  
  The easiest way to do that is by using the C<Log::Dispatch::Email::MailSend>
  module as an appender. It comes with the C<Log::Dispatch> bundle and
  allows you to specify recipient and subject of outgoing emails in the Log4perl
  configuration file:
  
      log4perl.category = FATAL, Mailer
      log4perl.appender.Mailer         = Log::Dispatch::Email::MailSend
      log4perl.appender.Mailer.to      = drone@pageme.net
      log4perl.appender.Mailer.subject = Something's broken!
      log4perl.appender.Mailer.layout  = SimpleLayout
  
  The message of every log incident this appender gets
  will then be forwarded to the given
  email address. Check the C<Log::Dispatch::Email::MailSend> documentation
  for details. And please make sure there's not a flood of email messages
  sent out by your application, filling up the recipient's inbox.
  
  There's one caveat you need to know about: The C<Log::Dispatch::Email>
  hierarchy of appenders turns on I<buffering> by default. This means that
  the appender will not send out messages right away but wait until a
  certain threshold has been reached. If you'd rather have your alerts
  sent out immediately, use
  
      log4perl.appender.Mailer.buffered = 0
  
  to turn buffering off.
  
  =head2 How can I write my own appender?
  
  First off, Log::Log4perl comes with a set of standard appenders. Then,
  there's a lot of Log4perl-compatible appenders already
  available on CPAN: Just run a search for C<Log::Dispatch> on
  http://search.cpan.org and chances are that what you're looking for
  has already been developed, debugged and been used successfully
  in production -- no need for you to reinvent the wheel.
  
  Also, Log::Log4perl ships with a nifty database appender named
  Log::Log4perl::Appender::DBI -- check it out if talking to databases is your
  desire.
  
  But if you're up for a truly exotic task, you might have to write
  an appender yourself. That's very easy -- it takes no longer
  than a couple of minutes.
  
  Say, we wanted to create an appender of the class
  C<ColorScreenAppender>, which logs messages
  to the screen in a configurable color. Just create a new class
  in C<ColorScreenAppender.pm>:
  
      package ColorScreenAppender;
  
  Now let's assume that your Log::Log4perl
  configuration file C<test.conf> looks like this:
  
      log4perl.logger = INFO, ColorApp
  
      log4perl.appender.ColorApp=ColorScreenAppender
      log4perl.appender.ColorApp.color=blue
  
      log4perl.appender.ColorApp.layout = PatternLayout
      log4perl.appender.ColorApp.layout.ConversionPattern=%d %m %n
  
  This will cause Log::Log4perl on C<init()> to look for a class
  ColorScreenAppender and call its constructor new(). Let's add
  new() to ColorScreenAppender.pm:
  
      sub new {
          my($class, %options) = @_;
  
          my $self = { %options };
          bless $self, $class;
  
          return $self;
      }
  
  To initialize this appender, Log::Log4perl will call
  and pass all attributes of the appender as defined in the configuration
  file to the constructor as name/value pairs (in this case just one):
  
      ColorScreenAppender->new(color => "blue");
  
  The new() method listed above stores the contents of the
  %options hash in the object's
  instance data hash (referred to by $self).
  That's all for initializing a new appender with Log::Log4perl.
  
  Second, ColorScreenAppender needs to expose a
  C<log()> method, which will be called by Log::Log4perl
  every time it thinks the appender should fire. Along with the
  object reference (as usual in Perl's object world), log()
  will receive a list of name/value pairs, of which only the one
  under the key C<message> shall be of interest for now since it is the
  message string to be logged. At this point, Log::Log4perl has already taken
  care of joining the message to be a single string.
  
  For our special appender ColorScreenAppender, we're using the
  Term::ANSIColor module to colorize the output:
  
      use Term::ANSIColor;
  
      sub log {
          my($self, %params) = @_;
  
          print colored($params{message},
                        $self->{color});
      }
  
  The color (as configured in the Log::Log4perl configuration file)
  is available as $self-E<gt>{color} in the appender object. Don't
  forget to return
  
      1;
  
  at the end of ColorScreenAppender.pm and you're done. Install the new appender
  somewhere where perl can find it and try it with a test script like
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->init("test.conf");
      ERROR("blah");
  
  to see the new colored output. Is this cool or what?
  
  And it gets even better: You can write dynamically generated appender
  classes using the C<Class::Prototyped> module. Here's an example of
  an appender prepending every outgoing message with a configurable
  number of bullets:
  
      use Class::Prototyped;
  
      my $class = Class::Prototyped->newPackage(
        "MyAppenders::Bulletizer",
        bullets => 1,
        log     => sub {
          my($self, %params) = @_;
          print "*" x $self->bullets(),
                $params{message};
        },
      );
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init(\ q{
        log4perl.logger = INFO, Bully
  
        log4perl.appender.Bully=MyAppenders::Bulletizer
        log4perl.appender.Bully.bullets=3
  
        log4perl.appender.Bully.layout = PatternLayout
        log4perl.appender.Bully.layout.ConversionPattern=%m %n
      });
  
          # ... prints: "***Boo!\n";
      INFO "Boo!";
  
  =head2 How can I drill down on references before logging them?
  
  If you've got a reference to a nested structure or object, then
  you probably don't want to log it as C<HASH(0x81141d4)> but rather
  dump it as something like
  
      $VAR1 = {
                'a' => 'b',
                'd' => 'e'
              };
  
  via a module like Data::Dumper. While it's syntactically correct to say
  
      $logger->debug(Data::Dumper::Dumper($ref));
  
  this call imposes a huge performance penalty on your application
  if the message is suppressed by Log::Log4perl, because Data::Dumper
  will perform its expensive operations in any case, because it doesn't
  know that its output will be thrown away immediately.
  
  As of Log::Log4perl 0.28, there's a better way: Use the
  message output filter format as in
  
      $logger->debug( {filter => \&Data::Dumper::Dumper,
                       value  => $ref} );
  
  and Log::Log4perl won't call the filter function unless the message really
  gets written out to an appender. Just make sure to pass the whole slew as a
  reference to a hash specifying a filter function (as a sub reference)
  under the key C<filter> and the value to be passed to the filter function in
  C<value>).
  When it comes to logging, Log::Log4perl will call the filter function,
  pass the C<value> as an argument and log the return value.
  Saves you serious cycles.
  
  =head2 How can I collect all FATAL messages in an extra log file?
  
  Suppose you have employed Log4perl all over your system and you've already
  activated logging in various subsystems. On top of that, without disrupting
  any other settings, how can you collect all FATAL messages all over the system
  and send them to a separate log file?
  
  If you define a root logger like this:
  
      log4perl.logger                  = FATAL, File
      log4perl.appender.File           = Log::Log4perl::Appender::File
      log4perl.appender.File.filename  = /tmp/fatal.txt
      log4perl.appender.File.layout    = PatternLayout
      log4perl.appender.File.layout.ConversionPattern= %d %m %n
          # !!! Something's missing ...
  
  you'll be surprised to not only receive all FATAL messages
  issued anywhere in the system,
  but also everything else -- gazillions of
  ERROR, WARN, INFO and even DEBUG messages will end up in
  your fatal.txt logfile!
  Reason for this is Log4perl's (or better: Log4j's) appender additivity.
  Once a
  lower-level logger decides to fire, the message is going to be forwarded
  to all appenders upstream -- without further priority checks with their
  attached loggers.
  
  There's a way to prevent this, however: If your appender defines a
  minimum threshold, only messages of this priority or higher are going
  to be logged. So, just add
  
      log4perl.appender.File.Threshold = FATAL
  
  to the configuration above, and you'll get what you wanted in the
  first place: An overall system FATAL message collector.
  
  =head2 How can I bundle several log messages into one?
  
  Would you like to tally the messages arriving at your appender and
  dump out a summary once they're exceeding a certain threshold?
  So that something like
  
      $logger->error("Blah");
      $logger->error("Blah");
      $logger->error("Blah");
  
  won't be logged as
  
      Blah
      Blah
      Blah
  
  but as
  
      [3] Blah
  
  instead? If you'd like to hold off on logging a message until it has been
  sent a couple of times, you can roll that out by creating a buffered
  appender.
  
  Let's define a new appender like
  
      package TallyAppender;
  
      sub new {
          my($class, %options) = @_;
  
          my $self = { maxcount => 5,
                       %options
                     };
  
          bless $self, $class;
  
          $self->{last_message}        = "";
          $self->{last_message_count}  = 0;
  
          return $self;
      }
  
  with two additional instance variables C<last_message> and
  C<last_message_count>, storing the content of the last message sent
  and a counter of how many times this has happened. Also, it features
  a configuration parameter C<maxcount> which defaults to 5 in the
  snippet above but can be set in the Log4perl configuration file like this:
  
      log4perl.logger = INFO, A
      log4perl.appender.A=TallyAppender
      log4perl.appender.A.maxcount = 3
  
  The main tallying logic lies in the appender's C<log> method,
  which is called every time Log4perl thinks a message needs to get logged
  by our appender:
  
      sub log {
          my($self, %params) = @_;
  
              # Message changed? Print buffer.
          if($self->{last_message} and
             $params{message} ne $self->{last_message}) {
              print "[$self->{last_message_count}]: " .
                    "$self->{last_message}";
              $self->{last_message_count} = 1;
              $self->{last_message} = $params{message};
              return;
          }
  
          $self->{last_message_count}++;
          $self->{last_message} = $params{message};
  
              # Threshold exceeded? Print, reset counter
          if($self->{last_message_count} >=
             $self->{maxcount}) {
              print "[$self->{last_message_count}]: " .
                    "$params{message}";
              $self->{last_message_count} = 0;
              $self->{last_message}       = "";
              return;
          }
      }
  
  We basically just check if the oncoming message in C<$param{message}>
  is equal to what we've saved before in the C<last_message> instance
  variable. If so, we're increasing C<last_message_count>.
  We print the message in two cases: If the new message is different
  than the buffered one, because then we need to dump the old stuff
  and store the new. Or, if the counter exceeds the threshold, as
  defined by the C<maxcount> configuration parameter.
  
  Please note that the appender always gets the fully rendered message and
  just compares it as a whole -- so if there's a date/timestamp in there,
  that might confuse your logic. You can work around this by specifying
  %m %n as a layout and add the date later on in the appender. Or, make
  the comparison smart enough to omit the date.
  
  At last, don't forget what happens if the program is being shut down.
  If there's still messages in the buffer, they should be printed out
  at that point. That's easy to do in the appender's DESTROY method,
  which gets called at object destruction time:
  
      sub DESTROY {
          my($self) = @_;
  
          if($self->{last_message_count}) {
              print "[$self->{last_message_count}]: " .
                    "$self->{last_message}";
              return;
          }
      }
  
  This will ensure that none of the buffered messages are lost.
  Happy buffering!
  
  =head2 I want to log ERROR and WARN messages to different files! How can I do that?
  
  Let's assume you wanted to have each logging statement written to a
  different file, based on the statement's priority. Messages with priority
  C<WARN> are supposed to go to C</tmp/app.warn>, events prioritized
  as C<ERROR> should end up in C</tmp/app.error>.
  
  Now, if you define two appenders C<AppWarn> and C<AppError>
  and assign them both to the root logger,
  messages bubbling up from any loggers below will be logged by both
  appenders because of Log4perl's message propagation feature. If you limit
  their exposure via the appender threshold mechanism and set
  C<AppWarn>'s threshold to C<WARN> and C<AppError>'s to C<ERROR>, you'll
  still get C<ERROR> messages in C<AppWarn>, because C<AppWarn>'s C<WARN>
  setting will just filter out messages with a I<lower> priority than
  C<WARN> -- C<ERROR> is higher and will be allowed to pass through.
  
  What we need for this is a Log4perl I<Custom Filter>, available with
  Log::Log4perl 0.30.
  
  Both appenders need to verify that
  the priority of the oncoming messages exactly I<matches> the priority
  the appender is supposed to log messages of. To accomplish this task,
  let's define two custom filters, C<MatchError> and C<MatchWarn>, which,
  when attached to their appenders, will limit messages passed on to them
  to those matching a given priority:
  
      log4perl.logger = WARN, AppWarn, AppError
  
          # Filter to match level ERROR
      log4perl.filter.MatchError = Log::Log4perl::Filter::LevelMatch
      log4perl.filter.MatchError.LevelToMatch  = ERROR
      log4perl.filter.MatchError.AcceptOnMatch = true
  
          # Filter to match level WARN
      log4perl.filter.MatchWarn  = Log::Log4perl::Filter::LevelMatch
      log4perl.filter.MatchWarn.LevelToMatch  = WARN
      log4perl.filter.MatchWarn.AcceptOnMatch = true
  
          # Error appender
      log4perl.appender.AppError = Log::Log4perl::Appender::File
      log4perl.appender.AppError.filename = /tmp/app.err
      log4perl.appender.AppError.layout   = SimpleLayout
      log4perl.appender.AppError.Filter   = MatchError
  
          # Warning appender
      log4perl.appender.AppWarn = Log::Log4perl::Appender::File
      log4perl.appender.AppWarn.filename = /tmp/app.warn
      log4perl.appender.AppWarn.layout   = SimpleLayout
      log4perl.appender.AppWarn.Filter   = MatchWarn
  
  The appenders C<AppWarn> and C<AppError> defined above are logging to C</tmp/app.warn> and
  C</tmp/app.err> respectively and have the custom filters C<MatchWarn> and C<MatchError>
  attached.
  This setup will direct all WARN messages, issued anywhere in the system, to /tmp/app.warn (and
  ERROR messages to /tmp/app.error) -- without any overlaps.
  
  =head2 On our server farm, Log::Log4perl configuration files differ slightly from host to host. Can I roll them all into one?
  
  You sure can, because Log::Log4perl allows you to specify attribute values
  dynamically. Let's say that one of your appenders expects the host's IP address
  as one of its attributes. Now, you could certainly roll out different
  configuration files for every host and specify the value like
  
      log4perl.appender.MyAppender    = Log::Log4perl::Appender::SomeAppender
      log4perl.appender.MyAppender.ip = 10.0.0.127
  
  but that's a maintenance nightmare. Instead, you can have Log::Log4perl
  figure out the IP address at configuration time and set the appender's
  value correctly:
  
          # Set the IP address dynamically
      log4perl.appender.MyAppender    = Log::Log4perl::Appender::SomeAppender
      log4perl.appender.MyAppender.ip = sub { \
         use Sys::Hostname; \
         use Socket; \
         return inet_ntoa(scalar gethostbyname hostname); \
      }
  
  If Log::Log4perl detects that an attribute value starts with something like
  C<"sub {...">, it will interpret it as a perl subroutine which is to be executed
  once at configuration time (not runtime!) and its return value is
  to be used as the attribute value. This comes in handy
  for rolling out applications where Log::Log4perl configuration files
  show small host-specific differences, because you can deploy the unmodified
  application distribution on all instances of the server farm.
  
  =head2 Log4perl doesn't interpret my backslashes correctly!
  
  If you're using Log4perl's feature to specify the configuration as a
  string in your program (as opposed to a separate configuration file),
  chances are that you've written it like this:
  
      # *** WRONG! ***
  
      Log::Log4perl->init( \ <<END_HERE);
          log4perl.logger = WARN, A1
          log4perl.appender.A1 = Log::Log4perl::Appender::Screen
          log4perl.appender.A1.layout = \
              Log::Log4perl::Layout::PatternLayout
          log4perl.appender.A1.layout.ConversionPattern = %m%n
      END_HERE
  
      # *** WRONG! ***
  
  and you're getting the following error message:
  
      Layout not specified for appender A1 at .../Config.pm line 342.
  
  What's wrong? The problem is that you're using a here-document with
  substitution enabled (C<E<lt>E<lt>END_HERE>) and that Perl won't
  interpret backslashes at line-ends as continuation characters but
  will essentially throw them out. So, in the code above, the layout line
  will look like
  
      log4perl.appender.A1.layout =
  
  to Log::Log4perl which causes it to report an error. To interpret the backslash
  at the end of the line correctly as a line-continuation character, use
  the non-interpreting mode of the here-document like in
  
      # *** RIGHT! ***
  
      Log::Log4perl->init( \ <<'END_HERE');
          log4perl.logger = WARN, A1
          log4perl.appender.A1 = Log::Log4perl::Appender::Screen
          log4perl.appender.A1.layout = \
              Log::Log4perl::Layout::PatternLayout
          log4perl.appender.A1.layout.ConversionPattern = %m%n
      END_HERE
  
      # *** RIGHT! ***
  
  (note the single quotes around C<'END_HERE'>) or use C<q{...}>
  instead of a here-document and Perl will treat the backslashes at
  line-end as intended.
  
  =head2 I want to suppress certain messages based on their content!
  
  Let's assume you've plastered all your functions with Log4perl
  statements like
  
      sub some_func {
  
          INFO("Begin of function");
  
          # ... Stuff happens here ...
  
          INFO("End of function");
      }
  
  to issue two log messages, one at the beginning and one at the end of
  each function. Now you want to suppress the message at the beginning
  and only keep the one at the end, what can you do? You can't use the category
  mechanism, because both messages are issued from the same package.
  
  Log::Log4perl's custom filters (0.30 or better) provide an interface for the
  Log4perl user to step in right before a message gets logged and decide if
  it should be written out or suppressed, based on the message content or other
  parameters:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl::init( \ <<'EOT' );
          log4perl.logger             = INFO, A1
          log4perl.appender.A1        = Log::Log4perl::Appender::Screen
          log4perl.appender.A1.layout = \
              Log::Log4perl::Layout::PatternLayout
          log4perl.appender.A1.layout.ConversionPattern = %m%n
  
          log4perl.filter.M1 = Log::Log4perl::Filter::StringMatch
          log4perl.filter.M1.StringToMatch = Begin
          log4perl.filter.M1.AcceptOnMatch = false
  
          log4perl.appender.A1.Filter = M1
  EOT
  
  The last four statements in the configuration above are defining a custom
  filter C<M1> of type C<Log::Log4perl::Filter::StringMatch>, which comes with
  Log4perl right out of the box and allows you to define a text pattern to match
  (as a perl regular expression) and a flag C<AcceptOnMatch> indicating
  if a match is supposed to suppress the message or let it pass through.
  
  The last line then assigns this filter to the C<A1> appender, which will
  call it every time it receives a message to be logged and throw all
  messages out I<not> matching the regular expression C<Begin>.
  
  Instead of using the standard C<Log::Log4perl::Filter::StringMatch> filter,
  you can define your own, simply using a perl subroutine:
  
      log4perl.filter.ExcludeBegin  = sub { !/Begin/ }
      log4perl.appender.A1.Filter   = ExcludeBegin
  
  For details on custom filters, check L<Log::Log4perl::Filter>.
  
  =head2 My new module uses Log4perl -- but what happens if the calling program didn't configure it?
  
  If a Perl module uses Log::Log4perl, it will typically rely on the
  calling program to initialize it. If it is using Log::Log4perl in C<:easy>
  mode, like in
  
      package MyMod;
      use Log::Log4perl qw(:easy);
  
      sub foo {
          DEBUG("In foo");
      }
  
      1;
  
  and the calling program doesn't initialize Log::Log4perl at all (e.g. because
  it has no clue that it's available), Log::Log4perl will silently
  ignore all logging messages. However, if the module is using Log::Log4perl
  in regular mode like in
  
      package MyMod;
      use Log::Log4perl qw(get_logger);
  
      sub foo {
          my $logger = get_logger("");
          $logger->debug("blah");
      }
  
      1;
  
  and the main program is just using the module like in
  
      use MyMode;
      MyMode::foo();
  
  then Log::Log4perl will also ignore all logging messages but
  issue a warning like
  
      Log4perl: Seems like no initialization happened.
      Forgot to call init()?
  
  (only once!) to remind novice users to not forget to initialize
  the logging system before using it.
  However, if you want to suppress this message, just
  add the C<:nowarn> target to the module's C<use Log::Log4perl> call:
  
      use Log::Log4perl qw(get_logger :nowarn);
  
  This will have Log::Log4perl silently ignore all logging statements if
  no initialization has taken place. If, instead of using init(), you're
  using Log4perl's API to define loggers and appenders, the same
  notification happens if no call to add_appenders() is made, i.e. no
  appenders are defined.
  
  If the module wants to figure out if some other program part has
  already initialized Log::Log4perl, it can do so by calling
  
      Log::Log4perl::initialized()
  
  which will return a true value in case Log::Log4perl has been initialized
  and a false value if not.
  
  =head2 How can I synchronize access to an appender?
  
  If you're using the same instance of an appender in multiple processes,
  and each process is passing on messages to the appender in parallel,
  you might end up with overlapping log entries.
  
  Typical scenarios include a file appender that you create in the main
  program, and which will then be shared between the parent and a
  forked child process. Or two separate processes, each initializing a
  Log4perl file appender on the same logfile.
  
  Log::Log4perl won't synchronize access to the shared logfile by
  default. Depending on your operating system's flush mechanism,
  buffer size and the size of your messages, there's a small chance of
  an overlap.
  
  The easiest way to prevent overlapping messages in logfiles written to
  by multiple processes is setting the
  file appender's C<syswrite> flag along with a file write mode of C<"append">.
  This makes sure that
  C<Log::Log4perl::Appender::File> uses C<syswrite()> (which is guaranteed
  to run uninterrupted) instead of C<print()> which might buffer
  the message or get interrupted by the OS while it is writing. And in
  C<"append"> mode, the OS kernel ensures that multiple processes share
  one end-of-file marker, ensuring that each process writes to the I<real>
  end of the file. (The value of C<"append">
  for the C<mode> parameter is the default setting in Log4perl's file
  appender so you don't have to set it explicitly.)
  
        # Guarantees atomic writes
  
      log4perl.category.Bar.Twix          = WARN, Logfile
  
      log4perl.appender.Logfile           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.mode      = append
      log4perl.appender.Logfile.syswrite  = 1
      log4perl.appender.Logfile.filename  = test.log
      log4perl.appender.Logfile.layout    = SimpleLayout
  
  Another guaranteed way of having messages separated with any kind of
  appender is putting a Log::Log4perl::Appender::Synchronized composite
  appender in between Log::Log4perl and the real appender. It will make
  sure to let messages pass through this virtual gate one by one only.
  
  Here's a sample configuration to synchronize access to a file appender:
  
      log4perl.category.Bar.Twix          = WARN, Syncer
  
      log4perl.appender.Logfile           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.autoflush = 1
      log4perl.appender.Logfile.filename  = test.log
      log4perl.appender.Logfile.layout    = SimpleLayout
  
      log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized
      log4perl.appender.Syncer.appender   = Logfile
  
  C<Log::Log4perl::Appender::Synchronized> uses
  the C<IPC::Shareable> module and its semaphores, which will slow down writing
  the log messages, but ensures sequential access featuring atomic checks.
  Check L<Log::Log4perl::Appender::Synchronized> for details.
  
  =head2 Can I use Log::Log4perl with log4j's Chainsaw?
  
  Yes, Log::Log4perl can be configured to send its events to log4j's
  graphical log UI I<Chainsaw>.
  
  =for html
  <p>
  <TABLE><TR><TD>
  <A HREF="http://log4perl.sourceforge.net/images/chainsaw2.jpg"><IMG SRC="http://log4perl.sourceforge.net/images/chainsaw2s.jpg"></A>
  <TR><TD>
  <I>Figure 1: Chainsaw receives Log::Log4perl events</I>
  </TABLE>
  <p>
  
  =for text
  Figure1: Chainsaw receives Log::Log4perl events
  
  Here's how it works:
  
  =over 4
  
  =item *
  
  Get Guido Carls' E<lt>gcarls@cpan.orgE<gt> Log::Log4perl extension
  C<Log::Log4perl::Layout::XMLLayout> from CPAN and install it:
  
      perl -MCPAN -eshell
      cpan> install Log::Log4perl::Layout::XMLLayout
  
  =item *
  
  Install and start Chainsaw, which is part of the C<log4j> distribution now
  (see http://jakarta.apache.org/log4j ). Create a configuration file like
  
    <log4j:configuration debug="true">
      <plugin name="XMLSocketReceiver"
              class="org.apache.log4j.net.XMLSocketReceiver">
        <param name="decoder" value="org.apache.log4j.xml.XMLDecoder"/>
        <param name="Port" value="4445"/>
      </plugin>
      <root> <level value="debug"/> </root>
    </log4j:configuration>
  
  and name it e.g. C<config.xml>. Then start Chainsaw like
  
    java -Dlog4j.debug=true -Dlog4j.configuration=config.xml \
      -classpath ".:log4j-1.3alpha.jar:log4j-chainsaw-1.3alpha.jar" \
      org.apache.log4j.chainsaw.LogUI
  
  and watch the GUI coming up.
  
  =item *
  
  Configure Log::Log4perl to use a socket appender with an XMLLayout, pointing
  to the host/port where Chainsaw (as configured above) is waiting with its
  XMLSocketReceiver:
  
    use Log::Log4perl qw(get_logger);
    use Log::Log4perl::Layout::XMLLayout;
  
    my $conf = q(
      log4perl.category.Bar.Twix          = WARN, Appender
      log4perl.appender.Appender          = Log::Log4perl::Appender::Socket
      log4perl.appender.Appender.PeerAddr = localhost
      log4perl.appender.Appender.PeerPort = 4445
      log4perl.appender.Appender.layout   = Log::Log4perl::Layout::XMLLayout
    );
  
    Log::Log4perl::init(\$conf);
  
      # Nasty hack to suppress encoding header
    my $app = Log::Log4perl::appenders->{"Appender"};
    $app->layout()->{enc_set} = 1;
  
    my $logger = get_logger("Bar.Twix");
    $logger->error("One");
  
  The nasty hack shown in the code snippet above is currently (October 2003)
  necessary, because Chainsaw expects XML messages to arrive in a format like
  
    <log4j:event logger="Bar.Twix"
                 timestamp="1066794904310"
                 level="ERROR"
                 thread="10567">
      <log4j:message><![CDATA[Two]]></log4j:message>
      <log4j:NDC><![CDATA[undef]]></log4j:NDC>
      <log4j:locationInfo class="main"
        method="main"
        file="./t"
        line="32">
      </log4j:locationInfo>
    </log4j:event>
  
  without a preceding
  
    <?xml version = "1.0" encoding = "iso8859-1"?>
  
  which Log::Log4perl::Layout::XMLLayout applies to the first event sent
  over the socket.
  
  =back
  
  See figure 1 for a screenshot of Chainsaw in action, receiving events from
  the Perl script shown above.
  
  Many thanks to Chainsaw's
  Scott Deboy <sdeboy@comotivsystems.com> for his support!
  
  =head2 How can I run Log::Log4perl under mod_perl?
  
  In persistent environments it's important to play by the rules outlined
  in section L<Log::Log4perl/"Initialize once and only once">.
  If you haven't read this yet, please go ahead and read it right now. It's
  very important.
  
  And no matter if you use a startup handler to init() Log::Log4perl or use the
  init_once() strategy (added in 0.42), either way you're very likely to have
  unsynchronized writes to logfiles.
  
  If Log::Log4perl is configured with a log file appender, and it is
  initialized via
  the Apache startup handler, the file handle created initially will be
  shared among all Apache processes. Similarly, with the init_once()
  approach: although every process has a separate L4p configuration,
  processes are gonna share the appender file I<names> instead, effectively
  opening several different file handles on the same file.
  
  Now, having several appenders using the same file handle or having
  several appenders logging to the same file unsynchronized, this might
  result in overlapping messages. Sometimes, this is acceptable. If it's
  not, here's two strategies:
  
  =over 4
  
  =item *
  
  Use the L<Log::Log4perl::Appender::Synchronized> appender to connect to
  your file appenders. Here's the writeup:
  http://log4perl.sourceforge.net/releases/Log-Log4perl/docs/html/Log/Log4perl/FAQ.html#23804
  
  =item *
  
  Use a different logfile for every process like in
  
       #log4perl.conf
       ...
       log4perl.appender.A1.filename = sub { "mylog.$$.log" }
  
  =back
  
  =head2 My program already uses warn() and die(). How can I switch to Log4perl?
  
  If your program already uses Perl's C<warn()> function to spew out
  error messages and you'd like to channel those into the Log4perl world,
  just define a C<__WARN__> handler where your program or module resides:
  
      use Log::Log4perl qw(:easy);
  
      $SIG{__WARN__} = sub {
          local $Log::Log4perl::caller_depth =
              $Log::Log4perl::caller_depth + 1;
          WARN @_;
      };
  
  Why the C<local> setting of C<$Log::Log4perl::caller_depth>?
  If you leave that out,
  C<PatternLayout> conversion specifiers like C<%M> or C<%F> (printing
  the current function/method and source filename) will refer
  to where the __WARN__ handler resides, not the environment
  Perl's C<warn()> function was issued from. Increasing C<caller_depth>
  adjusts for this offset. Having it C<local>, makes sure the level
  gets set back after the handler exits.
  
  Once done, if your program does something like
  
      sub some_func {
          warn "Here's a warning";
      }
  
  you'll get (depending on your Log::Log4perl configuration) something like
  
      2004/02/19 20:41:02-main::some_func: Here's a warning at ./t line 25.
  
  in the appropriate appender instead of having a screen full of STDERR
  messages. It also works with the C<Carp> module and its C<carp()>
  and C<cluck()> functions.
  
  If, on the other hand, catching C<die()> and friends is
  required, a C<__DIE__> handler is appropriate:
  
      $SIG{__DIE__} = sub {
          if($^S) {
              # We're in an eval {} and don't want log
              # this message but catch it later
              return;
          }
          local $Log::Log4perl::caller_depth =
              $Log::Log4perl::caller_depth + 1;
          LOGDIE @_;
      };
  
  This will call Log4perl's C<LOGDIE()> function, which will log a fatal
  error and then call die() internally, causing the program to exit. Works
  equally well with C<Carp>'s C<croak()> and C<confess()> functions.
  
  =head2 Some module prints messages to STDERR. How can I funnel them to Log::Log4perl?
  
  If a module you're using doesn't use Log::Log4perl but prints logging
  messages to STDERR instead, like
  
      ########################################
      package IgnorantModule;
      ########################################
  
      sub some_method {
          print STDERR "Parbleu! An error!\n";
      }
  
      1;
  
  there's still a way to capture these messages and funnel them
  into Log::Log4perl, even without touching the module. What you need is
  a trapper module like
  
      ########################################
      package Trapper;
      ########################################
  
      use Log::Log4perl qw(:easy);
  
      sub TIEHANDLE {
          my $class = shift;
          bless [], $class;
      }
  
      sub PRINT {
          my $self = shift;
          $Log::Log4perl::caller_depth++;
          DEBUG @_;
          $Log::Log4perl::caller_depth--;
      }
  
      1;
  
  and a C<tie> command in the main program to tie STDERR to the trapper
  module along with regular Log::Log4perl initialization:
  
      ########################################
      package main;
      ########################################
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init(
          {level  => $DEBUG,
           file   => 'stdout',   # make sure not to use stderr here!
           layout => "%d %M: %m%n",
          });
  
      tie *STDERR, "Trapper";
  
  Make sure not to use STDERR as Log::Log4perl's file appender
  here (which would be the default in C<:easy> mode), because it would
  end up in an endless recursion.
  
  Now, calling
  
      IgnorantModule::some_method();
  
  will result in the desired output
  
      2004/05/06 11:13:04 IgnorantModule::some_method: Parbleu! An error!
  
  =head2 How come PAR (Perl Archive Toolkit) creates executables which then can't find their Log::Log4perl appenders?
  
  If not instructed otherwise, C<Log::Log4perl> dynamically pulls in
  appender classes found in its configuration. If you specify
  
      #!/usr/bin/perl
      # mytest.pl
  
      use Log::Log4perl qw(get_logger);
  
      my $conf = q(
        log4perl.category.Bar.Twix = WARN, Logfile
        log4perl.appender.Logfile  = Log::Log4perl::Appender::Screen
        log4perl.appender.Logfile.layout = SimpleLayout
      );
  
      Log::Log4perl::init(\$conf);
      my $logger = get_logger("Bar::Twix");
      $logger->error("Blah");
  
  then C<Log::Log4perl::Appender::Screen> will be pulled in while the program
  runs, not at compile time. If you have PAR compile the script above to an
  executable binary via
  
      pp -o mytest mytest.pl
  
  and then run C<mytest> on a machine without having Log::Log4perl installed,
  you'll get an error message like
  
      ERROR: can't load appenderclass 'Log::Log4perl::Appender::Screen'
      Can't locate Log/Log4perl/Appender/Screen.pm in @INC ...
  
  Why? At compile time, C<pp> didn't realize that
  C<Log::Log4perl::Appender::Screen> would be needed later on and didn't
  wrap it into the executable created. To avoid this, either say
  C<use Log::Log4perl::Appender::Screen> in the script explicitly or
  compile it with
  
      pp -o mytest -M Log::Log4perl::Appender::Screen mytest.pl
  
  to make sure the appender class gets included.
  
  =head2 How can I access a custom appender defined in the configuration?
  
  Any appender defined in the configuration file or somewhere in the code
  can be accessed later via
  C<Log::Log4perl-E<gt>appender_by_name("appender_name")>,
  which returns a reference of the appender object.
  
  Once you've got a hold of the object, it can be queried or modified to
  your liking. For example, see the custom C<IndentAppender> defined below:
  After calling C<init()> to define the Log4perl settings, the
  appender object is retrieved to call its C<indent_more()> and C<indent_less()>
  methods to control indentation of messages:
  
      package IndentAppender;
  
      sub new {
          bless { indent => 0 }, $_[0];
      }
  
      sub indent_more  { $_[0]->{indent}++ }
      sub indent_less  { $_[0]->{indent}-- }
  
      sub log {
          my($self, %params) = @_;
          print " " x $self->{indent}, $params{message};
      }
  
      package main;
  
      use Log::Log4perl qw(:easy);
  
      my $conf = q(
      log4perl.category          = DEBUG, Indented
      log4perl.appender.Indented = IndentAppender
      log4perl.appender.Indented.layout = Log::Log4perl::Layout::SimpleLayout
      );
  
      Log::Log4perl::init(\$conf);
  
      my $appender = Log::Log4perl->appender_by_name("Indented");
  
      DEBUG "No identation";
      $appender->indent_more();
      DEBUG "One more";
      $appender->indent_more();
      DEBUG "Two more";
      $appender->indent_less();
      DEBUG "One less";
  
  As you would expect, this will print
  
      DEBUG - No identation
       DEBUG - One more
        DEBUG - Two more
       DEBUG - One less
  
  because the very appender used by Log4perl is modified dynamically at
  runtime.
  
  =head2 I don't know if Log::Log4perl is installed. How can I prepare my script?
  
  In case your script needs to be prepared for environments that may or may
  not have Log::Log4perl installed, there's a trick.
  
  If you put the following BEGIN blocks at the top of the program,
  you'll be able to use the DEBUG(), INFO(), etc. macros in
  Log::Log4perl's C<:easy> mode.
  If Log::Log4perl
  is installed in the target environment, the regular Log::Log4perl rules
  apply. If not, all of DEBUG(), INFO(), etc. are "stubbed" out, i.e. they
  turn into no-ops:
  
      use warnings;
      use strict;
  
      BEGIN {
          eval { require Log::Log4perl; };
  
          if($@) {
              print "Log::Log4perl not installed - stubbing.\n";
              no strict qw(refs);
              *{"main::$_"} = sub { } for qw(DEBUG INFO WARN ERROR FATAL);
          } else {
              no warnings;
              print "Log::Log4perl installed - life is good.\n";
              require Log::Log4perl::Level;
              Log::Log4perl::Level->import(__PACKAGE__);
              Log::Log4perl->import(qw(:easy));
              Log::Log4perl->easy_init($main::DEBUG);
          }
      }
  
          # The regular script begins ...
      DEBUG "Hey now!";
  
  This snippet will first probe for Log::Log4perl, and if it can't be found,
  it will alias DEBUG(), INFO(), with empty subroutines via typeglobs.
  If Log::Log4perl is available, its level constants are first imported
  (C<$DEBUG>, C<$INFO>, etc.) and then C<easy_init()> gets called to initialize
  the logging system.
  
  =head2 Can file appenders create files with different permissions?
  
  Typically, when C<Log::Log4perl::Appender::File> creates a new file,
  its permissions are set to C<rw-r--r-->. Why? Because your
  environment's I<umask> most likely defaults to
  C<0022>, that's the standard setting.
  
  What's a I<umask>, you're asking? It's a template that's applied to
  the permissions of all newly created files. While calls like
  C<open(FILE, "E<gt>foo")> will always try to create files in C<rw-rw-rw-
  > mode, the system will apply the current I<umask> template to
  determine the final permission setting. I<umask> is a bit mask that's
  inverted and then applied to the requested permission setting, using a
  bitwise AND:
  
      $request_permission &~ $umask
  
  So, a I<umask> setting of 0000 (the leading 0 simply indicates an
  octal value) will create files in C<rw-rw-rw-> mode, a setting of 0277
  will use C<r-------->, and the standard 0022 will use C<rw-r--r-->.
  
  As an example, if you want your log files to be created with
  C<rw-r--rw-> permissions, use a I<umask> of C<0020> before
  calling Log::Log4perl->init():
  
      use Log::Log4perl;
  
      umask 0020;
          # Creates log.out in rw-r--rw mode
      Log::Log4perl->init(\ q{
          log4perl.logger = WARN, File
          log4perl.appender.File = Log::Log4perl::Appender::File
          log4perl.appender.File.filename = log.out
          log4perl.appender.File.layout = SimpleLayout
      });
  
  =head2 Using Log4perl in an END block causes a problem!
  
  It's not easy to get to this error, but if you write something like
  
      END { Log::Log4perl::get_logger()->debug("Hey there."); }
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
  it won't work. The reason is that C<Log::Log4perl> defines an
  END block that cleans up all loggers. And perl will run END blocks
  in the reverse order as they're encountered in the compile phase,
  so in the scenario above, the END block will run I<after> Log4perl
  has cleaned up its loggers.
  
  Placing END blocks using Log4perl I<after>
  a C<use Log::Log4perl> statement fixes the problem:
  
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      END { Log::Log4perl::get_logger()->debug("Hey there."); }
  
  In this scenario, the shown END block is executed I<before> Log4perl
  cleans up and the debug message will be processed properly.
  
  =head2 Help! My appender is throwing a "Wide character in print" warning!
  
  This warning shows up when Unicode strings are printed without
  precautions. The warning goes away if the complaining appender is
  set to utf-8 mode:
  
        # Either in the log4perl configuration file:
    log4perl.appender.Logfile.filename = test.log
    log4perl.appender.Logfile.utf8     = 1
  
        # Or, in easy mode:
    Log::Log4perl->easy_init( {
      level => $DEBUG,
      file  => ":utf8> test.log"
    } );
  
  If the complaining appender is a screen appender, set its C<utf8> option:
  
        log4perl.appender.Screen.stderr = 1
        log4perl.appender.Screen.utf8   = 1
  
  Alternatively, C<binmode> does the trick:
  
        # Either STDOUT ...
      binmode(STDOUT, ":utf8);
  
        # ... or STDERR.
      binmode(STDERR, ":utf8);
  
  Some background on this: Perl's strings are either byte strings or
  Unicode strings. C<"Mike"> is a byte string.
  C<"\x{30DE}\x{30A4}\x{30AF}"> is a Unicode string. Unicode strings are
  marked specially and are UTF-8 encoded internally.
  
  If you print a byte string to STDOUT,
  all is well, because STDOUT is by default set to byte mode. However,
  if you print a Unicode string to STDOUT without precautions, C<perl>
  will try to transform the Unicode string back to a byte string before
  printing it out. This is troublesome if the Unicode string contains
  'wide' characters which can't be represented in Latin-1.
  
  For example, if you create a Unicode string with three japanese Katakana
  characters as in
  
      perl -le 'print "\x{30DE}\x{30A4}\x{30AF}"'
  
  (coincidentally pronounced Ma-i-ku, the japanese pronunciation of
  "Mike"), STDOUT is in byte mode and the warning
  
      Wide character in print at ./script.pl line 14.
  
  appears. Setting STDOUT to UTF-8 mode as in
  
      perl -le 'binmode(STDOUT, ":utf8"); print "\x{30DE}\x{30A4}\x{30AF}"'
  
  will silently print the Unicode string to STDOUT in UTF-8. To see the
  characters printed, you'll need a UTF-8 terminal with a font including
  japanese Katakana characters.
  
  =head2 How can I send errors to the screen, and debug messages to a file?
  
  Let's assume you want to maintain a detailed DEBUG output in a file
  and only messages of level ERROR and higher should be printed on the
  screen. Often times, developers come up with something like this:
  
       # Wrong!!!
      log4perl.logger = DEBUG, FileApp
      log4perl.logger = ERROR, ScreenApp
       # Wrong!!!
  
  This won't work, however. Logger definitions aren't additive, and the
  second statement will overwrite the first one. Log4perl versions
  below 1.04 were silently accepting this, leaving people confused why
  it wouldn't work as expected.
  As of 1.04, this will throw a I<fatal error> to notify the user of
  the problem.
  
  What you want to do instead, is this:
  
      log4perl.logger                    = DEBUG, FileApp, ScreenApp
  
      log4perl.appender.FileApp          = Log::Log4perl::Appender::File
      log4perl.appender.FileApp.filename = test.log
      log4perl.appender.FileApp.layout   = SimpleLayout
  
      log4perl.appender.ScreenApp          = Log::Log4perl::Appender::Screen
      log4perl.appender.ScreenApp.stderr   = 0
      log4perl.appender.ScreenApp.layout   = SimpleLayout
         ### limiting output to ERROR messages
      log4perl.appender.ScreenApp.Threshold = ERROR
         ###
  
  Note that without the second appender's C<Threshold> setting, both appenders
  would receive all messages prioritized DEBUG and higher. With the
  threshold set to ERROR, the second appender will filter the messages
  as required.
  
  =head2 Where should I put my logfiles?
  
  Your log files may go anywhere you want them, but the effective
  user id of the calling process must have write access.
  
  If the log file doesn't exist at program start, Log4perl's file appender
  will create it. For this, it needs write access to the directory where
  the new file will be located in. If the log file already exists at startup,
  the process simply needs write access to the file. Note that it will
  need write access to the file's directory if you're encountering situations
  where the logfile gets recreated, e.g. during log rotation.
  
  If Log::Log4perl is used by a web server application (e.g. in a CGI script
  or mod_perl), then the webserver's user (usually C<nobody> or C<www>)
  must have the permissions mentioned above.
  
  To prepare your web server to use log4perl, we'd recommend:
  
      webserver:~$ su -
      webserver:~# mkdir /var/log/cgiapps
      webserver:~# chown nobody:root /var/log/cgiapps/
      webserver:~# chown nobody:root -R /var/log/cgiapps/
      webserver:~# chmod 02755 -R /var/log/cgiapps/
  
  Then set your /etc/log4perl.conf file to include:
  
      log4perl.appender.FileAppndr1.filename =
          /var/log/cgiapps/<app-name>.log
  
  =head2 How can my file appender deal with disappearing log files?
  
  The file appender that comes with Log4perl, L<Log::Log4perl::Appender::File>,
  will open a specified log file at initialization time and will
  keep writing to it via a file handle.
  
  In case the associated file goes way, messages written by a
  long-running process will still be written
  to the file handle. In case the file has been moved to a different
  location on the same file system, the writer will keep writing to
  it under the new filename. In case the file has been removed from
  the file system, the log messages will end up in nowhere land. This
  is not a bug in Log4perl, this is how Unix works. There is
  no error message in this case, because the writer has no idea that
  the file handle is not associated with a visible file.
  
  To prevent the loss of log messages when log files disappear, the
  file appender's C<recreate> option needs to be set to a true value:
  
      log4perl.appender.Logfile.recreate = 1
  
  This will instruct the file appender to check in regular intervals
  (default: 30 seconds) if the log file is still there. If it finds
  out that the file is missing, it will recreate it.
  
  Continuously checking if the log file still exists is fairly
  expensive. For this reason it is only performed every 30 seconds. To
  change this interval, the option C<recreate_check_interval> can be set
  to the number of seconds between checks. In the extreme case where the
  check should be performed before every write, it can even be set to 0:
  
      log4perl.appender.Logfile.recreate = 1
      log4perl.appender.Logfile.recreate_check_interval = 0
  
  To avoid having to check the file system so frequently, a signal
  handler can be set up:
  
      log4perl.appender.Logfile.recreate = 1
      log4perl.appender.Logfile.recreate_check_signal = USR1
  
  This will install a signal handler which will recreate a missing log file
  immediately when it receives the defined signal.
  
  Note that the init_and_watch() method for Log4perl's initialization
  can also be instructed to install a signal handler, usually using the
  HUP signal. Make sure to use a different signal if you're using both
  of them at the same time.
  
  =head2 How can I rotate a logfile with newsyslog?
  
  Here's a few things that need to be taken care of when using the popular
  log file rotating utility C<newsyslog>
  (http://www.courtesan.com/newsyslog) with Log4perl's file appender
  in long-running processes.
  
  For example, with a newsyslog configuration like
  
      # newsyslog.conf
      /tmp/test.log 666  12  5  *  B
  
  and a call to
  
      # newsyslog -f /path/to/newsyslog.conf
  
  C<newsyslog> will take action if C</tmp/test.log> is larger than the
  specified 5K in size. It will move the current log file C</tmp/test.log> to
  C</tmp/test.log.0> and create a new and empty C</tmp/test.log> with
  the specified permissions (this is why C<newsyslog> needs to run as root).
  An already existing C</tmp/test.log.0> would be moved to
  C</tmp/test.log.1>, C</tmp/test.log.1> to C</tmp/test.log.2>, and so
  forth, for every one of a max number of 12 archived logfiles that have
  been configured in C<newsyslog.conf>.
  
  Although a new file has been created, from Log4perl's appender's point
  of view, this situation is identical to the one described in the
  previous FAQ entry, labeled C<How can my file appender deal with
  disappearing log files>.
  
  To make sure that log messages are written to the new log file and not
  to an archived one or end up in nowhere land,
  the appender's C<recreate> and C<recreate_check_interval> have to be
  configured to deal with the 'disappearing' log file.
  
  The situation gets interesting when C<newsyslog>'s option
  to compress archived log files is enabled. This causes the
  original log file not to be moved, but to disappear. If the
  file appender isn't configured to recreate the logfile in this situation,
  log messages will actually be lost without warning. This also
  applies for the short time frame of C<recreate_check_interval> seconds
  in between the recreator's file checks.
  
  To make sure that no messages get lost, one option is to set the
  interval to
  
      log4perl.appender.Logfile.recreate_check_interval = 0
  
  However, this is fairly expensive. A better approach is to define
  a signal handler:
  
      log4perl.appender.Logfile.recreate = 1
      log4perl.appender.Logfile.recreate_check_signal  = USR1
      log4perl.appender.Logfile.recreate_pid_write = /tmp/myappid
  
  As a service for C<newsyslog> users, Log4perl's file appender writes
  the current process ID to a PID file specified by the C<recreate_pid_write>
  option.  C<newsyslog> then needs to be configured as in
  
      # newsyslog.conf configuration for compressing archive files and
      # sending a signal to the Log4perl-enabled application
      /tmp/test.log 666  12  5  *  B /tmp/myappid 30
  
  to send the defined signal (30, which is USR1 on FreeBSD) to the
  application process at rotation time. Note that the signal number
  is different on Linux, where USR1 denotes as 10. Check C<man signal>
  for details.
  
  =head2 How can a process under user id A log to a file under user id B?
  
  This scenario often occurs in configurations where processes run under
  various user IDs but need to write to a log file under a fixed, but
  different user id.
  
  With a traditional file appender, the log file will probably be created
  under one user's id and appended to under a different user's id. With
  a typical umask of 0002, the file will be created with -rw-rw-r--
  permissions. If a user who's not in the first user's group
  subsequently appends to the log file, it will fail because of a
  permission problem.
  
  Two potential solutions come to mind:
  
  =over 4
  
  =item *
  
  Creating the file with a umask of 0000 will allow all users to append
  to the log file. Log4perl's file appender C<Log::Log4perl::Appender::File>
  has an C<umask> option that can be set to support this:
  
      log4perl.appender.File = Log::Log4perl::Appender::File
      log4perl.appender.File.umask = sub { 0000 };
  
  This way, the log file will be created with -rw-rw-rw- permissions and
  therefore has world write permissions. This might open up the logfile
  for unwanted manipulations by arbitrary users, though.
  
  =item *
  
  Running the process under an effective user id of C<root> will allow
  it to write to the log file, no matter who started the process.
  However, this is not a good idea, because of security concerns.
  
  =back
  
  Luckily, under Unix, there's the syslog daemon which runs as root and
  takes log requests from user processes over a socket and writes them
  to log files as configured in C</etc/syslog.conf>.
  
  By modifying C</etc/syslog.conf> and HUPing the syslog daemon, you can
  configure new log files:
  
      # /etc/syslog.conf
      ...
      user.* /some/path/file.log
  
  Using the C<Log::Dispatch::Syslog> appender, which comes with the
  C<Log::Log4perl> distribution, you can then send messages via syslog:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init(\<<EOT);
          log4perl.logger = DEBUG, app
          log4perl.appender.app=Log::Dispatch::Syslog
          log4perl.appender.app.Facility=user
          log4perl.appender.app.layout=SimpleLayout
      EOT
  
          # Writes to /some/path/file.log
      ERROR "Message!";
  
  This way, the syslog daemon will solve the permission problem.
  
  Note that while it is possible to use syslog() without Log4perl (syslog
  supports log levels, too), traditional syslog setups have a
  significant drawback.
  
  Without Log4perl's ability to activate logging in only specific
  parts of a system, complex systems will trigger log events all over
  the place and slow down execution to a crawl at high debug levels.
  
  Remote-controlling logging in the hierarchical parts of an application
  via Log4perl's categories is one of its most distinguished features.
  It allows for enabling high debug levels in specified areas without
  noticeable performance impact.
  
  =head2 I want to use UTC instead of the local time!
  
  If a layout defines a date, Log::Log4perl uses local time to populate it.
  If you want UTC instead, set
  
      log4perl.utcDateTimes = 1
  
  in your configuration. Alternatively, you can set
  
      $Log::Log4perl::DateFormat::GMTIME = 1;
  
  in your program before the first log statement.
  
  =head2 Can Log4perl intercept messages written to a filehandle?
  
  You have a function that prints to a filehandle. You want to tie
  into that filehandle and forward all arriving messages to a
  Log4perl logger.
  
  First, let's write a package that ties a file handle and forwards it
  to a Log4perl logger:
  
      package FileHandleLogger;
      use Log::Log4perl qw(:levels get_logger);
  
      sub TIEHANDLE {
         my($class, %options) = @_;
  
         my $self = {
             level    => $DEBUG,
             category => '',
             %options
         };
  
         $self->{logger} = get_logger($self->{category}),
         bless $self, $class;
      }
  
      sub PRINT {
          my($self, @rest) = @_;
          $Log::Log4perl::caller_depth++;
          $self->{logger}->log($self->{level}, @rest);
          $Log::Log4perl::caller_depth--;
      }
  
      sub PRINTF {
          my($self, $fmt, @rest) = @_;
          $Log::Log4perl::caller_depth++;
          $self->PRINT(sprintf($fmt, @rest));
          $Log::Log4perl::caller_depth--;
      }
  
      1;
  
  Now, if you have a function like
  
      sub function_printing_to_fh {
          my($fh) = @_;
          printf $fh "Hi there!\n";
      }
  
  which takes a filehandle and prints something to it, it can be used
  with Log4perl:
  
      use Log::Log4perl qw(:easy);
      usa FileHandleLogger;
  
      Log::Log4perl->easy_init($DEBUG);
  
      tie *SOMEHANDLE, 'FileHandleLogger' or
          die "tie failed ($!)";
  
      function_printing_to_fh(*SOMEHANDLE);
          # prints "2007/03/22 21:43:30 Hi there!"
  
  If you want, you can even specify a different log level or category:
  
      tie *SOMEHANDLE, 'FileHandleLogger',
          level => $INFO, category => "Foo::Bar" or die "tie failed ($!)";
  
  =head2 I want multiline messages rendered line-by-line!
  
  With the standard C<PatternLayout>, if you send a multiline message to
  an appender as in
  
      use Log::Log4perl qw(:easy);
      Log
  
  it gets rendered this way:
  
      2007/04/04 23:23:39 multi
      line
      message
  
  If you want each line to be rendered separately according to
  the layout use C<Log::Log4perl::Layout::PatternLayout::Multiline>:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init(\<<EOT);
        log4perl.category         = DEBUG, Screen
        log4perl.appender.Screen = Log::Log4perl::Appender::Screen
        log4perl.appender.Screen.layout = \\
          Log::Log4perl::Layout::PatternLayout::Multiline
        log4perl.appender.Screen.layout.ConversionPattern = %d %m %n
      EOT
  
      DEBUG "some\nmultiline\nmessage";
  
  and you'll get
  
      2007/04/04 23:23:39 some
      2007/04/04 23:23:39 multiline
      2007/04/04 23:23:39 message
  
  instead.
  
  =head2 I'm on Windows and I'm getting all these 'redefined' messages!
  
  If you're on Windows and are getting warning messages like
  
    Constant subroutine Log::Log4perl::_INTERNAL_DEBUG redefined at
      C:/Programme/Perl/lib/constant.pm line 103.
    Subroutine import redefined at
      C:/Programme/Perl/site/lib/Log/Log4Perl.pm line 69.
    Subroutine initialized redefined at
      C:/Programme/Perl/site/lib/Log/Log4Perl.pm line 207.
  
  then chances are that you're using 'Log::Log4Perl' (wrong uppercase P)
  instead of the correct 'Log::Log4perl'. Perl on Windows doesn't
  handle this error well and spits out a slew of confusing warning
  messages. But now you know, just use the correct module name and
  you'll be fine.
  
  =head2 Log4perl complains that no initialization happened during shutdown!
  
  If you're using Log4perl log commands in DESTROY methods of your objects,
  you might see confusing messages like
  
      Log4perl: Seems like no initialization happened. Forgot to call init()?
      Use of uninitialized value in subroutine entry at
      /home/y/lib/perl5/site_perl/5.6.1/Log/Log4perl.pm line 134 during global
      destruction. (in cleanup) Undefined subroutine &main:: called at
      /home/y/lib/perl5/site_perl/5.6.1/Log/Log4perl.pm line 134 during global
      destruction.
  
  when the program shuts down. What's going on?
  
  This phenomenon happens if you have circular references in your objects,
  which perl can't clean up when an object goes out of scope but waits
  until global destruction instead. At this time, however, Log4perl has
  already shut down, so you can't use it anymore.
  
  For example, here's a simple class which uses a logger in its DESTROY
  method:
  
      package A;
      use Log::Log4perl qw(:easy);
      sub new { bless {}, shift }
      sub DESTROY { DEBUG "Waaah!"; }
  
  Now, if the main program creates a self-referencing object, like in
  
      package main;
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      my $a = A->new();
      $a->{selfref} = $a;
  
  then you'll see the error message shown above during global destruction.
  How to tackle this problem?
  
  First, you should clean up your circular references before global
  destruction. They will not only cause objects to be destroyed in an order
  that's hard to predict, but also eat up memory until the program shuts
  down.
  
  So, the program above could easily be fixed by putting
  
      $a->{selfref} = undef;
  
  at the end or in an END handler. If that's hard to do, use weak references:
  
      package main;
      use Scalar::Util qw(weaken);
      use Log::Log4perl qw(:easy);
      Log::Log4perl->easy_init($DEBUG);
  
      my $a = A->new();
      $a->{selfref} = weaken $a;
  
  This allows perl to clean up the circular reference when the object
  goes out of scope, and doesn't wait until global destruction.
  
  =head2 How can I access POE heap values from Log4perl's layout?
  
  POE is a framework for creating multitasked applications running in a
  single process and a single thread. POE's threads equivalents are
  'sessions' and since they run quasi-simultaneously, you can't use
  Log4perl's global NDC/MDC to hold session-specific data.
  
  However, POE already maintains a data store for every session. It is called
  'heap' and is just a hash storing session-specific data in key-value pairs.
  To access this per-session heap data from a Log4perl layout, define a
  custom cspec and reference it with the newly defined pattern in the layout:
  
      use strict;
      use POE;
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->init( \ q{
          log4perl.logger = DEBUG, Screen
          log4perl.appender.Screen = Log::Log4perl::Appender::Screen
          log4perl.appender.Screen.layout = PatternLayout
          log4perl.appender.Screen.layout.ConversionPattern = %U %m%n
          log4perl.PatternLayout.cspec.U = \
              sub { POE::Kernel->get_active_session->get_heap()->{ user } }
      } );
  
      for (qw( Huey Lewey Dewey )) {
          POE::Session->create(
              inline_states => {
                  _start    => sub {
                      $_[HEAP]->{user} = $_;
                      POE::Kernel->yield('hello');
                  },
                  hello     => sub {
                      DEBUG "I'm here now";
                  }
              }
          );
      }
  
      POE::Kernel->run();
      exit;
  
  The code snippet above defines a new layout placeholder (called
  'cspec' in Log4perl) %U which calls a subroutine, retrieves the active
  session, gets its heap and looks up the entry specified ('user').
  
  Starting with Log::Log4perl 1.20, cspecs also support parameters in
  curly braces, so you can say
  
      log4perl.appender.Screen.layout.ConversionPattern = %U{user} %U{id} %m%n
      log4perl.PatternLayout.cspec.U = \
              sub { POE::Kernel->get_active_session-> \
                    get_heap()->{ $_[0]->{curlies} } }
  
  and print the POE session heap entries 'user' and 'id' with every logged
  message. For more details on cpecs, read the PatternLayout manual.
  
  =head2 I want to print something unconditionally!
  
  Sometimes it's a script that's supposed to log messages regardless if
  Log4perl has been initialized or not. Or there's a logging statement that's
  not going to be suppressed under any circumstances -- many people want to
  have the final word, make the executive decision, because it seems like
  the only logical choice.
  
  But think about it:
  First off, if a messages is supposed to be printed, where is it supposed
  to end up at? STDOUT? STDERR? And are you sure you want to set in stone
  that this message needs to be printed, while someone else might
  find it annoying and wants to get rid of it?
  
  The truth is, there's always going to be someone who wants to log a
  messages at all cost, but also another person who wants to suppress it
  with equal vigilance. There's no good way to serve these two conflicting
  desires, someone will always want to win at the cost of leaving
  the other party disappointed.
  
  So, the best Log4perl offers is the ALWAYS level for a message that even
  fires if the system log level is set to $OFF:
  
      use Log::Log4perl qw(:easy);
  
      Log::Log4perl->easy_init( $OFF );
      ALWAYS "This gets logged always. Well, almost always";
  
  The logger won't fire, though, if Log4perl hasn't been initialized or
  if someone defines a custom log hurdle that's higher than $OFF.
  
  Bottom line: Leave the setting of the logging level to the initial Perl
  script -- let their owners decided what they want, no matter how tempting
  it may be to decide it for them.
  
  =head2 Why doesn't my END handler remove my log file on Win32?
  
  If you have code like
  
      use Log::Log4perl qw( :easy );
      Log::Log4perl->easy_init( { level => $DEBUG, file => "my.log" } );
      END { unlink "my.log" or die };
  
  then you might be in for a surprise when you're running it on
  Windows, because the C<unlink()> call in the END handler will complain that
  the file is still in use.
  
  What happens in Perl if you have something like
  
      END { print "first end in main\n"; }
      use Module;
      END { print "second end in main\n"; }
  
  and
  
      package Module;
      END { print "end in module\n"; }
      1;
  
  is that you get
  
      second end in main
      end in module
      first end in main
  
  because perl stacks the END handlers in reverse order in which it
  encounters them in the compile phase.
  
  Log4perl defines an END handler that cleans up left-over appenders (e.g.
  file appenders which still hold files open), because those appenders have
  circular references and therefore aren't cleaned up otherwise.
  
  Now if you define an END handler after "use Log::Log4perl", it'll
  trigger before Log4perl gets a chance to clean up, which isn't a 
  problem on Unix where you can delete a file even if some process has a 
  handle to it open, but it's a problem on Win32, where the OS won't 
  let you do that.
  
  The solution is easy, just place the END handler I<before> Log4perl
  gets loaded, like in
  
      END { unlink "my.log" or die };
      use Log::Log4perl qw( :easy );
      Log::Log4perl->easy_init( { level => $DEBUG, file => "my.log" } );
  
  which will call the END handlers in the intended order.
  
  =cut
  
  =head1 SEE ALSO
  
  Log::Log4perl
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt>
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches):
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull,
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter,
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope,
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FAQ

$fatpacked{"Log/Log4perl/Filter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER';
  ##################################################
  package Log::Log4perl::Filter;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our %FILTERS_DEFINED = ();
  
  ##################################################
  sub new {
  ##################################################
      my($class, $name, $action) = @_;
    
      print "Creating filter $name\n" if _INTERNAL_DEBUG;
  
      my $self = { name => $name };
      bless $self, $class;
  
      if(ref($action) eq "CODE") {
          # it's a code ref
          $self->{ok} = $action;
      } else {
          # it's something else
          die "Code for ($name/$action) not properly defined";
      }
  
      return $self;
  }
  
  ##################################################
  sub register {         # Register a filter by name
                         # (Passed on to subclasses)
  ##################################################
      my($self) = @_;
  
      by_name($self->{name}, $self);
  }
  
  ##################################################
  sub by_name {        # Get/Set a filter object by name
  ##################################################
      my($name, $value) = @_;
  
      if(defined $value) {
          $FILTERS_DEFINED{$name} = $value;
      }
  
      if(exists $FILTERS_DEFINED{$name}) {
          return $FILTERS_DEFINED{$name};
      } else {
          return undef;
      }
  }
  
  ##################################################
  sub reset {
  ##################################################
      %FILTERS_DEFINED = ();
  }
  
  ##################################################
  sub ok {
  ##################################################
      my($self, %p) = @_;
  
      print "Calling $self->{name}'s ok method\n" if _INTERNAL_DEBUG;
  
          # Force filter classes to define their own
          # ok(). Exempt are only sub {..} ok functions,
          # defined in the conf file.
      die "This is to be overridden by the filter" unless
           defined $self->{ok};
  
      # What should we set the message in $_ to? The most logical
      # approach seems to be to concat all parts together. If some
      # filter wants to dissect the parts, it still can examine %p,
      # which gets passed to the subroutine and contains the chunks
      # in $p{message}.
          # Split because of CVS
      local($_) = join $
                       Log::Log4perl::JOIN_MSG_ARRAY_CHAR, @{$p{message}};
      print "\$_ is '$_'\n" if _INTERNAL_DEBUG;
  
      my $decision = $self->{ok}->(%p);
  
      print "$self->{name}'s ok'ed: ", 
            ($decision ? "yes" : "no"), "\n" if _INTERNAL_DEBUG;
  
      return $decision;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter - Log4perl Custom Filter Base Class
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl->init(\ <<'EOT');
      log4perl.logger = INFO, Screen
      log4perl.filter.MyFilter        = sub { /let this through/ }
      log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.Filter = MyFilter
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
    EOT
  
        # Define a logger
    my $logger = Log::Log4perl->get_logger("Some");
  
        # Let this through
    $logger->info("Here's the info, let this through!");
  
        # Suppress this
    $logger->info("Here's the info, suppress this!");
  
    #################################################################
    # StringMatch Filter:
    #################################################################
    log4perl.filter.M1               = Log::Log4perl::Filter::StringMatch
    log4perl.filter.M1.StringToMatch = let this through
    log4perl.filter.M1.AcceptOnMatch = true
  
    #################################################################
    # LevelMatch Filter:
    #################################################################
    log4perl.filter.M1               = Log::Log4perl::Filter::LevelMatch
    log4perl.filter.M1.LevelToMatch  = INFO
    log4perl.filter.M1.AcceptOnMatch = true
  
  =head1 DESCRIPTION
  
  Log4perl allows the use of customized filters in its appenders
  to control the output of messages. These filters might grep for
  certain text chunks in a message, verify that its priority
  matches or exceeds a certain level or that this is the 10th
  time the same message has been submitted -- and come to a log/no log 
  decision based upon these circumstantial facts.
  
  Filters have names and can be specified in two different ways in the Log4perl
  configuration file: As subroutines or as filter classes. Here's a 
  simple filter named C<MyFilter> which just verifies that the 
  oncoming message matches the regular expression C</let this through/i>:
  
      log4perl.filter.MyFilter        = sub { /let this through/i }
  
  It exploits the fact that when the subroutine defined
  above is called on a message,
  Perl's special C<$_> variable will be set to the message text (prerendered,
  i.e. concatenated but not layouted) to be logged. 
  The subroutine is expected to return a true value 
  if it wants the message to be logged or a false value if doesn't.
  
  Also, Log::Log4perl will pass a hash to the subroutine,
  containing all key/value pairs that it would pass to the corresponding 
  appender, as specified in Log::Log4perl::Appender. Here's an
  example of a filter checking the priority of the oncoming message:
  
    log4perl.filter.MyFilter        = sub {    \
         my %p = @_;                           \
         if($p{log4p_level} eq "WARN" or       \
            $p{log4p_level} eq "INFO") {       \
             return 1;                         \
         }                                     \
         return 0;                             \
    }     
  
  If the message priority equals C<WARN> or C<INFO>, 
  it returns a true value, causing
  the message to be logged.
  
  =head2 Predefined Filters
  
  For common tasks like verifying that the message priority matches
  a certain priority, there's already a 
  set of predefined filters available. To perform an exact level match, it's
  much cleaner to use Log4perl's C<LevelMatch> filter instead:
  
    log4perl.filter.M1               = Log::Log4perl::Filter::LevelMatch
    log4perl.filter.M1.LevelToMatch  = INFO
    log4perl.filter.M1.AcceptOnMatch = true
  
  This will let the message through if its priority is INFO and suppress
  it otherwise. The statement can be negated by saying
  
    log4perl.filter.M1.AcceptOnMatch = false
  
  instead. This way, the message will be logged if its priority is
  anything but INFO.
  
  On a similar note, Log4perl's C<StringMatch> filter will check the 
  oncoming message for strings or regular expressions:
  
    log4perl.filter.M1               = Log::Log4perl::Filter::StringMatch
    log4perl.filter.M1.StringToMatch = bl.. bl..
    log4perl.filter.M1.AcceptOnMatch = true
  
  This will open the gate for messages like C<blah blah> because the 
  regular expression in the C<StringToMatch> matches them. Again,
  the setting of C<AcceptOnMatch> determines if the filter is defined
  in a positive or negative way.
  
  All class filter entries in the configuration file
  have to adhere to the following rule:
  Only after a filter has been defined by name and class/subroutine,
  its attribute values can be
  assigned, just like the C<true> value above gets assigned to the
  C<AcceptOnMatch> attribute I<after> the
  filter C<M1> has been defined.
  
  =head2 Attaching a filter to an appender
  
  Attaching a filter to an appender is as easy as assigning its name to
  the appender's C<Filter> attribute:
  
      log4perl.appender.MyAppender.Filter = MyFilter
  
  This will cause C<Log::Log4perl> to call the filter subroutine/method
  every time a message is supposed to be passed to the appender. Depending
  on the filter's return value, C<Log::Log4perl> will either continue as
  planned or withdraw immediately.
  
  =head2 Combining filters with Log::Log4perl::Filter::Boolean
  
  Sometimes, it's useful to combine the output of various filters to
  arrive at a log/no log decision. While Log4j, Log4perl's mother ship,
  has chosen to implement this feature as a filter chain, similar to Linux' IP chains,
  Log4perl tries a different approach. 
  
  Typically, filter results will not need to be bumped along chains but 
  combined in a programmatic manner using boolean logic. "Log if
  this filter says 'yes' and that filter says 'no'" 
  is a fairly common requirement, but hard to implement as a chain.
  
  C<Log::Log4perl::Filter::Boolean> is a specially predefined custom filter
  for Log4perl. It combines the results of other custom filters 
  in arbitrary ways, using boolean expressions:
  
      log4perl.logger = WARN, AppWarn, AppError
  
      log4perl.filter.Match1       = sub { /let this through/ }
      log4perl.filter.Match2       = sub { /and that, too/ }
      log4perl.filter.MyBoolean       = Log::Log4perl::Filter::Boolean
      log4perl.filter.MyBoolean.logic = Match1 || Match2
  
      log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
      log4perl.appender.Screen.Filter = MyBoolean
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
  
  C<Log::Log4perl::Filter::Boolean>'s boolean expressions allow for combining
  different appenders by name using AND (&& or &), OR (|| or |) and NOT (!) as
  logical expressions. Also, parentheses can be used for defining precedences. 
  Operator precedence follows standard Perl conventions. Here's a bunch of examples:
  
      Match1 && !Match2            # Match1 and not Match2
      !(Match1 || Match2)          # Neither Match1 nor Match2
      (Match1 && Match2) || Match3 # Both Match1 and Match2 or Match3
  
  =head2 Writing your own filter classes
  
  If none of Log::Log4perl's predefined filter classes fits your needs,
  you can easily roll your own: Just define a new class,
  derive it from the baseclass C<Log::Log4perl::Filter>,
  and define its C<new> and C<ok> methods like this:
  
      package Log::Log4perl::Filter::MyFilter;
  
      use base Log::Log4perl::Filter;
  
      sub new {
          my ($class, %options) = @_;
  
          my $self = { %options,
                     };
       
          bless $self, $class;
  
          return $self;
      }
  
      sub ok {
           my ($self, %p) = @_;
  
           # ... decide and return 1 or 0
      }
  
      1;
  
  Log4perl will call the ok() method to determine if the filter
  should let the message pass or not. A true return value indicates
  the message will be logged by the appender, a false value blocks it.
  
  Values you've defined for its attributes in Log4perl's configuration file,
  will be received through its C<new> method:
  
      log4perl.filter.MyFilter       = Log::Log4perl::Filter::MyFilter
      log4perl.filter.MyFilter.color = red
  
  will cause C<Log::Log4perl::Filter::MyFilter>'s constructor to be called
  like this:
  
      Log::Log4perl::Filter::MyFilter->new( name  => "MyFilter",
                                            color => "red" );
  
  The custom filter class should use this to set the object's attributes, 
  to have them available later to base log/nolog decisions on it.
  
  C<ok()> is the filter's method to tell if it agrees or disagrees with logging
  the message. It will be called by Log::Log4perl whenever it needs the
  filter to decide. A false value returned by C<ok()> will block messages,
  a true value will let them through.
  
  =head2 A Practical Example: Level Matching
  
  See L<Log::Log4perl::FAQ> for this.
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::StringRange>,
  L<Log::Log4perl::Filter::Boolean>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER

$fatpacked{"Log/Log4perl/Filter/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_BOOLEAN';
  ##################################################
  package Log::Log4perl::Filter::Boolean;
  ##################################################
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  
  use constant _INTERNAL_DEBUG => 0;
  
  use base qw(Log::Log4perl::Filter);
  
  ##################################################
  sub new {
  ##################################################
      my ($class, %options) = @_;
  
      my $self = { params => {},
                   %options,
                 };
       
      bless $self, $class;
       
      print "Compiling '$options{logic}'\n" if _INTERNAL_DEBUG;
  
          # Set up meta-decider for later
      $self->compile_logic($options{logic});
  
      return $self;
  }
  
  ##################################################
  sub ok {
  ##################################################
       my ($self, %p) = @_;
  
       return $self->eval_logic(\%p);
  }
  
  ##################################################
  sub compile_logic {
  ##################################################
      my ($self, $logic) = @_;
  
         # Extract Filter placeholders in logic as defined
         # in configuration file.
      while($logic =~ /([\w_-]+)/g) {
              # Get the corresponding filter object
          my $filter = Log::Log4perl::Filter::by_name($1);
          die "Filter $filter required by Boolean filter, but not defined" 
              unless $filter;
  
          $self->{params}->{$1} = $filter;
      }
  
          # Fabricate a parameter list: A1/A2/A3 => $A1, $A2, $A3
      my $plist = join ', ', map { '$' . $_ } keys %{$self->{params}};
  
          # Replace all the (dollar-less) placeholders in the code with
          # calls to their respective coderefs.  
          $logic =~ s/([\w_-]+)/\&\$$1/g;
  
          # Set up the meta decider, which transforms the config file
          # logic into compiled perl code
      my $func = <<EOT;
          sub { 
              my($plist) = \@_;
              $logic;
          }
  EOT
  
      print "func=$func\n" if _INTERNAL_DEBUG;
  
      my $eval_func = eval $func;
  
      if(! $eval_func) {
          die "Syntax error in Boolean filter logic: $eval_func";
      }
  
      $self->{eval_func} = $eval_func;
  }
  
  ##################################################
  sub eval_logic {
  ##################################################
      my($self, $p) = @_;
  
      my @plist = ();
  
          # Eval the results of all filters referenced
          # in the code (although the order of keys is
          # not predictable, it is consistent :)
      for my $param (keys %{$self->{params}}) {
          # Pass a coderef as a param that will run the filter's ok method and
          # return a 1 or 0.  
          print "Passing filter $param\n" if _INTERNAL_DEBUG;
          push(@plist, sub {
              return $self->{params}->{$param}->ok(%$p) ? 1 : 0
          });
      }
  
          # Now pipe the parameters into the canned function,
          # have it evaluate the logic and return the final
          # decision
      print "Passing in (", join(', ', @plist), ")\n" if _INTERNAL_DEBUG;
      return $self->{eval_func}->(@plist);
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::Boolean - Special filter to combine the results of others
  
  =head1 SYNOPSIS
  
      log4perl.logger = WARN, AppWarn, AppError
  
      log4perl.filter.Match1       = sub { /let this through/ }
      log4perl.filter.Match2       = sub { /and that, too/ }
      log4perl.filter.MyBoolean       = Log::Log4perl::Filter::Boolean
      log4perl.filter.MyBoolean.logic = Match1 || Match2
  
      log4perl.appender.Screen        = Log::Dispatch::Screen
      log4perl.appender.Screen.Filter = MyBoolean
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
  
  =head1 DESCRIPTION
  
  Sometimes, it's useful to combine the output of various filters to
  arrive at a log/no log decision. While Log4j, Log4perl's mother ship,
  chose to implement this feature as a filter chain, similar to Linux' IP chains,
  Log4perl tries a different approach. 
  
  Typically, filter results will not need to be passed along in chains but 
  combined in a programmatic manner using boolean logic. "Log if
  this filter says 'yes' and that filter says 'no'" 
  is a fairly common requirement but hard to implement as a chain.
  
  C<Log::Log4perl::Filter::Boolean> is a special predefined custom filter
  for Log4perl which combines the results of other custom filters 
  in arbitrary ways, using boolean expressions:
  
      log4perl.logger = WARN, AppWarn, AppError
  
      log4perl.filter.Match1       = sub { /let this through/ }
      log4perl.filter.Match2       = sub { /and that, too/ }
      log4perl.filter.MyBoolean       = Log::Log4perl::Filter::Boolean
      log4perl.filter.MyBoolean.logic = Match1 || Match2
  
      log4perl.appender.Screen        = Log::Dispatch::Screen
      log4perl.appender.Screen.Filter = MyBoolean
      log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
  
  C<Log::Log4perl::Filter::Boolean>'s boolean expressions allow for combining
  different appenders by name using AND (&& or &), OR (|| or |) and NOT (!) as
  logical expressions. Parentheses are used for grouping. Precedence follows
  standard Perl. Here's a bunch of examples:
  
      Match1 && !Match2            # Match1 and not Match2
      !(Match1 || Match2)          # Neither Match1 nor Match2
      (Match1 && Match2) || Match3 # Both Match1 and Match2 or Match3
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::MDC>,
  L<Log::Log4perl::Filter::StringRange>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_BOOLEAN

$fatpacked{"Log/Log4perl/Filter/LevelMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_LEVELMATCH';
  ##################################################
  package Log::Log4perl::Filter::LevelMatch;
  ##################################################
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  use Log::Log4perl::Util qw( params_check );
  
  use constant _INTERNAL_DEBUG => 0;
  
  use base qw(Log::Log4perl::Filter);
  
  ##################################################
  sub new {
  ##################################################
      my ($class, %options) = @_;
  
      my $self = { LevelToMatch  => '',
                   AcceptOnMatch => 1,
                   %options,
                 };
       
      params_check( $self,
                    [ qw( LevelToMatch ) ], 
                    [ qw( name AcceptOnMatch ) ] 
                  );
  
      $self->{AcceptOnMatch} = Log::Log4perl::Config::boolean_to_perlish(
                                                  $self->{AcceptOnMatch});
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub ok {
  ##################################################
       my ($self, %p) = @_;
  
       if($self->{LevelToMatch} eq $p{log4p_level}) {
           print "Levels match\n" if _INTERNAL_DEBUG;
           return $self->{AcceptOnMatch};
       } else {
           print "Levels don't match\n" if _INTERNAL_DEBUG;
           return !$self->{AcceptOnMatch};
       }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::LevelMatch - Filter to match the log level exactly
  
  =head1 SYNOPSIS
  
      log4perl.filter.Match1               = Log::Log4perl::Filter::LevelMatch
      log4perl.filter.Match1.LevelToMatch  = ERROR
      log4perl.filter.Match1.AcceptOnMatch = true
  
  =head1 DESCRIPTION
  
  This Log4perl custom filter checks if the currently submitted message
  matches a predefined priority, as set in C<LevelToMatch>.
  The additional parameter C<AcceptOnMatch> defines if the filter
  is supposed to pass or block the message (C<true> or C<false>)
  on a match.
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::Boolean>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::MDC>,
  L<Log::Log4perl::Filter::StringMatch>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_LEVELMATCH

$fatpacked{"Log/Log4perl/Filter/LevelRange.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_LEVELRANGE';
  ##################################################
  package Log::Log4perl::Filter::LevelRange;
  ##################################################
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Log::Log4perl::Level;
  use Log::Log4perl::Config;
  use Log::Log4perl::Util qw( params_check );
  
  use constant _INTERNAL_DEBUG => 0;
  
  use base "Log::Log4perl::Filter";
  
  ##################################################
  sub new {
  ##################################################
      my ($class, %options) = @_;
  
      my $self = { LevelMin      => 'DEBUG',
                   LevelMax      => 'FATAL',
                   AcceptOnMatch => 1,
                   %options,
                 };
       
      params_check( $self,
                    [ qw( LevelMin LevelMax ) ], 
                    [ qw( name AcceptOnMatch ) ] 
                  );
  
      $self->{AcceptOnMatch} = Log::Log4perl::Config::boolean_to_perlish(
                                                  $self->{AcceptOnMatch});
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub ok {
  ##################################################
       my ($self, %p) = @_;
  
       if(Log::Log4perl::Level::to_priority($self->{LevelMin}) <= 
          Log::Log4perl::Level::to_priority($p{log4p_level}) and
          Log::Log4perl::Level::to_priority($self->{LevelMax}) >= 
          Log::Log4perl::Level::to_priority($p{log4p_level})) {
           return $self->{AcceptOnMatch};
       } else {
           return ! $self->{AcceptOnMatch};
       }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::LevelRange - Filter for a range of log levels
  
  =head1 SYNOPSIS
  
      log4perl.filter.Match1               = Log::Log4perl::Filter::LevelRange
      log4perl.filter.Match1.LevelMin      = INFO
      log4perl.filter.Match1.LevelMax      = ERROR
      log4perl.filter.Match1.AcceptOnMatch = true
  
  =head1 DESCRIPTION
  
  This Log4perl custom filter checks if the current message
  has a priority matching a predefined range. 
  The C<LevelMin> and C<LevelMax> parameters define the levels
  (choose from C<DEBUG>, C<INFO>, C<WARN>, C<ERROR>, C<FATAL>) marking
  the window of allowed messages priorities.
  
  C<LevelMin> defaults to C<DEBUG>, and C<LevelMax> to C<FATAL>.
  
  The additional parameter C<AcceptOnMatch> defines if the filter
  is supposed to pass or block the message (C<true> or C<false>).
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::Boolean>,
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::MDC>,
  L<Log::Log4perl::Filter::StringMatch>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_LEVELRANGE

$fatpacked{"Log/Log4perl/Filter/MDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_MDC';
  package Log::Log4perl::Filter::MDC;
  use strict;
  use warnings;
  
  use Log::Log4perl::Util qw( params_check );
  
  use base "Log::Log4perl::Filter";
  
  sub new {
      my ( $class, %options ) = @_;
  
      my $self = {%options};
  
      params_check( $self, [qw( KeyToMatch RegexToMatch )] );
  
      $self->{RegexToMatch} = qr/$self->{RegexToMatch}/;
  
      bless $self, $class;
  
      return $self;
  }
  
  sub ok {
      my ( $self, %p ) = @_;
  
      my $context = Log::Log4perl::MDC->get_context;
  
      my $value = $context->{ $self->{KeyToMatch} };
      return 1
          if defined $value && $value =~ $self->{RegexToMatch};
  
      return 0;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::MDC - Filter to match on values of a MDC key
  
  =head1 SYNOPSIS
  
      log4perl.filter.Match1               = Log::Log4perl::Filter::MDC
      log4perl.filter.Match1.KeyToMatch    = foo
      log4perl.filter.Match1.RegexToMatch  = bar
  
  =head1 DESCRIPTION
  
  This Log4perl filter checks if a predefined MDC key, as set in C<KeyToMatch>,
  of the currently submitted message matches a predefined regex, as set in
  C<RegexToMatch>.
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::Boolean>,
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::MDC>,
  L<Log::Log4perl::Filter::StringMatch>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_MDC

$fatpacked{"Log/Log4perl/Filter/StringMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_FILTER_STRINGMATCH';
  ##################################################
  package Log::Log4perl::Filter::StringMatch;
  ##################################################
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Log::Log4perl::Config;
  use Log::Log4perl::Util qw( params_check );
  
  use constant _INTERNAL_DEBUG => 0;
  
  use base "Log::Log4perl::Filter";
  
  ##################################################
  sub new {
  ##################################################
       my ($class, %options) = @_;
  
       print join('-', %options) if _INTERNAL_DEBUG;
  
       my $self = { StringToMatch => undef,
                    AcceptOnMatch => 1,
                    %options,
                  };
       
       params_check( $self,
                    [ qw( StringToMatch ) ], 
                    [ qw( name AcceptOnMatch ) ] 
                  );
  
       $self->{AcceptOnMatch} = Log::Log4perl::Config::boolean_to_perlish(
                                                   $self->{AcceptOnMatch});
  
       $self->{StringToMatch} = qr($self->{StringToMatch});
  
       bless $self, $class;
  
       return $self;
  }
  
  ##################################################
  sub ok {
  ##################################################
       my ($self, %p) = @_;
  
       local($_) = join $
                       Log::Log4perl::JOIN_MSG_ARRAY_CHAR, @{$p{message}};
  
       if($_ =~ $self->{StringToMatch}) {
           print "Strings match\n" if _INTERNAL_DEBUG;
           return $self->{AcceptOnMatch};
       } else {
           print "Strings don't match ($_/$self->{StringToMatch})\n" 
               if _INTERNAL_DEBUG;
           return !$self->{AcceptOnMatch};
       }
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Filter::StringMatch - Filter on log message string
  
  =head1 SYNOPSIS
  
      log4perl.filter.Match1               = Log::Log4perl::Filter::StringMatch
      log4perl.filter.Match1.StringToMatch = blah blah
      log4perl.filter.Match1.AcceptOnMatch = true
  
  =head1 DESCRIPTION
  
  This Log4perl custom filter checks if the currently submitted message
  matches a predefined regular expression, as set in the C<StringToMatch>
  parameter. It uses common Perl 5 regexes.
  
  The additional parameter C<AcceptOnMatch> defines if the filter
  is supposed to pass or block the message on a match (C<true> or C<false>).
  
  =head1 SEE ALSO
  
  L<Log::Log4perl::Filter>,
  L<Log::Log4perl::Filter::Boolean>,
  L<Log::Log4perl::Filter::LevelMatch>,
  L<Log::Log4perl::Filter::LevelRange>,
  L<Log::Log4perl::Filter::MDC>
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_FILTER_STRINGMATCH

$fatpacked{"Log/Log4perl/InternalDebug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_INTERNALDEBUG';
  package Log::Log4perl::InternalDebug;
  use warnings;
  use strict;
  
  use File::Temp qw(tempfile);
  use File::Spec;
  
  require Log::Log4perl::Resurrector;
  
  ###########################################
  sub enable {
  ###########################################
      unshift @INC, \&internal_debug_loader;
  }
  
  ##################################################
  sub internal_debug_fh {
  ##################################################
      my($file) = @_;
  
      local($/) = undef;
      open FILE, "<$file" or die "Cannot open $file";
      my $text = <FILE>;
      close FILE;
  
      my($tmp_fh, $tmpfile) = tempfile( UNLINK => 1 );
  
      $text =~ s/_INTERNAL_DEBUG(?!\s*=>)/1/g;
  
      print $tmp_fh $text;
      seek $tmp_fh, 0, 0;
  
      return $tmp_fh;
  }
  
  ###########################################
  sub internal_debug_loader {
  ###########################################
      my ($code, $module) = @_;
  
        # Skip non-Log4perl modules
      if($module !~ m#^Log/Log4perl#) {
          return undef;
      }
  
      my $path = $module;
      if(!-f $path) {
          $path = Log::Log4perl::Resurrector::pm_search( $module );
      }
  
      my $fh = internal_debug_fh($path);
  
      my $abs_path = File::Spec->rel2abs( $path );
      $INC{$module} = $abs_path;
  
      return $fh;
  }
  
  ###########################################
  sub resurrector_init {
  ###########################################
      unshift @INC, \&resurrector_loader;
  }
  
  ###########################################
  sub import {
  ###########################################
      # enable it on import
    enable();
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::InternalDebug - Dark Magic to enable _INTERNAL_DEBUG
  
  =head1 DESCRIPTION
  
  When called with
  
      perl -MLog::Log4perl::InternalDebug t/001Test.t
  
  scripts will run with _INTERNAL_DEBUG set to a true value and hence
  print internal Log4perl debugging information.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_INTERNALDEBUG

$fatpacked{"Log/Log4perl/JavaMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP';
  package Log::Log4perl::JavaMap;
  
  use Carp;
  use strict;
  
  use constant _INTERNAL_DEBUG => 0;
  
  our %translate = (
      'org.apache.log4j.ConsoleAppender' => 
          'Log::Log4perl::JavaMap::ConsoleAppender',
      'org.apache.log4j.FileAppender'    => 
          'Log::Log4perl::JavaMap::FileAppender',
      'org.apache.log4j.RollingFileAppender'    => 
          'Log::Log4perl::JavaMap::RollingFileAppender',
      'org.apache.log4j.TestBuffer'    => 
          'Log::Log4perl::JavaMap::TestBuffer',
       'org.apache.log4j.jdbc.JDBCAppender'    => 
          'Log::Log4perl::JavaMap::JDBCAppender',
       'org.apache.log4j.SyslogAppender'    => 
          'Log::Log4perl::JavaMap::SyslogAppender',
       'org.apache.log4j.NTEventLogAppender'    => 
          'Log::Log4perl::JavaMap::NTEventLogAppender',
  );
  
  our %user_defined;
  
  sub get {
      my ($appender_name, $appender_data) = @_;
  
      print "Trying to map $appender_name\n" if _INTERNAL_DEBUG;
  
      $appender_data->{value} ||
              die "ERROR: you didn't tell me how to implement your appender " .
                  "'$appender_name'";
  
      my $perl_class = $translate{$appender_data->{value}} || 
                       $user_defined{$appender_data->{value}} ||
              die "ERROR:  I don't know how to make a '$appender_data->{value}' " .
                  "to implement your appender '$appender_name', that's not a " .
                  "supported class\n";
      eval {
          eval "require $perl_class";  #see 'perldoc -f require' for why two evals
          die $@ if $@;
      };
      $@ and die "ERROR: trying to set appender for $appender_name to " .
                 "$appender_data->{value} using $perl_class failed\n$@  \n";
  
      my $app = $perl_class->new($appender_name, $appender_data);
      return $app;
  }
  
  #an external api to the two hashes
  sub translate {
      my $java_class = shift;
  
      return $translate{$java_class} || 
              $user_defined{$java_class};
  }
  
  1;
  
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap - maps java log4j appenders to Log::Dispatch classes
  
  =head1 SYNOPSIS
  
       ###############################
       log4j.appender.FileAppndr1        = org.apache.log4j.FileAppender
       log4j.appender.FileAppndr1.File   = /var/log/onetime.log
       log4j.appender.FileAppndr1.Append = false
  
       log4j.appender.FileAppndr1.layout = org.apache.log4j.PatternLayout
       log4j.appender.FileAppndr1.layout.ConversionPattern=%d %4r [%t] %-5p %c %x - %m%n
       ###############################
  
  
  =head1 DESCRIPTION
  
  If somebody wants to create an appender called C<org.apache.log4j.ConsoleAppender>,
  we want to translate it to Log::Dispatch::Screen, and then translate
  the log4j options into Log::Dispatch parameters..
  
  =head2 What's Implemented
  
  (Note that you can always use the Log::Dispatch::* module.  By 'implemented'
  I mean having a translation class that translates log4j options into
  the Log::Dispatch options so you can use log4j rather than log4perl 
  syntax in your config file.)
  
  Here's the list of appenders I see on the current (6/2002) log4j site.
  
  These are implemented
  
      ConsoleAppender     - Log::Dispatch::Screen
      FileAppender        - Log::Dispatch::File
      RollingFileAppender - Log::Dispatch::FileRotate (by Mark Pfeiffer)
      JDBCAppender        - Log::Log4perl::Appender::DBI
      SyslogAppender      - Log::Dispatch::Syslog
      NTEventLogAppender  - Log::Dispatch::Win32EventLog
  
  
  These should/will/might be implemented
      
      DailyRollingFileAppender - 
      SMTPAppender     - Log::Dispatch::Email::MailSender
      
  
  These might be implemented but they don't have corresponding classes
  in Log::Dispatch (yet):
  
      NullAppender
      TelnetAppender
  
  These might be simulated
  
      LF5Appender - use Tk?
      ExternallyRolledFileAppender - catch a HUP instead?
  
  These will probably not be implemented
  
      AsyncAppender
      JMSAppender
      SocketAppender - (ships a serialized LoggingEvent to the server side)
      SocketHubAppender
  
  =head1 ROLL YOUR OWN
  
  Let's say you've in a mixed Java/Perl environment and you've
  come up with some custom Java appender with behavior you want to 
  use in both worlds, C<myorg.customAppender>.  You write a
  Perl appender with the same behavior C<Myorg::CustomAppender>. You
  want to use one config file across both applications, so the
  config file will have to say 'myorg.customAppender'.  But
  the mapping from C<myorg.customAppender> to C<Myorg::CustomAppender>
  isn't in this JavaMap class, so what do you do?
  
  In  your Perl code, before you call Log::Log4perl::init(), do this:
  
      $Log::Log4perl::JavaMap::user_defined{'myorg.customAppender'} = 
          'Myorg::CustomAppender';
  
  and you can use 'myorg.customAppender' in your config file with
  impunity.
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP

$fatpacked{"Log/Log4perl/JavaMap/ConsoleAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_CONSOLEAPPENDER';
  package Log::Log4perl::JavaMap::ConsoleAppender;
  
  use Carp;
  use strict;
  use Log::Dispatch::Screen;
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      if (my $t = $data->{Target}{value}) {
          if ($t eq 'System.out') {
              $stderr = 0;
          }elsif ($t eq 'System.err') {
              $stderr = 1;
          }else{
              die "ERROR: illegal value '$t' for $data->{value}.Target' in appender $appender_name\n";
          }
      }elsif (defined $data->{stderr}{value}){
          $stderr = $data->{stderr}{value};
      }else{
          $stderr = 0;
      }
  
      return Log::Log4perl::Appender->new("Log::Dispatch::Screen",
          name   => $appender_name,
          stderr => $stderr );
  }
  
  
  1;
  
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::ConsoleAppender - wraps Log::Dispatch::Screen
  
  =head1 SYNOPSIS
  
  
  =head1 DESCRIPTION
  
  Possible config properties for log4j ConsoleAppender are 
  
      Target (System.out, System.err, default is System.out)
  
  Possible config properties for Log::Dispatch::Screen are
  
      stderr (0 or 1)
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  Log::Dispatch::Screen
  
  =cut 
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_CONSOLEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/FileAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_FILEAPPENDER';
  package Log::Log4perl::JavaMap::FileAppender;
  
  use Carp;
  use strict;
  use Log::Dispatch::File;
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my $filename =  $data->{File}{value} || 
                  $data->{filename}{value} || 
                  die "'File' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
      my $mode;
      if (defined($data->{Append}{value})){
          if (lc $data->{Append}{value} eq 'true' || $data->{Append}{value} == 1){
              $mode = 'append';
          }elsif (lc $data->{Append}{value} eq 'false' || $data->{Append}{value} == 0) {
              $mode = 'write';
          }elsif($data->{Append} =~ /^(write|append)$/){
              $mode = $data->{Append}
          }else{
              die "'$data->{Append}' is not a legal value for Append for appender '$appender_name', '$data->{value}'\n";
          }
      }else{
          $mode = 'append';
      }
  
      my $autoflush;
      if (defined($data->{BufferedIO}{value})){
          if (lc $data->{BufferedIO}{value} eq 'true' || $data->{BufferedIO}{value}){
              $autoflush = 1;
          }elsif (lc $data->{BufferedIO}{value} eq 'true' || ! $data->{BufferedIO}{value}) {
              $autoflush = 0;
          }else{
              die "'$data->{BufferedIO}' is not a legal value for BufferedIO for appender '$appender_name', '$data->{value}'\n";
          }
      }else{
          $autoflush = 1;
      }
  
  
      return Log::Log4perl::Appender->new("Log::Dispatch::File",
          name      => $appender_name,
          filename  => $filename,
          mode      => $mode,
          autoflush => $autoflush,
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::FileAppender - wraps Log::Dispatch::File
  
  =head1 SYNOPSIS
  
  
  =head1 DESCRIPTION
  
  Possible config properties for log4j ConsoleAppender are 
  
      File
      Append      "true|false|1|0" default=true
      BufferedIO  "true|false|1|0" default=false (i.e. autoflush is on)
  
  Possible config properties for Log::Dispatch::File are
  
      filename
      mode  "write|append"
      autoflush 0|1
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  Log::Dispatch::File
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_FILEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/JDBCAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_JDBCAPPENDER';
  package Log::Log4perl::JavaMap::JDBCAppender;
  
  use Carp;
  use strict;
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my $pwd =  $data->{password}{value} || 
                  die "'password' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
      my $username =  $data->{user}{value} || 
                  $data->{username}{value} || 
                  die "'user' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
  
      my $sql =  $data->{sql}{value} || 
                  die "'sql' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
  
      my $dsn;
  
      my $databaseURL = $data->{URL}{value};
      if ($databaseURL) {
          $databaseURL =~ m|^jdbc:(.+?):(.+?)://(.+?):(.+?);(.+)|;
          my $driverName = $1;
          my $databaseName = $2;
          my $hostname = $3;
          my $port = $4;
          my $params = $5;
          $dsn = "dbi:$driverName:database=$databaseName;host=$hostname;port=$port;$params";
      }elsif ($data->{datasource}{value}){
          $dsn = $data->{datasource}{value};
      }else{
          die "'databaseURL' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
      }
  
  
      #this part isn't supported by log4j, it's my Log4perl
      #hack, but I think it's so useful I'm going to implement it
      #anyway
      my %bind_value_params;
      foreach my $p (keys %{$data->{params}}){
          $bind_value_params{$p} =  $data->{params}{$p}{value};
      }
  
      return Log::Log4perl::Appender->new("Log::Log4perl::Appender::DBI",
          datasource    => $dsn,
          username      => $username,
          password      => $pwd, 
          sql           => $sql,
          params        => \%bind_value_params,
              #warp_message also not a log4j thing, but see above
          warp_message=> $data->{warp_message}{value},  
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::JDBCAppender - wraps Log::Log4perl::Appender::DBI
  
  =head1 SYNOPSIS
  
  
  =head1 DESCRIPTION
  
  Possible config properties for log4j JDBCAppender are 
  
      bufferSize 
      sql
      password
      user
      URL - attempting to translate a JDBC URL into DBI parameters,
          let me know if you find problems
  
  Possible config properties for Log::Log4perl::Appender::DBI are
  
      bufferSize 
      sql
      password
      username
      datasource
      
      usePreparedStmt 0|1
      
      (patternLayout).dontCollapseArrayRefs 0|1
      
      
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  Log::Log4perl::Appender::DBI
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_JDBCAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/NTEventLogAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_NTEVENTLOGAPPENDER';
  package Log::Log4perl::JavaMap::NTEventLogAppender;
  
  use Carp;
  use strict;
  
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my ($source,   #        
          );
  
      if (defined $data->{Source}{value}) {
          $source = $data->{Source}{value}
      }elsif (defined $data->{source}{value}){
          $source = $data->{source}{value};
      }else{
          $source = 'user';
      }
  
      
      return Log::Log4perl::Appender->new("Log::Dispatch::Win32EventLog",
          name      => $appender_name,
          source    => $source,
          min_level => 'debug',
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::NTEventLogAppender - wraps Log::Dispatch::Win32EventLog
  
  
  =head1 DESCRIPTION
  
  This maps log4j's NTEventLogAppender to Log::Dispatch::Win32EventLog
  
  Possible config properties for log4j NTEventLogAppender are 
  
      Source
  
  Possible config properties for Log::Dispatch::Win32EventLog are
  
      source
  
  Boy, that was hard.
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_NTEVENTLOGAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/RollingFileAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_ROLLINGFILEAPPENDER';
  package Log::Log4perl::JavaMap::RollingFileAppender;
  
  use Carp;
  use strict;
  use Log::Dispatch::FileRotate 1.10;
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my $filename =  $data->{File}{value} || 
                  $data->{filename}{value} || 
                  die "'File' not supplied for appender '$appender_name', required for a '$data->{value}'\n";
  
      my $mode;
      if (defined($data->{Append}{value})){
          if (lc $data->{Append}{value} eq 'true' || $data->{Append}{value} == 1){
              $mode = 'append';
          }elsif (lc $data->{Append}{value} eq 'false' || $data->{Append}{value} == 0) {
              $mode = 'write';
          }elsif($data->{Append} =~ /^(write|append)$/){
              $mode = $data->{Append}
          }else{
              die "'$data->{Append}' is not a legal value for Append for appender '$appender_name', '$data->{value}'\n";
          }
      }else{
          $mode = 'append';
      }
  
      my $autoflush;
      if (defined($data->{BufferedIO}{value})){
          if (lc $data->{BufferedIO}{value} eq 'true' || $data->{BufferedIO}{value}){
              $autoflush = 1;
          }elsif (lc $data->{BufferedIO}{value} eq 'true' || ! $data->{BufferedIO}{value}) {
              $autoflush = 0;
          }else{
              die "'$data->{BufferedIO}' is not a legal value for BufferedIO for appender '$appender_name', '$data->{value}'\n";
          }
      }else{
          $autoflush = 1;
      }
  
      my $max;
      if (defined $data->{MaxBackupIndex}{value}) {
          $max = $data->{MaxBackupIndex}{value};
      }elsif (defined $data->{max}{value}){
          $max = $data->{max}{value};
      }else{
          $max = 1;
  
      }
  
      my $size;
      if (defined $data->{MaxFileSize}{value}) {
          $size = $data->{MaxFileSize}{value}
      }elsif (defined $data->{size}{value}){
          $size = $data->{size}{value};
      }else{
          $size = 10_000_000;
      }
  
  
      return Log::Log4perl::Appender->new("Log::Dispatch::FileRotate",
          name      => $appender_name,
          filename  => $filename,
          mode      => $mode,
          autoflush => $autoflush,
          size      => $size,
          max       => $max,
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::RollingFileAppender - wraps Log::Dispatch::FileRotate
  
  =head1 SYNOPSIS
  
  
  =head1 DESCRIPTION
  
  This maps log4j's RollingFileAppender to Log::Dispatch::FileRotate 
  by Mark Pfeiffer, <markpf@mlp-consulting.com.au>.
  
  Possible config properties for log4j ConsoleAppender are 
  
      File
      Append      "true|false|1|0" default=true
      BufferedIO  "true|false|1|0" default=false (i.e. autoflush is on)
      MaxFileSize default 10_000_000
      MaxBackupIndex default is 1
  
  Possible config properties for Log::Dispatch::FileRotate are
  
      filename
      mode  "write|append"
      autoflush 0|1
      size
      max
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_ROLLINGFILEAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/SyslogAppender.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_SYSLOGAPPENDER';
  package Log::Log4perl::JavaMap::SyslogAppender;
  
  use Carp;
  use strict;
  use Log::Dispatch::Syslog;
  
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      my ($ident,    #defaults to $0
          $logopt,   #Valid options are 'cons', 'pid', 'ndelay', and 'nowait'.
          $facility, #Valid options are 'auth', 'authpriv',
                     #  'cron', 'daemon', 'kern', 'local0' through 'local7',
                     #   'mail, 'news', 'syslog', 'user', 'uucp'.  Defaults to
                     #   'user'
          $socket,   #Valid options are 'unix' or 'inet'. Defaults to 'inet'
          );
  
      if (defined $data->{Facility}{value}) {
          $facility = $data->{Facility}{value}
      }elsif (defined $data->{facility}{value}){
          $facility = $data->{facility}{value};
      }else{
          $facility = 'user';
      }
  
      if (defined $data->{Ident}{value}) {
          $ident = $data->{Ident}{value}
      }elsif (defined $data->{ident}{value}){
          $ident = $data->{ident}{value};
      }else{
          $ident = $0;
      }
      
      return Log::Log4perl::Appender->new("Log::Dispatch::Syslog",
          name      => $appender_name,
          facility  => $facility,
          ident     => $ident,
          min_level => 'debug',
      );
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::SysLogAppender - wraps Log::Dispatch::Syslog
  
  
  =head1 DESCRIPTION
  
  This maps log4j's SyslogAppender to Log::Dispatch::Syslog
  
  Possible config properties for log4j SyslogAppender are 
  
      SyslogHost (Log::Dispatch::Syslog only accepts 'localhost')
      Facility
  
  Possible config properties for Log::Dispatch::Syslog are
  
      min_level (debug)
      max_level
      ident    (defaults to $0)
      logopt
      facility 
      socket   (defaults to 'inet')
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_SYSLOGAPPENDER

$fatpacked{"Log/Log4perl/JavaMap/TestBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_JAVAMAP_TESTBUFFER';
  package Log::Log4perl::JavaMap::TestBuffer;
  
  use Carp;
  use strict;
  use Log::Log4perl::Appender::TestBuffer;
  
  use constant _INTERNAL_DEBUG => 0;
  
  sub new {
      my ($class, $appender_name, $data) = @_;
      my $stderr;
  
      return Log::Log4perl::Appender->new("Log::Log4perl::Appender::TestBuffer",
                                          name => $appender_name);
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::JavaMap::TestBuffer - wraps Log::Log4perl::Appender::TestBuffer
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  Just for testing the Java mapping.
  
  =head1 SEE ALSO
  
  http://jakarta.apache.org/log4j/docs/
  
  Log::Log4perl::Javamap
  
  Log::Dispatch::Screen
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_JAVAMAP_TESTBUFFER

$fatpacked{"Log/Log4perl/Layout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT';
  package Log::Log4perl::Layout;
  
  
  use Log::Log4perl::Layout::SimpleLayout;
  use Log::Log4perl::Layout::PatternLayout;
  use Log::Log4perl::Layout::PatternLayout::Multiline;
  
  
  ####################################################
  sub appender_name {
  ####################################################
      my ($self, $arg) = @_;
  
      if ($arg) {
          die "setting appender_name unimplemented until it makes sense";
      }
      return $self->{appender_name};
  }
  
  
  ##################################################
  sub define {
  ##################################################
      ;  #subclasses may implement
  }
  
  
  ##################################################
  sub render {
  ##################################################
      die "subclass must implement render";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout - Log4perl Layout Virtual Base Class
  
  =head1 SYNOPSIS
  
      # Not to be used directly, see below
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Layout> is a virtual base class for the two currently 
  implemented layout types
  
      Log::Log4perl::Layout::SimpleLayout
      Log::Log4perl::Layout::PatternLayout
  
  Unless you're implementing a new layout class for Log4perl, you shouldn't
  use this class directly, but rather refer to
  L<Log::Log4perl::Layout::SimpleLayout> or 
  L<Log::Log4perl::Layout::PatternLayout>.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT

$fatpacked{"Log/Log4perl/Layout/NoopLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_NOOPLAYOUT';
  ##################################################
  package Log::Log4perl::Layout::NoopLayout;
  ##################################################
  
  
  ##################################################
  sub new {
  ##################################################
      my $class = shift;
      $class = ref ($class) || $class;
  
      my $self = {
          format      => undef,
          info_needed => {},
          stack       => [],
      };
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub render {
  ##################################################
      #my($self, $message, $category, $priority, $caller_level) = @_;
      return $_[1];;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout::NoopLayout - Pass-thru Layout
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Layout::NoopLayout;
    my $layout = Log::Log4perl::Layout::NoopLayout->new();
  
  =head1 DESCRIPTION
  
  This is a no-op layout, returns the logging message unaltered,
  useful for implementing the DBI logger.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT_NOOPLAYOUT

$fatpacked{"Log/Log4perl/Layout/PatternLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT';
  ##################################################
  package Log::Log4perl::Layout::PatternLayout;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  use constant _INTERNAL_DEBUG => 0;
  
  use Carp;
  use Log::Log4perl::Util;
  use Log::Log4perl::Level;
  use Log::Log4perl::DateFormat;
  use Log::Log4perl::NDC;
  use Log::Log4perl::MDC;
  use Log::Log4perl::Util::TimeTracker;
  use File::Spec;
  use File::Basename;
  
  our $TIME_HIRES_AVAILABLE_WARNED = 0;
  our $HOSTNAME;
  our %GLOBAL_USER_DEFINED_CSPECS = ();
  
  our $CSPECS = 'cCdFHIlLmMnpPrRtTxX%';
  
  BEGIN {
      # Check if we've got Sys::Hostname. If not, just punt.
      $HOSTNAME = "unknown.host";
      if(Log::Log4perl::Util::module_available("Sys::Hostname")) {
          require Sys::Hostname;
          $HOSTNAME = Sys::Hostname::hostname();
      }
  }
  
  use base qw(Log::Log4perl::Layout);
  
  no strict qw(refs);
  
  ##################################################
  sub new {
  ##################################################
      my $class = shift;
      $class = ref ($class) || $class;
  
      my $options       = ref $_[0] eq "HASH" ? shift : {};
      my $layout_string = @_ ? shift : '%m%n';
      
      my $self = {
          format                => undef,
          info_needed           => {},
          stack                 => [],
          CSPECS                => $CSPECS,
          dontCollapseArrayRefs => $options->{dontCollapseArrayRefs}{value},
          last_time             => undef,
          undef_column_value    => 
              (exists $options->{ undef_column_value } 
                  ? $options->{ undef_column_value } 
                  : "[undef]"),
      };
  
      $self->{timer} = Log::Log4perl::Util::TimeTracker->new(
          time_function => $options->{time_function}
      );
  
      if(exists $options->{ConversionPattern}->{value}) {
          $layout_string = $options->{ConversionPattern}->{value};
      }
  
      if(exists $options->{message_chomp_before_newline}) {
          $self->{message_chomp_before_newline} = 
            $options->{message_chomp_before_newline}->{value};
      } else {
          $self->{message_chomp_before_newline} = 1;
      }
  
      bless $self, $class;
  
      #add the global user-defined cspecs
      foreach my $f (keys %GLOBAL_USER_DEFINED_CSPECS){
              #add it to the list of letters
          $self->{CSPECS} .= $f;
               #for globals, the coderef is already evaled, 
          $self->{USER_DEFINED_CSPECS}{$f} = $GLOBAL_USER_DEFINED_CSPECS{$f};
      }
  
      #add the user-defined cspecs local to this appender
      foreach my $f (keys %{$options->{cspec}}){
          $self->add_layout_cspec($f, $options->{cspec}{$f}{value});
      }
  
      # non-portable line breaks
      $layout_string =~ s/\\n/\n/g;
      $layout_string =~ s/\\r/\r/g;
  
      $self->define($layout_string);
  
      return $self;
  }
  
  ##################################################
  sub define {
  ##################################################
      my($self, $format) = @_;
  
          # If the message contains a %m followed by a newline,
          # make a note of that so that we can cut a superfluous 
          # \n off the message later on
      if($self->{message_chomp_before_newline} and $format =~ /%m%n/) {
          $self->{message_chompable} = 1;
      } else {
          $self->{message_chompable} = 0;
      }
  
      # Parse the format
      $format =~ s/%(-?\d*(?:\.\d+)?) 
                         ([$self->{CSPECS}])
                         (?:{(.*?)})*/
                         rep($self, $1, $2, $3);
                        /gex;
  
      $self->{printformat} = $format;
  }
  
  ##################################################
  sub rep {
  ##################################################
      my($self, $num, $op, $curlies) = @_;
  
      return "%%" if $op eq "%";
  
      # If it's a %d{...} construct, initialize a simple date
      # format formatter, so that we can quickly render later on.
      # If it's just %d, assume %d{yyyy/MM/dd HH:mm:ss}
      if($op eq "d") {
          if(defined $curlies) {
              $curlies = Log::Log4perl::DateFormat->new($curlies);
          } else {
              $curlies = Log::Log4perl::DateFormat->new("yyyy/MM/dd HH:mm:ss");
          }
      } elsif($op eq "m") {
          $curlies = $self->curlies_csv_parse($curlies);
      }
  
      push @{$self->{stack}}, [$op, $curlies];
  
      $self->{info_needed}->{$op}++;
  
      return "%${num}s";
  }
  
  ###########################################
  sub curlies_csv_parse {
  ###########################################
      my($self, $curlies) = @_;
  
      my $data = {};
  
      if(defined $curlies and length $curlies) {
          $curlies =~ s/\s//g;
  
          for my $field (split /,/, $curlies) {
              my($key, $value) = split /=/, $field;
              $data->{$key} = $value;
          }
      }
  
      return $data;
  }
  
  ##################################################
  sub render {
  ##################################################
      my($self, $message, $category, $priority, $caller_level) = @_;
  
      $caller_level = 0 unless defined  $caller_level;
  
      my %info    = ();
  
      $info{m}    = $message;
          # See 'define'
      chomp $info{m} if $self->{message_chompable};
  
      my @results = ();
  
      my $caller_offset = Log::Log4perl::caller_depth_offset( $caller_level );
  
      if($self->{info_needed}->{L} or
         $self->{info_needed}->{F} or
         $self->{info_needed}->{C} or
         $self->{info_needed}->{l} or
         $self->{info_needed}->{M} or
         $self->{info_needed}->{T} or
         0
        ) {
  
          my ($package, $filename, $line, 
              $subroutine, $hasargs,
              $wantarray, $evaltext, $is_require, 
              $hints, $bitmask) = caller($caller_offset);
  
          # If caller() choked because of a whacko caller level,
          # correct undefined values to '[undef]' in order to prevent 
          # warning messages when interpolating later
          unless(defined $bitmask) {
              for($package, 
                  $filename, $line,
                  $subroutine, $hasargs,
                  $wantarray, $evaltext, $is_require,
                  $hints, $bitmask) {
                  $_ = '[undef]' unless defined $_;
              }
          }
  
          $info{L} = $line;
          $info{F} = $filename;
          $info{C} = $package;
  
          if($self->{info_needed}->{M} or
             $self->{info_needed}->{l} or
             0) {
              # To obtain the name of the subroutine which triggered the 
              # logger, we need to go one additional level up.
              my $levels_up = 1; 
              {
                  my @callinfo = caller($caller_offset+$levels_up);
  
                  if(_INTERNAL_DEBUG) {
                      callinfo_dump( $caller_offset, \@callinfo );
                  }
  
                  $subroutine = $callinfo[3];
                      # If we're inside an eval, go up one level further.
                  if(defined $subroutine and
                     $subroutine eq "(eval)") {
                      print "Inside an eval, one up\n" if _INTERNAL_DEBUG;
                      $levels_up++;
                      redo;
                  }
              }
              $subroutine = "main::" unless $subroutine;
              print "Subroutine is '$subroutine'\n" if _INTERNAL_DEBUG;
              $info{M} = $subroutine;
              $info{l} = "$subroutine $filename ($line)";
          }
      }
  
      $info{X} = "[No curlies defined]";
      $info{x} = Log::Log4perl::NDC->get() if $self->{info_needed}->{x};
      $info{c} = $category;
      $info{d} = 1; # Dummy value, corrected later
      $info{n} = "\n";
      $info{p} = $priority;
      $info{P} = $$;
      $info{H} = $HOSTNAME;
  
      my $current_time;
  
      if($self->{info_needed}->{r} or $self->{info_needed}->{R}) {
          if(!$TIME_HIRES_AVAILABLE_WARNED++ and 
             !$self->{timer}->hires_available()) {
              warn "Requested %r/%R pattern without installed Time::HiRes\n";
          }
          $current_time = [$self->{timer}->gettimeofday()];
      }
  
      if($self->{info_needed}->{r}) {
          $info{r} = $self->{timer}->milliseconds( $current_time );
      }
      if($self->{info_needed}->{R}) {
          $info{R} = $self->{timer}->delta_milliseconds( $current_time );
      }
  
          # Stack trace wanted?
      if($self->{info_needed}->{T}) {
          local $Carp::CarpLevel =
                $Carp::CarpLevel + $caller_offset;
          my $mess = Carp::longmess(); 
          chomp($mess);
          # $mess =~ s/(?:\A\s*at.*\n|^\s*Log::Log4perl.*\n|^\s*)//mg;
          $mess =~ s/(?:\A\s*at.*\n|^\s*)//mg;
          $mess =~ s/\n/, /g;
          $info{T} = $mess;
      }
  
          # As long as they're not implemented yet ..
      $info{t} = "N/A";
  
          # Iterate over all info fields on the stack
      for my $e (@{$self->{stack}}) {
          my($op, $curlies) = @$e;
  
          my $result;
  
          if(exists $self->{USER_DEFINED_CSPECS}->{$op}) {
              next unless $self->{info_needed}->{$op};
              $self->{curlies} = $curlies;
              $result = $self->{USER_DEFINED_CSPECS}->{$op}->($self, 
                                $message, $category, $priority, 
                                $caller_offset+1);
          } elsif(exists $info{$op}) {
              $result = $info{$op};
              if($curlies) {
                  $result = $self->curly_action($op, $curlies, $info{$op},
                                                $self->{printformat}, \@results);
              } else {
                  # just for %d
                  if($op eq 'd') {
                      $result = $info{$op}->format($self->{timer}->gettimeofday());
                  }
              }
          } else {
              warn "Format %'$op' not implemented (yet)";
              $result = "FORMAT-ERROR";
          }
  
          $result = $self->{undef_column_value} unless defined $result;
          push @results, $result;
      }
  
        # dbi appender needs that
      if( scalar @results == 1 and
          !defined $results[0] ) {
          return undef;
      }
  
      return (sprintf $self->{printformat}, @results);
  }
  
  ##################################################
  sub curly_action {
  ##################################################
      my($self, $ops, $curlies, $data, $printformat, $results) = @_;
  
      if($ops eq "c") {
          $data = shrink_category($data, $curlies);
      } elsif($ops eq "C") {
          $data = shrink_category($data, $curlies);
      } elsif($ops eq "X") {
          $data = Log::Log4perl::MDC->get($curlies);
      } elsif($ops eq "d") {
          $data = $curlies->format( $self->{timer}->gettimeofday() );
      } elsif($ops eq "M") {
          $data = shrink_category($data, $curlies);
      } elsif($ops eq "m") {
          if(exists $curlies->{chomp}) {
              chomp $data;
          }
          if(exists $curlies->{indent}) {
              if(defined $curlies->{indent}) {
                    # fixed indent
                  $data =~ s/\n/ "\n" . (" " x $curlies->{indent})/ge;
              } else {
                    # indent on the lead-in
                  no warnings; # trailing array elements are undefined
                  my $indent = length sprintf $printformat, @$results;
                  $data =~ s/\n/ "\n" . (" " x $indent)/ge;
              }
          }
      } elsif($ops eq "F") {
          my @parts = File::Spec->splitdir($data);
              # Limit it to max curlies entries
          if(@parts > $curlies) {
              splice @parts, 0, @parts - $curlies;
          }
          $data = File::Spec->catfile(@parts);
      } elsif($ops eq "p") {
          $data = substr $data, 0, $curlies;
      }
  
      return $data;
  }
  
  ##################################################
  sub shrink_category {
  ##################################################
      my($category, $len) = @_;
  
      my @components = split /\.|::/, $category;
  
      if(@components > $len) {
          splice @components, 0, @components - $len;
          $category = join '.', @components;
      } 
  
      return $category;
  }
  
  ##################################################
  sub add_global_cspec {
  ##################################################
  # This is a Class method.
  # Accepts a coderef or text
  ##################################################
  
      unless($Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE) {
          die "\$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE setting " .
              "prohibits user defined cspecs";
      }
  
      my ($letter, $perlcode) = @_;
  
      croak "Illegal value '$letter' in call to add_global_cspec()"
          unless ($letter =~ /^[a-zA-Z]$/);
  
      croak "Missing argument for perlcode for 'cspec.$letter' ".
            "in call to add_global_cspec()"
          unless $perlcode;
  
      croak "Please don't redefine built-in cspecs [$CSPECS]\n".
            "like you do for \"cspec.$letter\"\n "
          if ($CSPECS =~/$letter/);
  
      if (ref $perlcode eq 'CODE') {
          $GLOBAL_USER_DEFINED_CSPECS{$letter} = $perlcode;
  
      }elsif (! ref $perlcode){
          
          $GLOBAL_USER_DEFINED_CSPECS{$letter} = 
              Log::Log4perl::Config::compile_if_perl($perlcode);
  
          if ($@) {
              die qq{Compilation failed for your perl code for }.
                  qq{"log4j.PatternLayout.cspec.$letter":\n}.
                  qq{This is the error message: \t$@\n}.
                  qq{This is the code that failed: \n$perlcode\n};
          }
  
          croak "eval'ing your perlcode for 'log4j.PatternLayout.cspec.$letter' ".
                "doesn't return a coderef \n".
                "Here is the perl code: \n\t$perlcode\n "
              unless (ref $GLOBAL_USER_DEFINED_CSPECS{$letter} eq 'CODE');
  
      }else{
          croak "I don't know how to handle perlcode=$perlcode ".
                "for 'cspec.$letter' in call to add_global_cspec()";
      }
  }
  
  ##################################################
  sub add_layout_cspec {
  ##################################################
  # object method
  # adds a cspec just for this layout
  ##################################################
      my ($self, $letter, $perlcode) = @_;
  
      unless($Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE) {
          die "\$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE setting " .
              "prohibits user defined cspecs";
      }
  
      croak "Illegal value '$letter' in call to add_layout_cspec()"
          unless ($letter =~ /^[a-zA-Z]$/);
  
      croak "Missing argument for perlcode for 'cspec.$letter' ".
            "in call to add_layout_cspec()"
          unless $perlcode;
  
      croak "Please don't redefine built-in cspecs [$CSPECS] \n".
            "like you do for 'cspec.$letter'"
          if ($CSPECS =~/$letter/);
  
      if (ref $perlcode eq 'CODE') {
  
          $self->{USER_DEFINED_CSPECS}{$letter} = $perlcode;
  
      }elsif (! ref $perlcode){
          
          $self->{USER_DEFINED_CSPECS}{$letter} =
              Log::Log4perl::Config::compile_if_perl($perlcode);
  
          if ($@) {
              die qq{Compilation failed for your perl code for }.
                  qq{"cspec.$letter":\n}.
                  qq{This is the error message: \t$@\n}.
                  qq{This is the code that failed: \n$perlcode\n};
          }
          croak "eval'ing your perlcode for 'cspec.$letter' ".
                "doesn't return a coderef \n".
                "Here is the perl code: \n\t$perlcode\n "
              unless (ref $self->{USER_DEFINED_CSPECS}{$letter} eq 'CODE');
  
  
      }else{
          croak "I don't know how to handle perlcode=$perlcode ".
                "for 'cspec.$letter' in call to add_layout_cspec()";
      }
  
      $self->{CSPECS} .= $letter;
  }
  
  ###########################################
  sub callinfo_dump {
  ###########################################
      my($level, $info) = @_;
  
      my @called_by = caller(0);
  
      # Just for internal debugging
      $called_by[1] = basename $called_by[1];
      print "caller($level) at $called_by[1]-$called_by[2] returned ";
  
      my @by_idx;
  
      # $info->[1] = basename $info->[1] if defined $info->[1];
  
      my $i = 0;
      for my $field (qw(package filename line subroutine hasargs
                        wantarray evaltext is_require hints bitmask)) {
          $by_idx[$i] = $field;
          $i++;
      }
  
      $i = 0;
      for my $value (@$info) {
          my $field = $by_idx[ $i ];
          print "$field=", 
                (defined $info->[$i] ? $info->[$i] : "[undef]"),
                " ";
          $i++;
      }
  
      print "\n";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout::PatternLayout - Pattern Layout
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Layout::PatternLayout;
  
    my $layout = Log::Log4perl::Layout::PatternLayout->new(
                                                     "%d (%F:%L)> %m");
  
  
  =head1 DESCRIPTION
  
  Creates a pattern layout according to
  http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/PatternLayout.html
  and a couple of Log::Log4perl-specific extensions.
  
  The C<new()> method creates a new PatternLayout, specifying its log
  format. The format
  string can contain a number of placeholders which will be
  replaced by the logging engine when it's time to log the message:
  
      %c Category of the logging event.
      %C Fully qualified package (or class) name of the caller
      %d Current date in yyyy/MM/dd hh:mm:ss format
      %d{...} Current date in customized format (see below)
      %F File where the logging event occurred
      %H Hostname (if Sys::Hostname is available)
      %l Fully qualified name of the calling method followed by the
         callers source the file name and line number between 
         parentheses.
      %L Line number within the file where the log statement was issued
      %m The message to be logged
      %m{chomp} Log message, stripped off a trailing newline
      %m{indent} Log message, multi-lines indented so they line up with first
      %m{indent=n} Log message, multi-lines indented by n spaces
      %M Method or function where the logging request was issued
      %n Newline (OS-independent)
      %p Priority of the logging event (%p{1} shows the first letter)
      %P pid of the current process
      %r Number of milliseconds elapsed from program start to logging 
         event
      %R Number of milliseconds elapsed from last logging event to
         current logging event 
      %T A stack trace of functions called
      %x The topmost NDC (see below)
      %X{key} The entry 'key' of the MDC (see below)
      %% A literal percent (%) sign
  
  NDC and MDC are explained in L<Log::Log4perl/"Nested Diagnostic Context (NDC)">
  and L<Log::Log4perl/"Mapped Diagnostic Context (MDC)">.
  
  The granularity of time values is milliseconds if Time::HiRes is available.
  If not, only full seconds are used.
  
  Every once in a while, someone uses the "%m%n" pattern and
  additionally provides an extra newline in the log message (e.g.
  C<-E<gt>log("message\n")>. To avoid printing an extra newline in
  this case, the PatternLayout will chomp the message, printing only
  one newline. This option can be controlled by PatternLayout's
  C<message_chomp_before_newline> option. See L<Advanced options>
  for details.
  
  =head2 Quantify placeholders
  
  All placeholders can be extended with formatting instructions,
  just like in I<printf>:
  
      %20c   Reserve 20 chars for the category, right-justify and fill
             with blanks if it is shorter
      %-20c  Same as %20c, but left-justify and fill the right side 
             with blanks
      %09r   Zero-pad the number of milliseconds to 9 digits
      %.8c   Specify the maximum field with and have the formatter
             cut off the rest of the value
  
  =head2 Fine-tuning with curlies
  
  Some placeholders have special functions defined if you add curlies 
  with content after them:
  
      %c{1}  Just show the right-most category compontent, useful in large
             class hierarchies (Foo::Baz::Bar -> Bar)
      %c{2}  Just show the two right most category components
             (Foo::Baz::Bar -> Baz::Bar)
  
      %F     Display source file including full path
      %F{1}  Just display filename
      %F{2}  Display filename and last path component (dir/test.log)
      %F{3}  Display filename and last two path components (d1/d2/test.log)
  
      %M     Display fully qualified method/function name
      %M{1}  Just display method name (foo)
      %M{2}  Display method name and last path component (main::foo)
  
  In this way, you're able to shrink the displayed category or
  limit file/path components to save space in your logs.
  
  =head2 Fine-tune the date
  
  If you're not happy with the default %d format for the date which 
  looks like
  
      yyyy/MM/DD HH:mm:ss
  
  (which is slightly different from Log4j which uses C<yyyy-MM-dd HH:mm:ss,SSS>)
  you're free to fine-tune it in order to display only certain characteristics
  of a date, according to the SimpleDateFormat in the Java World
  (http://java.sun.com/j2se/1.3/docs/api/java/text/SimpleDateFormat.html):
  
      %d{HH:mm}     "23:45" -- Just display hours and minutes
      %d{yy, EEEE}  "02, Monday" -- Just display two-digit year 
                                    and spelled-out weekday
  Here's the symbols and their meaning, according to the SimpleDateFormat
  specification:
  
      Symbol   Meaning                 Presentation     Example
      ------   -------                 ------------     -------
      G        era designator          (Text)           AD
      y        year                    (Number)         1996 
      M        month in year           (Text & Number)  July & 07
      d        day in month            (Number)         10
      h        hour in am/pm (1-12)    (Number)         12
      H        hour in day (0-23)      (Number)         0
      m        minute in hour          (Number)         30
      s        second in minute        (Number)         55
      E        day in week             (Text)           Tuesday
      D        day in year             (Number)         189
      a        am/pm marker            (Text)           PM
      e        epoch seconds           (Number)         1315011604
  
      (Text): 4 or more pattern letters--use full form, < 4--use short or 
              abbreviated form if one exists. 
  
      (Number): the minimum number of digits. Shorter numbers are 
                zero-padded to this amount. Year is handled 
                specially; that is, if the count of 'y' is 2, the 
                Year will be truncated to 2 digits. 
  
      (Text & Number): 3 or over, use text, otherwise use number. 
  
  There's also a bunch of pre-defined formats:
  
      %d{ABSOLUTE}   "HH:mm:ss,SSS"
      %d{DATE}       "dd MMM yyyy HH:mm:ss,SSS"
      %d{ISO8601}    "yyyy-MM-dd HH:mm:ss,SSS"
  
  =head2 Custom cspecs
  
  First of all, "cspecs" is short for "conversion specifiers", which is 
  the log4j and the printf(3) term for what Mike is calling "placeholders."
  I suggested "cspecs" for this part of the api before I saw that Mike was 
  using "placeholders" consistently in the log4perl documentation.  Ah, the
  joys of collaboration ;=) --kg
  
  If the existing corpus of placeholders/cspecs isn't good enough for you,
  you can easily roll your own:
  
      #'U' a global user-defined cspec     
      log4j.PatternLayout.cspec.U = sub { return "UID: $< "}
      
      #'K' cspec local to appndr1                 (pid in hex)
      log4j.appender.appndr1.layout.cspec.K = sub { return sprintf "%1x", $$}
      
      #and now you can use them
      log4j.appender.appndr1.layout.ConversionPattern = %K %U %m%n
  
  The benefit of this approach is that you can define and use the cspecs 
  right next to each other in the config file.
  
  If you're an API kind of person, there's also this call:
  
      Log::Log4perl::Layout::PatternLayout::
                      add_global_cspec('Z', sub {'zzzzzzzz'}); #snooze?
  
  When the log message is being put together, your anonymous sub 
  will be called with these arguments:
  
      ($layout, $message, $category, $priority, $caller_level);
      
      layout: the PatternLayout object that called it
      message: the logging message (%m)
      category: e.g. groceries.beverages.adult.beer.schlitz
      priority: e.g. DEBUG|WARN|INFO|ERROR|FATAL
      caller_level: how many levels back up the call stack you have 
          to go to find the caller
  
  Please note that the subroutines you're defining in this way are going
  to be run in the C<main> namespace, so be sure to fully qualify functions
  and variables if they're located in different packages. I<Also make sure
  these subroutines aren't using Log4perl, otherwise Log4perl will enter 
  an infinite recursion.>
  
  With Log4perl 1.20 and better, cspecs can be written with parameters in
  curly braces. Writing something like
  
      log4perl.appender.Screen.layout.ConversionPattern = %U{user} %U{id} %m%n
  
  will cause the cspec function defined for %U to be called twice, once
  with the parameter 'user' and then again with the parameter 'id', 
  and the placeholders in the cspec string will be replaced with
  the respective return values.
  
  The parameter value is available in the 'curlies' entry of the first
  parameter passed to the subroutine (the layout object reference). 
  So, if you wanted to map %U{xxx} to entries in the POE session hash, 
  you'd write something like:
  
     log4perl.PatternLayout.cspec.U = sub { \
       POE::Kernel->get_active_session->get_heap()->{ $_[0]->{curlies} } }
                                            
  B<SECURITY NOTE>
    
  This feature means arbitrary perl code can be embedded in the config file. 
  In the rare case where the people who have access to your config file are
  different from the people who write your code and shouldn't have execute
  rights, you might want to set
  
      $Log::Log4perl::Config->allow_code(0);
  
  before you call init().  Alternatively you can supply a restricted set of
  Perl opcodes that can be embedded in the config file as described in
  L<Log::Log4perl/"Restricting what Opcodes can be in a Perl Hook">.
    
  =head2 Advanced Options
  
  The constructor of the C<Log::Log4perl::Layout::PatternLayout> class
  takes an optional hash reference as a first argument to specify
  additional options in order to (ab)use it in creative ways:
  
    my $layout = Log::Log4perl::Layout::PatternLayout->new(
      { time_function       => \&my_time_func,
      }, 
      "%d (%F:%L)> %m");
  
  Here's a list of parameters:
  
  =over 4
  
  =item time_function
  
  Takes a reference to a function returning the time for the time/date
  fields, either in seconds
  since the epoch or as an array, carrying seconds and 
  microseconds, just like C<Time::HiRes::gettimeofday> does.
  
  =item message_chomp_before_newline
  
  If a layout contains the pattern "%m%n" and the message ends with a newline,
  PatternLayout will chomp the message, to prevent printing two newlines. 
  If this is not desired, and you want two newlines in this case, 
  the feature can be turned off by setting the
  C<message_chomp_before_newline> option to a false value:
  
    my $layout = Log::Log4perl::Layout::PatternLayout->new(
        { message_chomp_before_newline => 0
        }, 
        "%d (%F:%L)> %m%n");
  
  In a Log4perl configuration file, the feature can be turned off like this:
  
      log4perl.appender.App.layout   = PatternLayout
      log4perl.appender.App.layout.ConversionPattern = %d %m%n
        # Yes, I want two newlines
      log4perl.appender.App.layout.message_chomp_before_newline = 0
  
  =back
  
  =head2 Getting rid of newlines
  
  If your code contains logging statements like 
  
        # WRONG, don't do that!
      $logger->debug("Some message\n");
  
  then it's usually best to strip the newlines from these calls. As explained
  in L<Log::Log4perl/Logging newlines>, logging statements should never contain
  newlines, but rely on appender layouts to add necessary newlines instead.
  
  If changing the code is not an option, use the special PatternLayout 
  placeholder %m{chomp} to refer to the message excluding a trailing 
  newline:
  
      log4perl.appender.App.layout.ConversionPattern = %d %m{chomp}%n
  
  This will add a single newline to every message, regardless if it
  complies with the Log4perl newline guidelines or not (thanks to 
  Tim Bunce for this idea).
  
  =head2 Multi Lines
  
  If a log message consists of several lines, like
  
      $logger->debug("line1\nline2\nline3");
  
  then by default, they get logged like this (assuming the the layout is
  set to "%d>%m%n"):
  
        # layout %d>%m%n
      2014/07/27 12:46:16>line1
      line2
      line3
  
  If you'd rather have the messages aligned like
  
        # layout %d>%m{indent}%n
      2014/07/27 12:46:16>line1
                          line2
                          line3
  
  then use the C<%m{indent}> option for the %m specifier. This option
  can also take a fixed value, as in C<%m{indent=2}>, which indents
  subsequent lines by two spaces:
  
        # layout %d>%m{indent=2}%n
      2014/07/27 12:46:16>line1
        line2
        line3
  
  Note that you can still add the C<chomp> option for the C<%m> specifier
  in this case (see above what it does), simply add it after a 
  separating comma, like in C<%m{indent=2,chomp}>.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT

$fatpacked{"Log/Log4perl/Layout/PatternLayout/Multiline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT_MULTILINE';
  #!/usr/bin/perl
  
  package Log::Log4perl::Layout::PatternLayout::Multiline;
  use base qw(Log::Log4perl::Layout::PatternLayout);
  
  ###########################################
  sub render {
  ###########################################
      my($self, $message, $category, $priority, $caller_level) = @_;
  
      my @messages = split /\r?\n/, $message;
  
      $caller_level = 0 unless defined $caller_level;
  
      my $result = '';
  
      for my $msg ( @messages ) {
          $result .= $self->SUPER::render(
              $msg, $category, $priority, $caller_level + 1
          );
      }
      return $result;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
      Log::Log4perl::Layout::PatternLayout::Multiline
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Layout::PatternLayout::Multiline;
  
      my $layout = Log::Log4perl::Layout::PatternLayout::Multiline->new(
          "%d (%F:%L)> %m");
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Layout::PatternLayout::Multiline> is a subclass
  of Log4perl's PatternLayout and is helpful if you send multiline
  messages to your appenders which appear as
  
      2007/04/04 23:59:01 This is
      a message with
      multiple lines
  
  and you want them to appear as 
  
      2007/04/04 23:59:01 This is
      2007/04/04 23:59:01 a message with
      2007/04/04 23:59:01 multiple lines
  
  instead. This layout class simply splits up the incoming message into
  several chunks split by line breaks and renders them with PatternLayout
  just as if it had arrived in separate chunks in the first place.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT_PATTERNLAYOUT_MULTILINE

$fatpacked{"Log/Log4perl/Layout/SimpleLayout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LAYOUT_SIMPLELAYOUT';
  ##################################################
  package Log::Log4perl::Layout::SimpleLayout;
  ##################################################
  # as documented in
  # http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/SimpleLayout.html
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  use Log::Log4perl::Level;
  
  no strict qw(refs);
  use base qw(Log::Log4perl::Layout);
  
  ##################################################
  sub new {
  ##################################################
      my $class = shift;
      $class = ref ($class) || $class;
  
      my $self = {
          format      => undef,
          info_needed => {},
          stack       => [],
      };
  
      bless $self, $class;
  
      return $self;
  }
  
  ##################################################
  sub render {
  ##################################################
      my($self, $message, $category, $priority, $caller_level) = @_;
  
      return "$priority - $message\n";
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Layout::SimpleLayout - Simple Layout
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Layout::SimpleLayout;
    my $layout = Log::Log4perl::Layout::SimpleLayout->new();
  
  =head1 DESCRIPTION
  
  This class implements the C<log4j> simple layout format -- it basically 
  just prints the message priority and the message, that's all.
  Check 
  http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/SimpleLayout.html
  for details.
  
  =head1 SEE ALSO
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LAYOUT_SIMPLELAYOUT

$fatpacked{"Log/Log4perl/Level.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LEVEL';
  ###############r###################################
  package Log::Log4perl::Level;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  use Carp;
  
  # log4j, for whatever reason, puts 0 as all and MAXINT as OFF.
  # this seems less optimal, as more logging would imply a higher
  # level. But oh well. Probably some brokenness that has persisted. :)
  use constant ALL_INT   => 0;
  use constant TRACE_INT =>  5000;
  use constant DEBUG_INT => 10000;
  use constant INFO_INT  => 20000;
  use constant WARN_INT  => 30000;
  use constant ERROR_INT => 40000;
  use constant FATAL_INT => 50000;
  use constant OFF_INT   => (2 ** 31) - 1;
  
  no strict qw(refs);
  use vars qw(%PRIORITY %LEVELS %SYSLOG %L4P_TO_LD);
  
  %PRIORITY = (); # unless (%PRIORITY);
  %LEVELS = () unless (%LEVELS);
  %SYSLOG = () unless (%SYSLOG);
  %L4P_TO_LD = () unless (%L4P_TO_LD);
  
  sub add_priority {
    my ($prio, $intval, $syslog, $log_dispatch_level) = @_;
    $prio = uc($prio); # just in case;
  
    $PRIORITY{$prio}    = $intval;
    $LEVELS{$intval}    = $prio;
  
    # Set up the mapping between Log4perl integer levels and 
    # Log::Dispatch levels
    # Note: Log::Dispatch uses the following levels:
    # 0 debug
    # 1 info
    # 2 notice
    # 3 warning
    # 4 error
    # 5 critical
    # 6 alert
    # 7 emergency
  
        # The equivalent Log::Dispatch level is optional, set it to 
        # the highest value (7=emerg) if it's not provided.
    $log_dispatch_level = 7 unless defined $log_dispatch_level;
    
    $L4P_TO_LD{$prio}  = $log_dispatch_level;
  
    $SYSLOG{$prio}      = $syslog if defined($syslog);
  }
  
  # create the basic priorities
  add_priority("OFF",   OFF_INT,   -1, 7);
  add_priority("FATAL", FATAL_INT,  0, 7);
  add_priority("ERROR", ERROR_INT,  3, 4);
  add_priority("WARN",  WARN_INT,   4, 3);
  add_priority("INFO",  INFO_INT,   6, 1);
  add_priority("DEBUG", DEBUG_INT,  7, 0);
  add_priority("TRACE", TRACE_INT,  8, 0);
  add_priority("ALL",   ALL_INT,    8, 0);
  
  # we often sort numerically, so a helper func for readability
  sub numerically {$a <=> $b}
  
  ###########################################
  sub import {
  ###########################################
      my($class, $namespace) = @_;
             
      if(defined $namespace) {
          # Export $OFF, $FATAL, $ERROR etc. to
          # the given namespace
          $namespace .= "::" unless $namespace =~ /::$/;
      } else {
          # Export $OFF, $FATAL, $ERROR etc. to
          # the caller's namespace
          $namespace = caller(0) . "::";
      }
  
      for my $key (keys %PRIORITY) {
          my $name  = "$namespace$key";
          my $value = $PRIORITY{$key};
          *{"$name"} = \$value;
  	my $nameint = "$namespace${key}_INT";
  	my $func = uc($key) . "_INT";
  	*{"$nameint"} = \&$func;
      }
  }
  
  ##################################################
  sub new { 
  ##################################################
      # We don't need any of this class nonsense
      # in Perl, because we won't allow subclassing
      # from this. We're optimizing for raw speed.
  }
  
  ##################################################
  sub to_priority {
  # changes a level name string to a priority numeric
  ##################################################
      my($string) = @_;
  
      if(exists $PRIORITY{$string}) {
          return $PRIORITY{$string};
      }else{
          croak "level '$string' is not a valid error level (".join ('|', keys %PRIORITY),')';
      }
  }
  
  ##################################################
  sub to_level {
  # changes a priority numeric constant to a level name string 
  ##################################################
      my ($priority) = @_;
      if (exists $LEVELS{$priority}) {
          return $LEVELS{$priority}
      }else {
        croak("priority '$priority' is not a valid error level number (",
  	  join("|", sort numerically keys %LEVELS), "
            )");
      }
  
  }
  
  ##################################################
  sub to_LogDispatch_string {
  # translates into strings that Log::Dispatch recognizes
  ##################################################
      my($priority) = @_;
  
      confess "do what? no priority?" unless defined $priority;
  
      my $string;
  
      if(exists $LEVELS{$priority}) {
          $string = $LEVELS{$priority};
      }
  
          # Log::Dispatch idiosyncrasies
      if($priority == $PRIORITY{WARN}) {
          $string = "WARNING";
      }
           
      if($priority == $PRIORITY{FATAL}) {
          $string = "EMERGENCY";
      }
           
      return $string;
  }
  
  ###################################################
  sub is_valid {
  ###################################################
      my $q = shift;
  
      if ($q =~ /[A-Z]/) {
          return exists $PRIORITY{$q};
      }else{
          return $LEVELS{$q};
      }
      
  }
  
  sub get_higher_level {
      my ($old_priority, $delta) = @_;
  
      $delta ||= 1;
  
      my $new_priority = 0;
  
      foreach (1..$delta){
          #so the list is TRACE, DEBUG, INFO, WARN, ERROR, FATAL
        # but remember, the numbers go in reverse order!
          foreach my $p (sort numerically keys %LEVELS){
              if ($p > $old_priority) {
                  $new_priority = $p;
                  last;
              }
          }
          $old_priority = $new_priority;
      }
      return $new_priority;
  }
  
  sub get_lower_level {
      my ($old_priority, $delta) = @_;
  
      $delta ||= 1;
  
      my $new_priority = 0;
  
      foreach (1..$delta){
          #so the list is FATAL, ERROR, WARN, INFO, DEBUG, TRACE
        # but remember, the numbers go in reverse order!
          foreach my $p (reverse sort numerically keys %LEVELS){
              if ($p < $old_priority) {
                  $new_priority = $p;
                  last;
              }
          }
          $old_priority = $new_priority;
      }
      return $new_priority;
  }
  
  sub isGreaterOrEqual {
    my $lval = shift;
    my $rval = shift;
    
    # in theory, we should check if the above really ARE valid levels.
    # but we just use numeric comparison, since they aren't really classes.
  
    # oh, yeah, and 'cuz level ints go from 0 .. N with 0 being highest,
    # these are reversed.
    return $lval <= $rval;
  }
  
  ######################################################################
  # 
  # since the integer representation of levels is reversed from what
  # we normally want, we don't want to use < and >... instead, we
  # want to use this comparison function
  
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Level - Predefined log levels
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Level;
    print $ERROR, "\n";
  
    # -- or --
  
    use Log::Log4perl qw(:levels);
    print $ERROR, "\n";
  
  =head1 DESCRIPTION
  
  C<Log::Log4perl::Level> simply exports a predefined set of I<Log4perl> log
  levels into the caller's name space. It is used internally by 
  C<Log::Log4perl>. The following scalars are defined:
  
      $OFF
      $FATAL
      $ERROR
      $WARN
      $INFO
      $DEBUG
      $TRACE
      $ALL
  
  C<Log::Log4perl> also exports these constants into the caller's namespace
  if you pull it in providing the C<:levels> tag:
  
      use Log::Log4perl qw(:levels);
  
  This is the preferred way, there's usually no need to call 
  C<Log::Log4perl::Level> explicitly.
  
  The numerical values assigned to these constants are purely virtual,
  only used by Log::Log4perl internally and can change at any time,
  so please don't make any assumptions. You can test for numerical equality
  by directly comparing two level values, that's ok:
  
      if( get_logger()->level() == $DEBUG ) {
          print "The logger's level is DEBUG\n";
      }
  
  But if you want to figure out which of two levels is more verbose, use
  Log4perl's own comparator:
  
      if( Log::Log4perl::Level::isGreaterOrEqual( $level1, $level2 ) ) {
          print Log::Log4perl::Level::to_level( $level1 ), 
              " is equal or more verbose than ", 
              Log::Log4perl::Level::to_level( $level2 ), "\n";
      }
  
  If the caller wants to import level constants into a different namespace,
  it can be provided with the C<use> command:
  
      use Log::Log4perl::Level qw(MyNameSpace);
  
  After this C<$MyNameSpace::ERROR>, C<$MyNameSpace::INFO> etc. 
  will be defined accordingly.
  
  =head2 Numeric levels and Strings
  
  Level variables like $DEBUG or $WARN have numeric values that are 
  internal to Log4perl. Transform them to strings that can be used
  in a Log4perl configuration file, use the c<to_level()> function
  provided by Log::Log4perl::Level:
  
      use Log::Log4perl qw(:easy);
      use Log::Log4perl::Level;
  
          # prints "DEBUG"
      print Log::Log4perl::Level::to_level( $DEBUG ), "\n";
  
  To perform the reverse transformation, which takes a string like
  "DEBUG" and converts it into a constant like C<$DEBUG>, use the
  to_priority() function:
  
      use Log::Log4perl qw(:easy);
      use Log::Log4perl::Level;
  
      my $numval = Log::Log4perl::Level::to_priority( "DEBUG" );
  
  after which $numval could be used where a numerical value is required:
  
      Log::Log4perl->easy_init( $numval );
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LEVEL

$fatpacked{"Log/Log4perl/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_LOGGER';
  ##################################################
  package Log::Log4perl::Logger;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  use Log::Log4perl;
  use Log::Log4perl::Level;
  use Log::Log4perl::Layout;
  use Log::Log4perl::Appender;
  use Log::Log4perl::Appender::String;
  use Log::Log4perl::Filter;
  use Carp;
  
  $Carp::Internal{"Log::Log4perl"}++;
  $Carp::Internal{"Log::Log4perl::Logger"}++;
  
  use constant _INTERNAL_DEBUG => 0;
  
      # Initialization
  our $ROOT_LOGGER;
  our $LOGGERS_BY_NAME = {};
  our %APPENDER_BY_NAME = ();
  our $INITIALIZED = 0;
  our $NON_INIT_WARNED;
  our $DIE_DEBUG = 0;
  our $DIE_DEBUG_BUFFER = "";
      # Define the default appender that's used for formatting
      # warn/die/croak etc. messages.
  our $STRING_APP_NAME = "_l4p_warn";
  our $STRING_APP      = Log::Log4perl::Appender->new(
                            "Log::Log4perl::Appender::String",
                            name => $STRING_APP_NAME);
  $STRING_APP->layout(Log::Log4perl::Layout::PatternLayout->new("%m"));
  our $STRING_APP_CODEREF = generate_coderef([[$STRING_APP_NAME, $STRING_APP]]);
  
  __PACKAGE__->reset();
  
  ###########################################
  sub warning_render {
  ###########################################
      my($logger, @message) = @_;
  
      $STRING_APP->string("");
      $STRING_APP_CODEREF->($logger, 
                            @message, 
                            Log::Log4perl::Level::to_level($ALL));
      return $STRING_APP->string();
  }
  
  ##################################################
  sub cleanup {
  ##################################################
      # warn "Logger cleanup";
  
      # Nuke all convenience loggers to avoid them causing cleanup to 
      # be delayed until global destruction. Problem is that something like
      #     *{"DEBUG"} = sub { $logger->debug };
      # ties up a reference to $logger until global destruction, so we 
      # need to clean up all :easy shortcuts, hence freeing the last
      # logger references, to then rely on the garbage collector for cleaning
      # up the loggers.
      Log::Log4perl->easy_closure_global_cleanup();
  
      # Delete all loggers
      $LOGGERS_BY_NAME = {};
  
      # Delete the root logger
      undef $ROOT_LOGGER;
  
      # Delete all appenders
      %APPENDER_BY_NAME   = ();
  
      undef $INITIALIZED;
  }
  
  ##################################################
  sub DESTROY {
  ##################################################
      CORE::warn "Destroying logger $_[0] ($_[0]->{category})" 
              if $Log::Log4perl::CHATTY_DESTROY_METHODS;
  }
  
  ##################################################
  sub reset {
  ##################################################
      $ROOT_LOGGER        = __PACKAGE__->_new("", $OFF);
  #    $LOGGERS_BY_NAME    = {};  #leave this alone, it's used by 
                                  #reset_all_output_methods when 
                                  #the config changes
  
      %APPENDER_BY_NAME   = ();
      undef $INITIALIZED;
      undef $NON_INIT_WARNED;
      Log::Log4perl::Appender::reset();
  
      #clear out all the existing appenders
      foreach my $logger (values %$LOGGERS_BY_NAME){
          $logger->{appender_names} = [];
  
  	#this next bit deals with an init_and_watch case where a category
  	#is deleted from the config file, we need to zero out the existing
  	#loggers so ones not in the config file not continue with their old
  	#behavior --kg
          next if $logger eq $ROOT_LOGGER;
          $logger->{level} = undef;
          $logger->level();  #set it from the hierarchy
      }
  
      # Clear all filters
      Log::Log4perl::Filter::reset();
  }
  
  ##################################################
  sub _new {
  ##################################################
      my($class, $category, $level) = @_;
  
      print("_new: $class/$category/", defined $level ? $level : "undef",
            "\n") if _INTERNAL_DEBUG;
  
      die "usage: __PACKAGE__->_new(category)" unless
          defined $category;
      
      $category  =~ s/::/./g;
  
         # Have we created it previously?
      if(exists $LOGGERS_BY_NAME->{$category}) {
          print "_new: exists already\n" if _INTERNAL_DEBUG;
          return $LOGGERS_BY_NAME->{$category};
      }
  
      my $self  = {
          category  => $category,
          num_appenders => 0,
          additivity    => 1,
          level         => $level,
          layout        => undef,
                  };
  
     bless $self, $class;
  
     $level ||= $self->level();
  
          # Save it in global structure
     $LOGGERS_BY_NAME->{$category} = $self;
  
     $self->set_output_methods;
  
     print("Created logger $self ($category)\n") if _INTERNAL_DEBUG;
  
     return $self;
  }
  
  ##################################################
  sub category {
  ##################################################
     my ($self) = @_;
  
     return $self->{ category };
  }
  
  ##################################################
  sub reset_all_output_methods {
  ##################################################
      print "reset_all_output_methods: \n" if _INTERNAL_DEBUG;
  
      foreach my $loggername ( keys %$LOGGERS_BY_NAME){
          $LOGGERS_BY_NAME->{$loggername}->set_output_methods;
      }
      $ROOT_LOGGER->set_output_methods;
  }
  
  ##################################################
  sub set_output_methods {
  # Here's a big performance increase.  Instead of having the logger
  # calculate whether to log and whom to log to every time log() is called,
  # we calculate it once when the logger is created, and recalculate
  # it if the config information ever changes.
  #
  ##################################################
     my ($self) = @_;
      
     my (@appenders, %seen);
  
     my ($level) = $self->level();
  
     print "set_output_methods: $self->{category}/$level\n" if _INTERNAL_DEBUG;
  
     #collect the appenders in effect for this category    
  
     for(my $logger = $self; $logger; $logger = parent_logger($logger)) {
  
          foreach my $appender_name (@{$logger->{appender_names}}){
  
                  #only one message per appender, (configurable)
              next if $seen{$appender_name} ++ && 
                      $Log::Log4perl::one_message_per_appender;
  
              push (@appenders,     
                     [$appender_name,
                      $APPENDER_BY_NAME{$appender_name},
                     ]
              );
          }
          last unless $logger->{additivity};
      }
  
          #make a no-op coderef for inactive levels
      my $noop = generate_noop_coderef();
  
         #make a coderef
      my $coderef = (! @appenders ? $noop : &generate_coderef(\@appenders)); 
  
      my %priority = %Log::Log4perl::Level::PRIORITY; #convenience and cvs
  
     # changed to >= from <= as level ints were reversed
      foreach my $levelname (keys %priority){
          if (Log::Log4perl::Level::isGreaterOrEqual($level,
  						   $priority{$levelname}
  						   )) {
              print "  ($priority{$levelname} <= $level)\n"
                    if _INTERNAL_DEBUG;
              $self->{$levelname}      = $coderef;
              $self->{"is_$levelname"} = generate_is_xxx_coderef("1");
              print "Setting is_$levelname to 1\n" if _INTERNAL_DEBUG;
          }else{
              print "  ($priority{$levelname} > $level)\n" if _INTERNAL_DEBUG;
              $self->{$levelname}      = $noop;
              $self->{"is_$levelname"} = generate_is_xxx_coderef("0");
              print "Setting is_$levelname to 0\n" if _INTERNAL_DEBUG;
          }
  
          print("  Setting [$self] $self->{category}.$levelname to ",
                ($self->{$levelname} == $noop ? "NOOP" : 
                ("Coderef [$coderef]: " . scalar @appenders . " appenders")), 
                "\n") if _INTERNAL_DEBUG;
      }
  }
  
  ##################################################
  sub generate_coderef {
  ##################################################
      my $appenders = shift;
                      
      print "generate_coderef: ", scalar @$appenders, 
            " appenders\n" if _INTERNAL_DEBUG;
  
      my $watch_check_code = generate_watch_code("logger", 1);
  
      return sub {
        my $logger = shift;
        my $level  = pop;
  
        my $message;
        my $appenders_fired = 0;
        
        # Evaluate all parameters that need to be evaluated. Two kinds:
        #
        # (1) It's a hash like { filter => "filtername",
        #                        value  => "value" }
        #     => filtername(value)
        #
        # (2) It's a code ref
        #     => coderef()
        #
  
        $message   = [map { ref $_ eq "HASH" && 
                             exists $_->{filter} && 
                             ref $_->{filter} eq 'CODE' ?
                                 $_->{filter}->($_->{value}) :
                             ref $_ eq "CODE" ?
                                 $_->() : $_ 
                            } @_];                  
  
        print("coderef: $logger->{category}\n") if _INTERNAL_DEBUG;
  
        if(defined $Log::Log4perl::Config::WATCHER) {
            return unless $watch_check_code->($logger, @_, $level);
        }
  
        foreach my $a (@$appenders) {   #note the closure here
            my ($appender_name, $appender) = @$a;
  
            print("  Sending message '<$message->[0]>' ($level) " .
                  "to $appender_name\n") if _INTERNAL_DEBUG;
                  
            $appender->log(
                #these get passed through to Log::Dispatch
                { name    => $appender_name,
                  level   => $Log::Log4perl::Level::L4P_TO_LD{
                                 $level},   
                  message => $message,
                },
                #these we need
                $logger->{category},
                $level,
            ) and $appenders_fired++;
                # Only counting it if it returns a true value. Otherwise
                # the appender threshold might have suppressed it after all.
      
        } #end foreach appenders
      
        return $appenders_fired;
  
      }; #end coderef
  }
  
  ##################################################
  sub generate_noop_coderef {
  ##################################################
      my $watch_delay_code;
  
      # This might seem crazy at first, but even in a Log4perl noop, we
      # need to check if the configuration changed in a init_and_watch 
      # situation. Why? Say, an application is running in a loop that
      # constantly tries to issue debug() messages, but they're suppressed by
      # the current Log4perl configuration. If debug() (which is a noop
      # here) wasn't watching the configuration for changes, it would never
      # catch the case where someone bumps up the log level and expects
      # the application to pick it up and start logging debug() statements.
  
      my $watch_check_code = generate_watch_code("logger", 1);
  
      my $coderef;
  
      if(defined $Log::Log4perl::Config::WATCHER) {
          $coderef = $watch_check_code;
      } else {
          $coderef = sub { undef };
      }
  
      return $coderef;
  }
  
  ##################################################
  sub generate_is_xxx_coderef {
  ##################################################
      my($return_token) = @_;
  
      return generate_watch_code("checker", $return_token);
  }
  
  ##################################################
  sub generate_watch_code {
  ##################################################
      my($type, $return_token) = @_;
  
      print "generate_watch_code:\n" if _INTERNAL_DEBUG;
  
        # No watcher configured, return a no-op as watch code.
      if(! defined $Log::Log4perl::Config::WATCHER) {
          return sub { $return_token };
      }
  
      my $cond = generate_watch_conditional();
  
      return sub {
          print "exe_watch_code:\n" if _INTERNAL_DEBUG;
  
         if(_INTERNAL_DEBUG) {
             print "Next check: ",
               "$Log::Log4perl::Config::Watch::NEXT_CHECK_TIME ",
               " Now: ", time(), " Mod: ",
               (stat($Log::Log4perl::Config::WATCHER->file()))[9],
               "\n";
         }
  
         if( $cond->() ) {
             my $init_permitted = 1;
  
             if(exists $Log::Log4perl::Config::OPTS->{ preinit_callback } ) {
                 print "Calling preinit_callback\n" if _INTERNAL_DEBUG;
                 $init_permitted = 
                 $Log::Log4perl::Config::OPTS->{ preinit_callback }->( 
                     Log::Log4perl::Config->watcher()->file() );
                 print "Callback returned $init_permitted\n" if _INTERNAL_DEBUG;
             }
  
             if( $init_permitted ) {
                 Log::Log4perl->init_and_watch();
             } else {
                 # It was time to reinit, but init wasn't permitted.
                 # Return true, so that the logger continues as if
                 # it wasn't time to reinit.
                 return 1;
             }
  
             my $logger = shift;
             my $level  = pop;
  
             # Forward call to new configuration
             if($type eq "checker") {
                 return $logger->$level();
  
             } elsif( $type eq "logger") {
                 my $methodname = lc($level);
  
                 # Bump up the caller level by three, since
                 # we've artificially introduced additional levels.
                 local $Log::Log4perl::caller_depth =
                       $Log::Log4perl::caller_depth + 3;
  
                 # Get a new logger for the same category (the old
                 # logger might be obsolete because of the re-init)
                 $logger = Log::Log4perl::get_logger( $logger->{category} );
  
                 $logger->$methodname(@_); # send the message
                 # to the new configuration
                 return undef;     # Return false, so the logger finishes
                 # prematurely and doesn't log the same 
                 # message again.
             } else {
                 die "internal error: unknown type";
             }
         } else {
             if(_INTERNAL_DEBUG) {
                 print "Conditional returned false\n";
             }
             return $return_token;
         }
     };
  }
  
  ##################################################
  sub generate_watch_conditional {
  ##################################################
  
      if(defined $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT) {
          # In this mode, we just check for the variable indicating
          # that the signal has been caught
          return sub {
              return $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT;
          };
      }
  
      return sub {
          return 
              ( time() > $Log::Log4perl::Config::Watch::NEXT_CHECK_TIME and 
                $Log::Log4perl::Config::WATCHER->change_detected() );
      };
  }
  
  ##################################################
  sub parent_string {
  ##################################################
      my($string) = @_;
  
      if($string eq "") {
          return undef; # root doesn't have a parent.
      }
  
      my @components = split /\./, $string;
      
      if(@components == 1) {
          return "";
      }
  
      pop @components;
  
      return join('.', @components);
  }
  
  ##################################################
  sub level {
  ##################################################
      my($self, $level, $dont_reset_all) = @_;
  
          # 'Set' function
      if(defined $level) {
          croak "invalid level '$level'" 
                  unless Log::Log4perl::Level::is_valid($level);
          if ($level =~ /\D/){
              $level = Log::Log4perl::Level::to_priority($level);
          }
          $self->{level} = $level;   
  
          &reset_all_output_methods
              unless $dont_reset_all;  #keep us from getting overworked 
                                       #if it's the config file calling us 
  
          return $level;
      }
  
          # 'Get' function
      if(defined $self->{level}) {
          return $self->{level};
      }
  
      for(my $logger = $self; $logger; $logger = parent_logger($logger)) {
  
          # Does the current logger have the level defined?
  
          if($logger->{category} eq "") {
              # It's the root logger
              return $ROOT_LOGGER->{level};
          }
              
          if(defined $LOGGERS_BY_NAME->{$logger->{category}}->{level}) {
              return $LOGGERS_BY_NAME->{$logger->{category}}->{level};
          }
      }
  
      # We should never get here because at least the root logger should
      # have a level defined
      die "We should never get here.";
  }
  
  ##################################################
  sub parent_logger {
  # Get the parent of the current logger or undef
  ##################################################
      my($logger) = @_;
  
          # Is it the root logger?
      if($logger->{category} eq "") {
          # Root has no parent
          return undef;
      }
  
          # Go to the next defined (!) parent
      my $parent_class = parent_string($logger->{category});
  
      while($parent_class ne "" and
            ! exists $LOGGERS_BY_NAME->{$parent_class}) {
          $parent_class = parent_string($parent_class);
          $logger =  $LOGGERS_BY_NAME->{$parent_class};
      }
  
      if($parent_class eq "") {
          $logger = $ROOT_LOGGER;
      } else {
          $logger = $LOGGERS_BY_NAME->{$parent_class};
      }
  
      return $logger;
  }
  
  ##################################################
  sub get_root_logger {
  ##################################################
      my($class) = @_;
      return $ROOT_LOGGER;    
  }
  
  ##################################################
  sub additivity {
  ##################################################
      my($self, $onoff, $no_reinit) = @_;
  
      if(defined $onoff) {
          $self->{additivity} = $onoff;
      }
  
      if( ! $no_reinit ) {
          $self->set_output_methods();
      }
  
      return $self->{additivity};
  }
  
  ##################################################
  sub get_logger {
  ##################################################
      my($class, $category) = @_;
  
      unless(defined $ROOT_LOGGER) {
          Carp::confess "Internal error: Root Logger not initialized.";
      }
  
      return $ROOT_LOGGER if $category eq "";
  
      my $logger = $class->_new($category);
      return $logger;
  }
  
  ##################################################
  sub add_appender {
  ##################################################
      my($self, $appender, $dont_reset_all) = @_;
  
          # We take this as an indicator that we're initialized.
      $INITIALIZED = 1;
  
      my $appender_name = $appender->name();
  
      $self->{num_appenders}++;  #should this be inside the unless?
  
        # Add newly created appender to the end of the appender array
      unless (grep{$_ eq $appender_name} @{$self->{appender_names}}){
          $self->{appender_names} = [sort @{$self->{appender_names}}, 
                                          $appender_name];
      }
  
      $APPENDER_BY_NAME{$appender_name} = $appender;
  
      reset_all_output_methods
                  unless $dont_reset_all;  # keep us from getting overworked
                                           # if it's  the config file calling us
  
          # For chaining calls ...
      return $appender;
  }
  
  ##################################################
  sub remove_appender {
  ##################################################
      my($self, $appender_name, $dont_reset_all, $sloppy) = @_;
  
      my %appender_names = map { $_ => 1 } @{$self->{appender_names}};
      
      if(!exists $appender_names{$appender_name}) {
          die "No such appender: $appender_name" unless $sloppy;
          return undef;
      }
  
      delete $appender_names{$appender_name};
      $self->{num_appenders}--;
      $self->{appender_names} = [sort keys %appender_names];
  
      &reset_all_output_methods
                  unless $dont_reset_all; 
  }
  
  ##################################################
  sub eradicate_appender {
  ##################################################
          # If someone calls Logger->... and not Logger::...
      shift if $_[0] eq __PACKAGE__;
  
      my($appender_name, $dont_reset_all) = @_;
  
      return 0 unless exists 
          $APPENDER_BY_NAME{$appender_name};
  
          # Remove the given appender from all loggers
          # and delete all references to it, causing
          # its DESTROY method to be called.
      foreach my $logger (values %$LOGGERS_BY_NAME){
          $logger->remove_appender($appender_name, 0, 1);
      }
          # Also remove it from the root logger
      $ROOT_LOGGER->remove_appender($appender_name, 0, 1);
      
      delete $APPENDER_BY_NAME{$appender_name};
  
      &reset_all_output_methods
                  unless $dont_reset_all; 
  
      return 1;
  }
  
  ##################################################
  sub has_appenders {
  ##################################################
      my($self) = @_;
  
      return $self->{num_appenders};
  }
  
  ##################################################
  sub log {
  # external api
  ##################################################
      my ($self, $priority, @messages) = @_;
  
      confess("log: No priority given!") unless defined($priority);
  
         # Just in case of 'init_and_watch' -- see Changes 0.21
      $_[0] = $LOGGERS_BY_NAME->{$_[0]->{category}} if 
          defined $Log::Log4perl::Config::WATCHER;
  
      init_warn() unless $INITIALIZED or $NON_INIT_WARNED;
  
      croak "priority $priority isn't numeric" if ($priority =~ /\D/);
  
      my $which = Log::Log4perl::Level::to_level($priority);
  
      $self->{$which}->($self, @messages, 
                      Log::Log4perl::Level::to_level($priority));
  }
  
  ######################################################################
  #
  # create_custom_level 
  # creates a custom level
  # in theory, could be used to create the default ones
  ######################################################################
  sub create_custom_level {
  ######################################################################
    my $level = shift || die("create_custom_level: " .
                             "forgot to pass in a level string!");
    my $after = shift || die("create_custom_level: " .
                             "forgot to pass in a level after which to " .
                             "place the new level!");
    my $syslog_equiv = shift; # can be undef
    my $log_dispatch_level = shift; # optional
  
    ## only let users create custom levels before initialization
  
    die("create_custom_level must be called before init or " .
        "first get_logger() call") if ($INITIALIZED);
  
    my %PRIORITY = %Log::Log4perl::Level::PRIORITY; #convenience
  
    die("create_custom_level: no such level \"$after\"! Use one of: ", 
       join(", ", sort keys %PRIORITY)) unless $PRIORITY{$after};
  
    # figure out new int value by AFTER + (AFTER+ 1) / 2
  
    my $next_prio = Log::Log4perl::Level::get_lower_level($PRIORITY{$after}, 1);
    my $cust_prio = int(($PRIORITY{$after} + $next_prio) / 2);
  
    die(qq{create_custom_level: Calculated level of $cust_prio already exists!
        This should only happen if you've made some insane number of custom
        levels (like 15 one after another)
        You can usually fix this by re-arranging your code from:
        create_custom_level("cust1", X);
        create_custom_level("cust2", X);
        create_custom_level("cust3", X);
        create_custom_level("cust4", X);
        create_custom_level("cust5", X);
        into:
        create_custom_level("cust3", X);
        create_custom_level("cust5", X);
        create_custom_level("cust4", 4);
        create_custom_level("cust2", cust3);
        create_custom_level("cust1", cust2);
     }) if (${Log::Log4perl::Level::LEVELS{$cust_prio}});
  
    Log::Log4perl::Level::add_priority($level, $cust_prio, $syslog_equiv,
                                       $log_dispatch_level);
  
    print("Adding prio $level at $cust_prio\n") if _INTERNAL_DEBUG;
  
    # get $LEVEL into namespace of Log::Log4perl::Logger to 
    # create $logger->foo nd $logger->is_foo
    my $name = "Log::Log4perl::Logger::";
    my $key = $level;
  
    no strict qw(refs);
    # be sure to use ${Log...} as CVS adds log entries for Log
    *{"$name$key"} = \${Log::Log4perl::Level::PRIORITY{$level}};
  
    # now, stick it in the caller's namespace
    $name = caller(0) . "::";
    *{"$name$key"} = \${Log::Log4perl::Level::PRIORITY{$level}};
    use strict qw(refs);
  
    create_log_level_methods($level);
  
    return 0;
  
  }
  
  ########################################
  #
  # if we were hackin' lisp (or scheme), we'd be returning some lambda
  # expressions. But we aren't. :) So we'll just create some strings and
  # eval them.
  ########################################
  sub create_log_level_methods {
  ########################################
    my $level = shift || die("create_log_level_methods: " .
                             "forgot to pass in a level string!");
    my $lclevel = lc($level);
    my $levelint = uc($level) . "_INT";
    my $initial_cap = ucfirst($lclevel);
  
    no strict qw(refs);
  
    # This is a bit better way to create code on the fly than eval'ing strings.
    # -erik
  
    *{__PACKAGE__ . "::$lclevel"} = sub {
          if(_INTERNAL_DEBUG) {
              my $level_disp = (defined $_[0]->{level} ? $_[0]->{level} 
                                                       : "[undef]");
              print "$lclevel: ($_[0]->{category}/$level_disp) [@_]\n";
          }
          init_warn() unless $INITIALIZED or $NON_INIT_WARNED;
          $_[0]->{$level}->(@_, $level) if defined $_[0]->{$level};
       };
  
    # Added these to have is_xxx functions as fast as xxx functions
    # -ms
    
    my $islevel   = "is_" . $level;
    my $islclevel = "is_" . $lclevel;
  
    *{__PACKAGE__ . "::is_$lclevel"} = sub {
        $_[0]->{$islevel}->($_[0], $islclevel);
    };
    
    # Add the isXxxEnabled() methods as identical to the is_xxx
    # functions. - dviner
    
    *{__PACKAGE__ . "::is".$initial_cap."Enabled"} = 
                             \&{__PACKAGE__ . "::is_$lclevel"};
    
    use strict qw(refs);
  
    return 0;
  }
  
  #now lets autogenerate the logger subs based on the defined priorities
  foreach my $level (keys %Log::Log4perl::Level::PRIORITY){
    create_log_level_methods($level);
  }
  
  ##################################################
  sub init_warn {
  ##################################################
      CORE::warn "Log4perl: Seems like no initialization happened. " .
                 "Forgot to call init()?\n";
      # Only tell this once;
      $NON_INIT_WARNED = 1;
  }
  
  #######################################################
  # call me from a sub-func to spew the sub-func's caller
  #######################################################
  sub callerline {
    my $message = join ('', @_);
  
    my $caller_offset = 
      Log::Log4perl::caller_depth_offset( 
          $Log::Log4perl::caller_depth + 1 );
  
    my ($pack, $file, $line) = caller($caller_offset);
  
    if (not chomp $message) {     # no newline
      $message .= " at $file line $line";
  
      # Someday, we'll use Threads. Really.
      if (defined &Thread::tid) {
        my $tid = Thread->self->tid;
        $message .= " thread $tid" if $tid;
      }
    }
  
    return ($message, "\n");
  }
  
  #######################################################
  sub and_warn {
  #######################################################
    my $self = shift;
    CORE::warn(callerline($self->warning_render(@_)));
  }
  
  #######################################################
  sub and_die {
  #######################################################
    my $self = shift;
    my $arg  = $_[0];
  
    my($msg) = callerline($self->warning_render(@_));
  
    if($DIE_DEBUG) {
        $DIE_DEBUG_BUFFER = "DIE_DEBUG: $msg";
    } else {
        if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
            die("$msg\n");
        }
        die $arg;
    }
  }
  
  ##################################################
  sub logwarn {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_warn()) {
          # Since we're one caller level off now, compensate for that.
      my @chomped = @_;
      chomp($chomped[-1]);
      $self->warn(@chomped);
    }
  
    $self->and_warn(@_);
  }
  
  ##################################################
  sub logdie {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_fatal()) {
          # Since we're one caller level off now, compensate for that.
      my @chomped = @_;
      chomp($chomped[-1]);
      $self->fatal(@chomped);
    }
  
    $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
        $self->and_die(@_) : 
          exit($Log::Log4perl::LOGEXIT_CODE);
  }
  
  ##################################################
  sub logexit {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_fatal()) {
          # Since we're one caller level off now, compensate for that.
      my @chomped = @_;
      chomp($chomped[-1]);
      $self->fatal(@chomped);
    }
  
    exit $Log::Log4perl::LOGEXIT_CODE;
  }
  
  ##################################################
  # clucks and carps are WARN level
  sub logcluck {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    local $Carp::CarpLevel = 
          $Carp::CarpLevel + 1;
  
    my $msg = $self->warning_render(@_);
  
    if ($self->is_warn()) {
      my $message = Carp::longmess($msg);
      foreach (split(/\n/, $message)) {
        $self->warn("$_\n");
      }
    }
  
    Carp::cluck($msg);
  }
  
  ##################################################
  sub logcarp {
  ##################################################
    my $self = shift;
  
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    my $msg = $self->warning_render(@_);
  
    if ($self->is_warn()) {
      my $message = Carp::shortmess($msg);
      foreach (split(/\n/, $message)) {
        $self->warn("$_\n");
      }
    }
  
    Carp::carp($msg);
  }
  
  ##################################################
  # croaks and confess are FATAL level
  ##################################################
  sub logcroak {
  ##################################################
    my $self = shift;
    my $arg  = $_[0];
  
    my $msg = $self->warning_render(@_);
  
    local $Carp::CarpLevel = 
          $Carp::CarpLevel + 1;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_fatal()) {
      my $message = Carp::shortmess($msg);
      foreach (split(/\n/, $message)) {
        $self->fatal("$_\n");
      }
    }
  
    my $croak_msg = $arg;
  
    if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
        $croak_msg = $msg;
    }
  
    $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
        Carp::croak($croak_msg) : 
          exit($Log::Log4perl::LOGEXIT_CODE);
  }
  
  ##################################################
  sub logconfess {
  ##################################################
    my $self = shift;
    my $arg  = $_[0];
  
    local $Carp::CarpLevel = 
          $Carp::CarpLevel + 1;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    my $msg = $self->warning_render(@_);
  
    if ($self->is_fatal()) {
      my $message = Carp::longmess($msg);
      foreach (split(/\n/, $message)) {
        $self->fatal("$_\n");
      }
    }
  
    my $confess_msg = $arg;
  
    if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
        $confess_msg = $msg;
    }
  
    $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
        confess($confess_msg) :
          exit($Log::Log4perl::LOGEXIT_CODE);
  }
  
  ##################################################
  # in case people prefer to use error for warning
  ##################################################
  sub error_warn {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    if ($self->is_error()) {
      $self->error(@_);
    }
  
    $self->and_warn(@_);
  }
  
  ##################################################
  sub error_die {
  ##################################################
    my $self = shift;
  
    local $Log::Log4perl::caller_depth = 
          $Log::Log4perl::caller_depth + 1;
  
    my $msg = $self->warning_render(@_);
  
    if ($self->is_error()) {
      $self->error($msg);
    }
  
    $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
        $self->and_die($msg) :
          exit($Log::Log4perl::LOGEXIT_CODE);
  }
  
  ##################################################
  sub more_logging {
  ##################################################
    my ($self) = shift;
    return $self->dec_level(@_);
  }
  
  ##################################################
  sub inc_level {
  ##################################################
      my ($self, $delta) = @_;
  
      $delta ||= 1;
  
      $self->level(Log::Log4perl::Level::get_higher_level($self->level(), 
                                                          $delta));
  
      $self->set_output_methods;
  }
  
  ##################################################
  sub less_logging {
  ##################################################
    my ($self) = shift;
    return $self->inc_level(@_);
  }
  
  ##################################################
  sub dec_level {
  ##################################################
      my ($self, $delta) = @_;
  
      $delta ||= 1;
  
      $self->level(Log::Log4perl::Level::get_lower_level($self->level(), $delta));
  
      $self->set_output_methods;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Logger - Main Logger Class
  
  =head1 SYNOPSIS
  
      # It's not here
  
  =head1 DESCRIPTION
  
  While everything that makes Log4perl tick is implemented here,
  please refer to L<Log::Log4perl> for documentation.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_LOGGER

$fatpacked{"Log/Log4perl/MDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_MDC';
  ##################################################
  package Log::Log4perl::MDC;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  our %MDC_HASH = ();
  
  ###########################################
  sub get {
  ###########################################
      my($class, $key) = @_;
  
      if($class ne __PACKAGE__) {
          # Somebody called us with Log::Log4perl::MDC::get($key)
          $key = $class;
      }
  
      if(exists $MDC_HASH{$key}) {
          return $MDC_HASH{$key};
      } else {
          return undef;
      }
  }
  
  ###########################################
  sub put {
  ###########################################
      my($class, $key, $value) = @_;
  
      if($class ne __PACKAGE__) {
          # Somebody called us with Log::Log4perl::MDC::put($key, $value)
          $value = $key;
          $key   = $class;
      }
  
      $MDC_HASH{$key} = $value;
  }
  
  ###########################################
  sub remove {
  ###########################################
      %MDC_HASH = ();
  
      1;
  }
  
  ###########################################
  sub get_context {
  ###########################################
      return \%MDC_HASH;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::MDC - Mapped Diagnostic Context
  
  =head1 DESCRIPTION
  
  Log::Log4perl allows loggers to maintain global thread-specific data, 
  called the Nested Diagnostic Context (NDC) and 
  Mapped Diagnostic Context (MDC).
  
  The MDC is a simple thread-specific hash table, in which the application
  can stuff values under certain keys and retrieve them later
  via the C<"%X{key}"> placeholder in 
  C<Log::Log4perl::Layout::PatternLayout>s.
  
  =over 4
  
  =item Log::Log4perl::MDC->put($key, $value);
  
  Store a value C<$value> under key C<$key> in the map.
  
  =item my $value = Log::Log4perl::MDC->get($key);
  
  Retrieve the content of the map under the specified key.
  Typically done by C<%X{key}> in
  C<Log::Log4perl::Layout::PatternLayout>.
  If no value exists to the given key, C<undef> is returned.
  
  =item my $text = Log::Log4perl::MDC->remove();
  
  Delete all entries from the map.
  
  =item Log::Log4perl::MDC->get_context();
  
  Returns a reference to the hash table.
  
  =back
  
  Please note that all of the methods above are class methods, there's no
  instances of this class. Since the thread model in perl 5.8.0 is
  "no shared data unless explicitly requested" the data structures
  used are just global (and therefore thread-specific).
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_MDC

$fatpacked{"Log/Log4perl/NDC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_NDC';
  ##################################################
  package Log::Log4perl::NDC;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  
  our @NDC_STACK = ();
  our $MAX_SIZE  = 5;
  
  ###########################################
  sub get {
  ###########################################
      if(@NDC_STACK) {
          # Return elements blank separated
          return join " ", @NDC_STACK;
      } else {
          return "[undef]";
      }
  }
  
  ###########################################
  sub pop {
  ###########################################
      if(@NDC_STACK) {
          return pop @NDC_STACK;
      } else {
          return undef;
      }
  }
  
  ###########################################
  sub push {
  ###########################################
      my($self, $text) = @_;
  
      unless(defined $text) {
          # Somebody called us via Log::Log4perl::NDC::push("blah") ?
          $text = $self;
      }
  
      if(@NDC_STACK >= $MAX_SIZE) {
          CORE::pop(@NDC_STACK);
      }
  
      return push @NDC_STACK, $text;
  }
  
  ###########################################
  sub remove {
  ###########################################
      @NDC_STACK = ();
  }
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::NDC - Nested Diagnostic Context
  
  =head1 DESCRIPTION
  
  Log::Log4perl allows loggers to maintain global thread-specific data, 
  called the Nested Diagnostic Context (NDC).
  
  At some point, the application might decide to push a piece of
  data onto the NDC stack, which other parts of the application might 
  want to reuse. For example, at the beginning of a web request in a server,
  the application might decide to push the IP address of the client
  onto the stack to provide it for other loggers down the road without
  having to pass the data from function to function.
  
  The Log::Log4perl::Layout::PatternLayout class even provides the handy
  C<%x> placeholder which is replaced by the blank-separated list
  of elements currently on the stack.
  
  This module maintains a simple stack which you can push data on to, query
  what's on top, pop it off again or delete the entire stack.
  
  Its purpose is to provide a thread-specific context which all 
  Log::Log4perl loggers can refer to without the application having to
  pass around the context data between its functions.
  
  Since in 5.8.0 perl's threads don't share data only upon request,
  global data is by definition thread-specific.
  
  =over 4
  
  =item Log::Log4perl::NDC->push($text);
  
  Push an item onto the stack. If the stack grows beyond the defined
  limit (C<$Log::Log4perl::NDC::MAX_SIZE>), just the topmost element
  will be replated.
  
  This is typically done when a context is entered.
  
  =item Log::Log4perl::NDC->pop();
  
  Discard the upmost element of the stack. This is typically done when
  a context is left.
  
  =item my $text = Log::Log4perl::NDC->get();
  
  Retrieve the content of the stack as a string of blank-separated values
  without disrupting the stack structure. Typically done by C<%x>.
  If the stack is empty the value C<"[undef]"> is being returned.
  
  =item Log::Log4perl::NDC->remove();
  
  Reset the stack, remove all items.
  
  =back
  
  Please note that all of the methods above are class methods, there's no
  instances of this class.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_NDC

$fatpacked{"Log/Log4perl/Resurrector.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_RESURRECTOR';
  package Log::Log4perl::Resurrector;
  use warnings;
  use strict;
  
  # [rt.cpan.org #84818]
  use if $^O eq "MSWin32", "Win32"; 
  
  use File::Temp qw(tempfile);
  use File::Spec;
  
  use constant INTERNAL_DEBUG => 0;
  
  our $resurrecting = '';
  
  ###########################################
  sub import {
  ###########################################
      resurrector_init();
  }
  
  ##################################################
  sub resurrector_fh {
  ##################################################
      my($file) = @_;
  
      local($/) = undef;
      open FILE, "<$file" or die "Cannot open $file";
      my $text = <FILE>;
      close FILE;
  
      print "Read ", length($text), " bytes from $file\n" if INTERNAL_DEBUG;
  
      my($tmp_fh, $tmpfile) = tempfile( UNLINK => 1 );
      print "Opened tmpfile $tmpfile\n" if INTERNAL_DEBUG;
  
      $text =~ s/^\s*###l4p//mg;
  
      print "Text=[$text]\n" if INTERNAL_DEBUG;
  
      print $tmp_fh $text;
      seek $tmp_fh, 0, 0;
  
      return $tmp_fh;
  }
  
  ###########################################
  sub resurrector_loader {
  ###########################################
      my ($code, $module) = @_;
  
      print "resurrector_loader called with $module\n" if INTERNAL_DEBUG;
  
        # Avoid recursion
      if($resurrecting eq $module) {
          print "ignoring $module (recursion)\n" if INTERNAL_DEBUG;
          return undef;
      }
      
      local $resurrecting = $module;
      
      
        # Skip Log4perl appenders
      if($module =~ m#^Log/Log4perl/Appender#) {
          print "Ignoring $module (Log4perl-internal)\n" if INTERNAL_DEBUG;
          return undef;
      }
  
      my $path = $module;
  
        # Skip unknown files
      if(!-f $module) {
            # We might have a 'use lib' statement that modified the
            # INC path, search again.
          $path = pm_search($module);
          if(! defined $path) {
              print "File $module not found\n" if INTERNAL_DEBUG;
              return undef;
          }
          print "File $module found in $path\n" if INTERNAL_DEBUG;
      }
  
      print "Resurrecting module $path\n" if INTERNAL_DEBUG;
  
      my $fh = resurrector_fh($path);
  
      my $abs_path = File::Spec->rel2abs( $path );
      print "Setting %INC entry of $module to $abs_path\n" if INTERNAL_DEBUG;
      $INC{$module} = $abs_path;
  
      return $fh;
  }
  
  ###########################################
  sub pm_search {
  ###########################################
      my($pmfile) = @_;
  
      for(@INC) {
            # Skip subrefs
          next if ref($_);
          my $path = File::Spec->catfile($_, $pmfile);
          return $path if -f $path;
      }
  
      return undef;
  }
  
  ###########################################
  sub resurrector_init {
  ###########################################
      unshift @INC, \&resurrector_loader;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Resurrector - Dark Magic to resurrect hidden L4p statements
  
  =head1 DESCRIPTION
  
  Loading C<use Log::Log4perl::Resurrector> causes subsequently loaded
  modules to have their hidden
  
      ###l4p use Log::Log4perl qw(:easy);
  
      ###l4p DEBUG(...)
      ###l4p INFO(...)
      ...
  
  statements uncommented and therefore 'resurrected', i.e. activated.
  
  This allows for a module C<Foobar.pm> to be written with Log4perl
  statements commented out and running at full speed in normal mode.
  When loaded via
  
      use Foobar;
  
  all hidden Log4perl statements will be ignored.
  
  However, if a script loads the module C<Foobar> I<after> loading 
  C<Log::Log4perl::Resurrector>, as in
  
      use Log::Log4perl::Resurrector;
      use Foobar;
  
  then C<Log::Log4perl::Resurrector> will have put a source filter in place
  that will extract all hidden Log4perl statements in C<Foobar> before 
  C<Foobar> actually gets loaded. 
  
  Therefore, C<Foobar> will then behave as if the
  
      ###l4p use Log::Log4perl qw(:easy);
  
      ###l4p DEBUG(...)
      ###l4p INFO(...)
      ...
  
  statements were actually written like
  
      use Log::Log4perl qw(:easy);
  
      DEBUG(...)
      INFO(...)
      ...
  
  and the module C<Foobar> will indeed be Log4perl-enabled. Whether any
  activated Log4perl statement will actually trigger log
  messages, is up to the Log4perl configuration, of course.
  
  There's a startup cost to using C<Log::Log4perl::Resurrector> (all
  subsequently loaded modules are examined) but once the compilation
  phase has finished, the perl program will run at full speed.
  
  Some of the techniques used in this module have been stolen from the
  C<Acme::Incorporated> CPAN module, written by I<chromatic>. Long
  live CPAN!
   
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_RESURRECTOR

$fatpacked{"Log/Log4perl/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL';
  package Log::Log4perl::Util;
  
  require Exporter;
  our @EXPORT_OK = qw( params_check );
  our @ISA       = qw( Exporter );
  
  use File::Spec;
  
  ###########################################
  sub params_check {
  ###########################################
      my( $hash, $required, $optional ) = @_;
  
      my $pkg       = caller();
      my %hash_copy = %$hash;
  
      if( defined $required ) {
          for my $p ( @$required ) {
              if( !exists $hash->{ $p } or
                  !defined $hash->{ $p } ) {
                  die "$pkg: Required parameter $p missing.";
              }
              delete $hash_copy{ $p };
          }
      }
  
      if( defined $optional ) {
          for my $p ( @$optional ) {
              delete $hash_copy{ $p };
          }
          if( scalar keys %hash_copy ) {
              die "$pkg: Unknown parameter: ", join( ",", keys %hash_copy );
          }
      }
  }
  
  ##################################################
  sub module_available {  # Check if a module is available
  ##################################################
      my($full_name) = @_;
  
        # Weird cases like "strict;" (including the semicolon) would 
        # succeed with the eval below, so check those up front. 
        # I can't believe Perl doesn't have a proper way to check if a 
        # module is available or not!
      return 0 if $full_name =~ /[^\w:]/;
  
      local $SIG{__DIE__} = sub {};
  
      eval "require $full_name";
  
      if($@) {
          return 0;
      }
  
      return 1;
  }
  
  ##################################################
  sub tmpfile_name {  # File::Temp without the bells and whistles
  ##################################################
  
      my $name = File::Spec->catfile(File::Spec->tmpdir(), 
                                'l4p-tmpfile-' . 
                                "$$-" .
                                int(rand(9999999)));
  
          # Some crazy versions of File::Spec use backslashes on Win32
      $name =~ s#\\#/#g;
      return $name;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Util - Internal utility functions
  
  =head1 DESCRIPTION
  
  Only internal functions here. Don't peek.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_UTIL

$fatpacked{"Log/Log4perl/Util/Semaphore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL_SEMAPHORE';
  #//////////////////////////////////////////
  package Log::Log4perl::Util::Semaphore;
  #//////////////////////////////////////////
  use IPC::SysV qw(IPC_RMID IPC_CREAT IPC_EXCL SEM_UNDO IPC_NOWAIT 
                   IPC_SET IPC_STAT SETVAL);
  use IPC::Semaphore;
  use POSIX qw(EEXIST);
  use strict;
  use warnings;
  use constant INTERNAL_DEBUG => 0;
  
  ###########################################
  sub new {
  ###########################################
      my($class, %options) = @_;
  
      my $self = {
          key           => undef,
          mode          => undef,
          uid           => undef,
          gid           => undef,
          destroy       => undef,
          semop_wait    => .1,
          semop_retries => 1,
  	creator       => $$,
          %options,
      };
  
      $self->{ikey} = unpack("i", pack("A4", $self->{key}));
  
        # Accept usernames in the uid field as well
      if(defined $self->{uid} and 
         $self->{uid} =~ /\D/) {
          $self->{uid} = (getpwnam $self->{uid})[2];
      }
  
      bless $self, $class;
      $self->init();
  
      my @values = ();
      for my $param (qw(mode uid gid)) {
          push @values, $param, $self->{$param} if defined $self->{$param};
      }
      $self->semset(@values) if @values;
  
      return $self;
  }
  
  ###########################################
  sub init {
  ###########################################
      my($self) = @_;
  
      print "Semaphore init '$self->{key}'/'$self->{ikey}'\n" if INTERNAL_DEBUG;
  
      $self->{id} = semget( $self->{ikey}, 
                            1, 
                            &IPC_EXCL|&IPC_CREAT|($self->{mode}||0777),
                    );
     
     if(! defined $self->{id} and
        $! == EEXIST) {
         print "Semaphore '$self->{key}' already exists\n" if INTERNAL_DEBUG;
         $self->{id} = semget( $self->{ikey}, 1, 0 )
             or die "semget($self->{ikey}) failed: $!";
     } elsif($!) {
         die "Cannot create semaphore $self->{key}/$self->{ikey} ($!)";
     }
  }
  
  ###########################################
  sub status_as_string {
  ###########################################
      my($self, @values) = @_;
  
      my $sem = IPC::Semaphore->new($self->{ikey}, 1, 0);
  
      my $values  = join('/', $sem->getall());
      my $ncnt    = $sem->getncnt(0);
      my $pidlast = $sem->getpid(0);
      my $zcnt    = $sem->getzcnt(0);
      my $id      = $sem->id();
  
      return <<EOT;
  Semaphore Status
  Key ...................................... $self->{key}
  iKey ..................................... $self->{ikey}
  Id ....................................... $id
  Values ................................... $values
  Processes waiting for counter increase ... $ncnt
  Processes waiting for counter to hit 0 ... $zcnt
  Last process to perform an operation ..... $pidlast
  EOT
  }
  
  ###########################################
  sub semsetval {
  ###########################################
      my($self, %keyvalues) = @_;
  
      my $sem = IPC::Semaphore->new($self->{ikey}, 1, 0);
      $sem->setval(%keyvalues);
  }
  
  ###########################################
  sub semset {
  ###########################################
      my($self, @values) = @_;
  
      print "Setting values for semaphore $self->{key}/$self->{ikey}\n" if
          INTERNAL_DEBUG;
  
      my $sem = IPC::Semaphore->new($self->{ikey}, 1, 0);
      $sem->set(@values);
  }
  
  ###########################################
  sub semlock {
  ###########################################
      my($self) = @_;
  
      my $operation = pack("s!*", 
                            # wait until it's 0
                           0, 0, 0,
                            # increment by 1
                           0, 1, SEM_UNDO
                          );
  
      print "Locking semaphore '$self->{key}'\n" if INTERNAL_DEBUG;
      $self->semop($self->{id}, $operation);
  }
  
  ###########################################
  sub semunlock {
  ###########################################
      my($self) = @_;
  
  #    my $operation = pack("s!*", 
  #                          # decrement by 1
  #                         0, -1, SEM_UNDO
  #                        );
  #
      print "Unlocking semaphore '$self->{key}'\n" if INTERNAL_DEBUG;
  
  #      # ignore errors, as they might result from trying to unlock an
  #      # already unlocked semaphore.
  #    semop($self->{id}, $operation);
  
      semctl $self->{id}, 0, SETVAL, 0;
  }
  
  ###########################################
  sub remove {
  ###########################################
      my($self) = @_;
  
      print "Removing semaphore '$self->{key}'\n" if INTERNAL_DEBUG;
  
      semctl ($self->{id}, 0, &IPC_RMID, 0) or 
          die "Removing semaphore $self->{key} failed: $!";
  }
  
  ###########################################
  sub DESTROY {
  ###########################################
      my($self) = @_;
  
      if($self->{destroy} && $$==$self->{creator}) {
          $self->remove();
      }
  }
  
  ###########################################
  sub semop {
  ###########################################
      my($self, @args) = @_;
  
      my $retries     = $self->{semop_retries};
  
      my $rc;
  
      {
          $rc = semop($args[0], $args[1]);
  
          if(!$rc and 
             $! =~ /temporarily unavailable/ and
             $retries-- > 0) {
              $rc = 'undef' unless defined $rc;
              print "semop failed (rc=$rc), retrying\n", 
                    $self->status_as_string if INTERNAL_DEBUG;
              select undef, undef, undef, $self->{semop_wait};
              redo;
          }
      }
  
      $rc or die "semop(@args) failed: $! ";
      $rc;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Util::Semaphore - Easy to use semaphores
  
  =head1 SYNOPSIS
  
      use Log::Log4perl::Util::Semaphore;
      my $sem = Log::Log4perl::Util::Semaphore->new( key => "abc" );
  
      $sem->semlock();
        # ... critical section 
      $sem->semunlock();
  
      $sem->semset( uid  => (getpwnam("hugo"))[2], 
                    gid  => 102,
                    mode => 0644
                  );
  
  =head1 DESCRIPTION
  
  Log::Log4perl::Util::Semaphore provides the synchronisation mechanism
  for the Synchronized.pm appender in Log4perl, but can be used independently
  of Log4perl.
  
  As a convenience, the C<uid> field accepts user names as well, which it 
  translates into the corresponding uid by running C<getpwnam>.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_UTIL_SEMAPHORE

$fatpacked{"Log/Log4perl/Util/TimeTracker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_LOG4PERL_UTIL_TIMETRACKER';
  ##################################################
  package Log::Log4perl::Util::TimeTracker;
  ##################################################
  
  use 5.006;
  use strict;
  use warnings;
  use Log::Log4perl::Util;
  use Carp;
  
  our $TIME_HIRES_AVAILABLE;
  
  BEGIN {
      # Check if we've got Time::HiRes. If not, don't make a big fuss,
      # just set a flag so we know later on that we can't have fine-grained
      # time stamps
      $TIME_HIRES_AVAILABLE = 0;
      if(Log::Log4perl::Util::module_available("Time::HiRes")) {
          require Time::HiRes;
          $TIME_HIRES_AVAILABLE = 1;
      }
  }
  
  ##################################################
  sub new {
  ##################################################
      my $class = shift;
      $class = ref ($class) || $class;
  
      my $self = {
          reset_time            => undef,
          @_,
      };
  
      $self->{time_function} = \&_gettimeofday unless 
          defined $self->{time_function};
  
      bless $self, $class;
  
      $self->reset();
  
      return $self;
  }
  
  ##################################################
  sub hires_available {
  ##################################################
      return $TIME_HIRES_AVAILABLE;
  }
  
  ##################################################
  sub _gettimeofday {
  ##################################################
      # Return secs and optionally msecs if we have Time::HiRes
      if($TIME_HIRES_AVAILABLE) {
          return (Time::HiRes::gettimeofday());
      } else {
          return (time(), 0);
      }
  }
  
  ##################################################
  sub gettimeofday {
  ##################################################
      my($self) = @_;
  
      my($seconds, $microseconds) = $self->{time_function}->();
  
      $microseconds = 0 if ! defined $microseconds;
      return($seconds, $microseconds);
  }
  
  ##################################################
  sub reset {
  ##################################################
      my($self) = @_;
  
      my $current_time = [$self->gettimeofday()];
      $self->{reset_time} = $current_time;
      $self->{last_call_time} = $current_time;
  
      return $current_time;
  }
  
  ##################################################
  sub time_diff {
  ##################################################
      my($time_from, $time_to) = @_;
  
      my $seconds = $time_to->[0] -
                    $time_from->[0];
  
      my $milliseconds = int(( $time_to->[1] -
                               $time_from->[1] ) / 1000);
  
      if($milliseconds < 0) {
          $milliseconds = 1000 + $milliseconds;
          $seconds--;
      }
  
      return($seconds, $milliseconds);
  }
  
  ##################################################
  sub milliseconds {
  ##################################################
      my($self, $current_time) = @_;
  
      $current_time = [ $self->gettimeofday() ] unless
          defined $current_time;
  
      my($seconds, $milliseconds) = time_diff(
              $self->{reset_time}, 
              $current_time);
  
      return $seconds*1000 + $milliseconds;
  }
  
  ##################################################
  sub delta_milliseconds {
  ##################################################
      my($self, $current_time) = @_;
  
      $current_time = [ $self->gettimeofday() ] unless
          defined $current_time;
  
      my($seconds, $milliseconds) = time_diff(
              $self->{last_call_time}, 
              $current_time);
  
      $self->{last_call_time} = $current_time;
  
      return $seconds*1000 + $milliseconds;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Log::Log4perl::Util::TimeTracker - Track time elapsed
  
  =head1 SYNOPSIS
  
    use Log::Log4perl::Util::TimeTracker;
  
    my $timer = Log::Log4perl::Util::TimeTracker->new();
  
      # equivalent to Time::HiRes::gettimeofday(), regardless
      # if Time::HiRes is present or not. 
    my($seconds, $microseconds) = $timer->gettimeofday();
  
      # reset internal timer
    $timer->reset();
  
      # return milliseconds since last reset
    $msecs = $timer->milliseconds();
  
      # return milliseconds since last call
    $msecs = $timer->delta_milliseconds();
  
  =head1 DESCRIPTION
  
  This utility module helps tracking time elapsed for PatternLayout's
  date and time placeholders. Its accuracy depends on the availability
  of the Time::HiRes module. If it's available, its granularity is
  milliseconds, if not, seconds.
  
  The most common use of this module is calling the gettimeofday() 
  method:
  
    my($seconds, $microseconds) = $timer->gettimeofday();
  
  It returns seconds and microseconds of the current epoch time. If 
  Time::HiRes is installed, it will simply defer to its gettimeofday()
  function, if it's missing, time() will be called instead and $microseconds
  will always be 0.
  
  To measure time elapsed in milliseconds, use the reset() method to 
  reset the timer to the current time, followed by one or more calls to
  the milliseconds() method:
  
      # reset internal timer
    $timer->reset();
  
      # return milliseconds since last reset
    $msecs = $timer->milliseconds();
  
  On top of the time span between the last reset and the current time, 
  the module keeps track of the time between calls to delta_milliseconds():
  
    $msecs = $timer->delta_milliseconds();
  
  On the first call, this will return the number of milliseconds since the
  last reset(), on subsequent calls, it will return the time elapsed in
  milliseconds since the last call to delta_milliseconds() instead. Note
  that reset() also resets the time of the last call.
  
  The internal timer of this module gets its time input from the POSIX time() 
  function, or, if the Time::HiRes module is available, from its 
  gettimeofday() function. To figure out which one it is, use
  
      if( $timer->hires_available() ) {
          print "Hooray, we get real milliseconds!\n";
      } else {
          print "Milliseconds are just bogus\n";
      }
  
  For testing purposes, a different time source can be provided, so test
  suites can simulate time passing by without actually having to wait:
  
    my $start_time = time();
  
    my $timer = Log::Log4perl::Util::TimeTracker->new(
            time_function => sub {
                return $start_time++;
            },
    );
  
  Every call to $timer->epoch() will then return a time value that is one
  second ahead of the value returned on the previous call. This also means
  that every call to delta_milliseconds() will return a value that exceeds
  the value returned on the previous call by 1000.
  
  =head1 LICENSE
  
  Copyright 2002-2013 by Mike Schilli E<lt>m@perlmeister.comE<gt> 
  and Kevin Goess E<lt>cpan@goess.orgE<gt>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 AUTHOR
  
  Please contribute patches to the project on Github:
  
      http://github.com/mschilli/log4perl
  
  Send bug reports or requests for enhancements to the authors via our
  
  MAILING LIST (questions, bug reports, suggestions/patches): 
  log4perl-devel@lists.sourceforge.net
  
  Authors (please contact them via the list above, not directly):
  Mike Schilli <m@perlmeister.com>,
  Kevin Goess <cpan@goess.org>
  
  Contributors (in alphabetical order):
  Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton
  Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony
  Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy
  Grundman, Paul Harrington, Alexander Hartmaier  David Hull, 
  Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, 
  Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, 
  Lars Thegler, David Viner, Mac Yang.
  
LOG_LOG4PERL_UTIL_TIMETRACKER

$fatpacked{"MySQLinstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MYSQLINSTALL';
  #!/usr/bin/env perl
  package MySQLinstall;
  
  use 5.010001;
  use strict;
  use warnings;
  use File::Spec::Functions qw(:ALL);
  use Carp;
  use Getopt::Long;
  use Pod::Usage;
  use Capture::Tiny qw/capture/;
  use Data::Dumper;
  #use Regexp::Debugger;
  use Log::Log4perl;
  use File::Find::Rule;
  use IO::Prompter;
  use Config::Std { def_sep => '=' };   #MySQL uses =
  
  our $VERSION = "0.01";
  
  our @EXPORT_OK = qw{
    run
    init_logging
    get_parameters_from_cmd
  
  };
  
  #MODULINO - works with debugger too
  run() if !caller() or (caller)[0] eq 'DB';
  
  ### INTERFACE SUB starting all others ###
  # Usage      : main();
  # Purpose    : it starts all other subs and entire modulino
  # Returns    : nothing
  # Parameters : none (argument handling by Getopt::Long)
  # Throws     : lots of exceptions from logging
  # Comments   : start of entire module
  # See Also   : n/a
  sub run {
      croak 'main() does not need parameters' unless @_ == 0;
  
      #first capture parameters to enable VERBOSE flag for logging
      my ($param_href) = get_parameters_from_cmd();
  
      #preparation of parameters
      my $VERBOSE    = $param_href->{VERBOSE};
      my $QUIET      = $param_href->{QUIET};
      my @MODE     = @{ $param_href->{MODE} };
  	my $URL      = $param_href->{URL};
      my $URL_TOKUDB = $param_href->{URL_TOKUDB};
  	my $OPT      = $param_href->{OPT};
      my $SANDBOX = $param_href->{SANDBOX};
      my $INFILE   = $param_href->{INFILE};
      my $OUT      = $param_href->{OUT};   #not used
      my $HOST     = $param_href->{HOST};
      my $DATABASE = $param_href->{DATABASE};   #not used
      my $USER     = $param_href->{USER};
      my $PASSWORD = $param_href->{PASSWORD};
      my $PORT     = $param_href->{PORT};
      my $SOCKET   = $param_href->{SOCKET};
  
      #start logging for the rest of program (without capturing of parameters)
  	
      init_logging($VERBOSE);
      ##########################
      # ... in some function ...
      ##########################
      my $log = Log::Log4perl::get_logger("main");
  
      # Logs both to Screen and File appender
      $log->info("This is start of logging for $0");
      $log->trace("This is example of trace logging for $0");
  
      #get dump of param_href if -v (VERBOSE) flag is on (for debugging)
      my $dump_print = sprintf( Dumper($param_href) ) if $VERBOSE;
      $log->debug( '$param_href = ', "$dump_print" ) if $VERBOSE;
  
      #call write modes (different subs that print different jobs)
  	my %dispatch = (
          install_perl             => \&install_perl,                  #using perlenv
          install_sandbox          => \&install_sandbox,               #and create dirs
          wget_mysql               => \&wget_mysql,                    #from mysql
          wget_percona             => \&wget_percona_with_tokudb,      #from percona
          install_mysql            => \&install_mysql,                 #edit also general options in my.cnf for InnoDB
          edit_tokudb              => \&edit_tokudb,                   #not implemented
          edit_deep                => \&edit_deep,                     #edit my.cnf for Deep engine and install it
          edit_deep_report         => \&edit_deep_report,              #edit my.cnf for Deep engine and install it (with reporting to deep.is)
  
      );
  
      foreach my $mode (@MODE) {
          if ( exists $dispatch{$mode} ) {
              $log->info("RUNNING ACTION for mode: ", $mode);
  
              $dispatch{$mode}->( $param_href );
  
              $log->info("TIME when finished for: $mode");
          }
          else {
              #complain if mode misspelled or just plain wrong
              $log->logcroak( "Unrecognized mode --mode={$mode} on command line thus aborting");
          }
      }
  
      return;
  }
  
  ### INTERNAL UTILITY ###
  # Usage      : my ($param_href) = get_parameters_from_cmd();
  # Purpose    : processes parameters from command line
  # Returns    : $param_href --> hash ref of all command line arguments and files
  # Parameters : none -> works by argument handling by Getopt::Long
  # Throws     : lots of exceptions from die
  # Comments   : it starts logger at start
  # See Also   : init_logging()
  sub get_parameters_from_cmd {
  
      #no logger here
  	my @arg_copy = @ARGV;
      my ( $help, $man, $URL, $SANDBOX, $OPT, $INFILE, $OUT, $HOST, $DATABASE, $USER, $PASSWORD, $PORT, $SOCKET, @MODE );
      my $QUIET   = 0;    #by default it is verbose with INFO level
      my $VERBOSE = 0;    #default INFO log level
  
      GetOptions(
          'help|h'        => \$help,
          'man|m'         => \$man,
          'url=s'         => \$URL,
          'sandbox|sand=s'=> \$SANDBOX,
          'opt=s'         => \$OPT,
  
          'infile|if=s'   => \$INFILE,
          'out|o=s'       => \$OUT,
          'host|h=s'      => \$HOST,
          'database|d=s'  => \$DATABASE,
          'user|u=s'      => \$USER,
          'password|p=s'  => \$PASSWORD,
          'port|po=i'     => \$PORT,
          'socket|s=s'    => \$SOCKET,
          'mode|mo=s{1,}' => \@MODE,       #accepts 1 or more arguments
          'quiet|q'       => \$QUIET,      #flag
          'verbose+'      => \$VERBOSE,    #flag
      ) or pod2usage( -verbose => 1 );
  
      @MODE = split( /,/, join( ',', @MODE ) );
      die 'No @MODE specified on command line' unless @MODE;
  
      pod2usage( -verbose => 1 ) if $help;
      pod2usage( -verbose => 2 ) if $man;
  
  	#if not -q or --quit print all this (else be quiet)
  	if ($QUIET == 0) {
  		print STDERR 'My @ARGV: {', join( "} {", @arg_copy ), '}', "\n";
  	
  		if ($INFILE) {
  			say 'My input file: ', canonpath($INFILE);
  			$INFILE = rel2abs($INFILE);
  			say 'My absolute input file: ', canonpath($INFILE);
  		}
  		if ($OUT) {
  			say 'My output path: ', canonpath($OUT);
  			$OUT = rel2abs($OUT);
  			say 'My absolute output path: ', canonpath($OUT);
  		}
  	}
  	else {
  		$VERBOSE = -1;
  	}
  
      return (
          {   MODE     => \@MODE,
              VERBOSE  => $VERBOSE,
              QUIET    => $QUIET,
              INFILE   => $INFILE,
              URL      => $URL,
              SANDBOX  => $SANDBOX,
              OPT      => $OPT,
              OUT      => $OUT,
              HOST     => $HOST,
              DATABASE => $DATABASE,
              USER     => $USER,
              PASSWORD => $PASSWORD,
              PORT     => $PORT,
              SOCKET   => $SOCKET,
          }
      );
  }
  
  
  ### INTERNAL UTILITY ###
  # Usage      : init_logging();
  # Purpose    : enables Log::Log4perl log() to Screen and File
  # Returns    : nothing
  # Parameters : doesn't need parameters (logfile is in same directory and same name as script -pl +log
  # Throws     : croaks if it receives parameters
  # Comments   : used to setup a logging framework
  # See Also   : Log::Log4perl at https://metacpan.org/pod/Log::Log4perl
  sub init_logging {
      croak 'init_logging() needs VERBOSE parameter' unless @_ == 1;
      my ($VERBOSE) = @_;
  
      #create log file in same dir where script is running
  	#removes perl script and takes absolute path from rest of path
  	my ($volume,$dir_out,$perl_script) = splitpath( $0 );
  	#say '$dir_out:', $dir_out;
  	$dir_out = rel2abs($dir_out);
  	#say '$dir_out:', $dir_out;
  
      my ($app_name) = $perl_script =~ m{\A(.+)\.(?:.+)\z};   #takes name of the script and removes .pl or .pm or .t
      #say '$app_name:', $app_name;
      my $logfile = catfile( $volume, $dir_out, $app_name . '.log' );    #combines all of above with .log
  	#say '$logfile:', $logfile;
  	$logfile = canonpath($logfile);
  	#say '$logfile:', $logfile;
  
      #colored output on windows
      my $osname = $^O;
      if ( $osname eq 'MSWin32' ) {
          require Win32::Console::ANSI;                                 #require needs import
          Win32::Console::ANSI->import();
      }
  
      #enable different levels based on VERBOSE flag
      my $log_level;
      if    ($VERBOSE == 0)  { $log_level = 'INFO';  }
      elsif ($VERBOSE == 1)  { $log_level = 'DEBUG'; }
      elsif ($VERBOSE == 2)  { $log_level = 'TRACE'; }
      elsif ($VERBOSE == -1) { $log_level = 'OFF';   }
  	else                   { $log_level = 'INFO';  }
  
      #levels:
      #TRACE, DEBUG, INFO, WARN, ERROR, FATAL
      ###############################################################################
      #                              Log::Log4perl Conf                             #
      ###############################################################################
      # Configuration in a string ...
      my $conf = qq(
        log4perl.category.main              = $log_level, Logfile, Screen
       
        log4perl.appender.Logfile           = Log::Log4perl::Appender::File
        log4perl.appender.Logfile.Threshold = TRACE
        log4perl.appender.Logfile.filename  = $logfile
        log4perl.appender.Logfile.mode      = append
        log4perl.appender.Logfile.autoflush = 1
        log4perl.appender.Logfile.umask     = 0022
        log4perl.appender.Logfile.header_text = INVOCATION:$0 @ARGV
        log4perl.appender.Logfile.layout    = Log::Log4perl::Layout::PatternLayout
        log4perl.appender.Logfile.layout.ConversionPattern = [%d{yyyy/MM/dd HH:mm:ss,SSS}]%m%n
       
        log4perl.appender.Screen            = Log::Log4perl::Appender::ScreenColoredLevels
        log4perl.appender.Screen.stderr     = 1
        log4perl.appender.Screen.layout     = Log::Log4perl::Layout::PatternLayout
        log4perl.appender.Screen.layout.ConversionPattern  = [%d{yyyy/MM/dd HH:mm:ss,SSS}]%m%n
      );
  
      # ... passed as a reference to init()
      Log::Log4perl::init( \$conf );
  
      return;
  }
  
  
  sub init_logging2 {
      croak 'init_logging() needs VERBOSE parameter' unless @_ == 1;
      my ($VERBOSE) = @_;
  
      #create log file in same dir where script is running
  	#removes perl script and takes absolute path from rest of path
  	my ($volume,$dir_out,$perl_script) = splitpath( $0 );
  	#say '$dir_out:', $dir_out;
  	$dir_out = rel2abs($dir_out);
  	#say '$dir_out:', $dir_out;
  
      my ($app_name) = $perl_script =~ m{\A(.+)\.(?:.+)\z};   #takes name of the script and removes .pl or .pm or .t
      #say '$app_name:', $app_name;
      my $logfile = catfile( $volume, $dir_out, $app_name . '.log' );    #combines all of above with .log
  	#say '$logfile:', $logfile;
  	$logfile = canonpath($logfile);
  	#say '$logfile:', $logfile;
  
      #colored output on windows
      my $osname = $^O;
      if ( $osname eq 'MSWin32' ) {
          require Win32::Console::ANSI;                                 #require needs import
          Win32::Console::ANSI->import();
      }
  
      #enable different levels based on VERBOSE flag
      my $log_level;
      if    ($VERBOSE == 0)  { $log_level = 'INFO';  }
      elsif ($VERBOSE == 1)  { $log_level = 'DEBUG'; }
      elsif ($VERBOSE == 2)  { $log_level = 'TRACE'; }
      elsif ($VERBOSE == -1) { $log_level = 'OFF';   }
  	else                   { $log_level = 'INFO';  }
  
      #levels:
      #ALL, TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF
      ###############################################################################
      #                              Log::Log4perl Conf                             #
      ###############################################################################
      # Configuration is dynamic
  	# Define a category logger
  	my $log = Log::Log4perl->get_logger("main");
   
      # Define a layout
  	my $layout = Log::Log4perl::Layout::PatternLayout->new("[%d{yyyy/MM/dd HH:mm:ss,SSS}]%m%n");
   
     # Define a file appender
  	my $file_appender = Log::Log4perl::Appender->new(
                          "Log::Log4perl::Appender::File",
                          name      => "Logfile",
                          filename  => "$logfile",
  						autoflush => 1,
  						umask => 022,
  						header_text => "INVOCATION:$0 @ARGV", 
  						#Threshold => "TRACE",
  					);
   
     # Define a stderr appender
  	my $stderr_appender =  Log::Log4perl::Appender->new(
                          "Log::Log4perl::Appender::ScreenColoredLevels",
                          name      => "Screen",
                          stderr    => 1,
  					);
   
     # Have both appenders use the same layout (could be different)
  	$stderr_appender->layout($layout);
  	$file_appender->layout($layout);
  
   
  	$log->add_appender($stderr_appender);
  	$log->add_appender($file_appender);
  	$log->level($log_level);
  	$file_appender->threshold( "TRACE" );
  	#Log::Log4perl->appender_thresholds_adjust(-1, ['Logfile']);
  	#print Dumper( Log::Log4perl->appenders() );
  
  
      return;
  }
  
  ### INTERNAL UTILITY ###
  # Usage      : my ($stdout, $stderr, $exit) = capture_output( $cmd, $param_href );
  # Purpose    : accepts command, executes it, captures output and returns it in vars
  # Returns    : STDOUT, STDERR and EXIT as vars
  # Parameters : ($cmd_to_execute)
  # Throws     : 
  # Comments   : second param is verbose flag (default off)
  # See Also   :
  sub capture_output {
      my $log = Log::Log4perl::get_logger("main");
      $log->logdie( 'capture_output() needs a $cmd' ) unless (@_ ==  2 or 1);
      my ($cmd, $param_href) = @_;
  
      my $VERBOSE = defined $param_href->{VERBOSE}  ? $param_href->{VERBOSE}  : undef;   #default is silent
      $log->info(qq|Report: COMMAND is: $cmd|);
  
      my ( $stdout, $stderr, $exit ) = capture {
          system($cmd );
      };
  
      if ($VERBOSE == 2) {
          $log->trace( 'STDOUT is: ', "$stdout", "\n", 'STDERR  is: ', "$stderr", "\n", 'EXIT   is: ', "$exit" );
      }
  
      return  $stdout, $stderr, $exit;
  }
  
  
  ### INTERFACE SUB ###
  # Usage      : install_perl( $param_href );
  # Purpose    : install latest perl if not installed
  # Returns    : nothing
  # Parameters : ( $param_href ) params from command line
  # Throws     : croaks if wrong number of parameters
  # Comments   : first sub in chain, run only once at start
  # See Also   :
  sub install_perl {
      my $log = Log::Log4perl::get_logger("main");
      $log->logcroak ('install_perl() needs a $param_href' ) unless @_ == 1;
      my ( $param_href ) = @_;
  
      #check perl version
      my $cmd_perl_version = 'perl -v';
      my ($stdout, $stderr, $exit) = capture_output( $cmd_perl_version, $param_href );
      if ($exit == 0) {
          $log->info( 'Checking Perl version with perl -v' );
          if ( $stdout =~ m{v(\d+\.(\d+)\.\d+)}g ) {
              my $perl_ver = $1;
              my $ver_num = $2;
              $log->warn( "We have Perl $perl_ver and we need to update" );
  
              #start perlenv install
              $log->info( 'Checking if we can install plenv' );
              my $cmd_plenv = 'git clone git://github.com/tokuhirom/plenv.git ~/.plenv';
              my ($stdout_env, $stderr_env, $exit_env) = capture_output( $cmd_plenv, $param_href );
              my ($git_missing) = $stderr_env =~ m{(git)};
              my ($plenv_exist) = $stderr_env =~ m{(plenv)};
  
              if ($exit_env != 0 ) {
                  if ( $git_missing ) {
                      $log->warn( 'Need to install git' );
                      my $cmd_git = 'sudo yum -y install git';
                      my ($stdout_git, $stderr_git, $exit_git) = capture_output( $cmd_git, $param_href );
                      if ($exit_git == 0 ) {
                          $log->trace( 'git successfully installed' );
                      }
                      my $cmd_tools = q{sudo yum -y groupinstall "Development tools"};
                      system $cmd_tools;
                  }
                  elsif ( $plenv_exist ) {
                      $log->trace( "plenv already installed: $stderr_env" );
                  }
              }
              else {
                  $log->trace( 'Installed plenv' );
                  
                  #updating .bash_profile for plenv to work
                  my $cmd_path = q{echo 'export PATH="$HOME/.plenv/bin:$PATH"' >> ~/.bash_profile};
                  my $cmd_eval = q{echo 'eval "$(plenv init -)"' >> ~/.bash_profile};
                  my $cmd_exec = q{source $HOME/.bash_profile};
                  system ($cmd_path);
                  system ($cmd_eval);
                  system ($cmd_exec);
                  $log->trace( 'Updated $PATH variable and initiliazed plenv' );
                  
                  #installing Perl-Build plugin for install function in plenv
                  my $cmd_perl_build = q{git clone git://github.com/tokuhirom/Perl-Build.git ~/.plenv/plugins/perl-build/};
                  my ($stdout_bp, $stderr_bp, $exit_bp) = capture_output( $cmd_perl_build, $param_href );
                  if ($exit_bp == 0) {
                      $log->trace( 'Installed Perl-Build plugin for plenv from github' );
                  }
  
                  #list all perls available
                  my $cmd_list_perls = q{plenv install --list};
                  my ($stdout_list, $stderr_list, $exit_list) = capture_output( $cmd_list_perls, $param_href );
                  my @perls = split("\n", $stdout_list);
                  #say @perls;
                  
                  #ask to choose which Perl to install
                  my $perl_to_install
                    = prompt 'Choose which Perl version you want to install',
                    -number,
                    -menu => [ @perls ],
                    '>';
                  my @thread_options = qw/usethreads nothreads/;
                  my $thread_option
                    = prompt 'Do you want to install Perl with or without threads?',
                    -menu => [ @thread_options ],
                    '>';
                  $log->trace( "Will install $perl_to_install with $thread_option" );
  
                  #install Perl
                  my $cmd_install;
                  if ($thread_option eq 'nothreads') {
                      $cmd_install = qq{plenv install -j 8 -Dcc=gcc $perl_to_install};
                  }
                  else {
                      $cmd_install = qq{plenv install -j 8 -Dcc=gcc -D usethreads $perl_to_install};
                  }
                  my ($stdout_ins, $stderr_ins, $exit_ins) = capture_output( $cmd_install, $param_href );
                  if ($exit_ins == 0) {
                      $log->trace( "Perl $perl_to_install installed successfully!" );
                  }
  
                  #finish installation, set perl as global
                  my $cmd_rehash = q{plenv rehash};
                  my $cmd_global = qq{plenv global $perl_to_install};
                  my $cmd_cpanm = q{plenv install-cpanm};
                  #my $cmd_lib   = q{sudo cpanm --local-lib=~/perl5 local::lib && eval $(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)};
                  system ($cmd_rehash);
                  system ($cmd_global);
                  my ($stdout_cp, $stderr_cp, $exit_cp) = capture_output( $cmd_cpanm, $param_href );
                  if ($exit_cp == 0) {
                      $log->trace( "Perl $perl_to_install is now global and cpanm installed" );
                  }
  
                  #check if right Perl installed
                  my ($stdout_ver, $stderr_ver, $exit_ver) = capture_output( $cmd_perl_version, $param_href );
                  if ($exit_ver == 0) {
                      $log->info( 'Checking Perl version with perl -v' );
                      if ( $stdout_ver =~ m{v(\d+\.(\d+)\.\d+)}g ) {
                          my $perl_ver2 = $1;
                          $log->warn( "We have Perl $perl_ver2 " );
                      }
                  }
                  }
          }
      }
      else {
          $log->logcarp( 'Got lost checking Perl version' );
      }
  
      return;
  }
  
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  MySQLinstall - is installation script that installs Perl using plenv, MySQL::Sandbox using cpanm, MySQL in a sandbox, additional engines like TokuDB and Deep and updates configuration.
  
  =head1 SYNOPSIS
  
   MySQLinstall --mode=install_perl
  
   MySQLinstall --mode=install_sandbox --sandbox=/msestak/sandboxes/ --opt=/msestak/opt/mysql/
  
   MySQLinstall --mode=wget_mysql -url http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-5.5.43-linux2.6-x86_64.tar.gz
  
   MySQLinstall --mode=wget_percona -url https://www.percona.com/downloads/Percona-Server-5.6/Percona-Server-5.6.24-72.2/binary/tarball/Percona-Server-5.6.24-rel72.2-Linux.x86_64.ssl101.tar.gz -url_tokudb https://www.percona.com/downloads/Percona-Server-5.6/Percona-Server-5.6.24-72.2/binary/tarball/Percona-Server-5.6.24-rel72.2-TokuDB.Linux.x86_64.ssl101.tar.gz
  
   MySQLinstall --mode=install_mysql -i ./download/mysql-5.6.26-linux-glibc2.5-x86_64.tar.gz
   MySQLinstall --mode=install_mysql --in=./download/Percona-Server-5.6.25-rel73.1-Linux.x86_64.ssl101.tar.gz
  
   MySQLinstall --mode=edit_tokudb --opt=/home/msestak/opt/mysql/5.6.25/ --sand=/home/msestak/sandboxes/msb_5_6_25/
  
   MySQLinstall --mode=edit_deep -i deep-mysql-5.6.25-community-plugin-3.2.0.19654-1.el6.x86_64.rpm --sand=/msestak/sandboxes/msb_5_6_25/ --opt=/msestak/opt/mysql/5.6.25/
   or with reporting
   MySQLinstall --mode=edit_deep_report -i ./download/deep-mysql-5.6.26-community-plugin-3.2.0.19896.el6.x86_64.tar.gz --sand=/home/msestak/sandboxes/msb_5_6_26 --opt=/home/msestak/opt/mysql/5.6.26
  
  
  
  =head1 DESCRIPTION
  
   MySQLinstall is installation script that installs Perl using plenv, MySQL::Sandbox using cpanm, MySQL in a sandbox, additional engines like TokuDB and Deep and updates configuration. 
  
   --mode=mode				Description
   --mode=install_perl		installs latest Perl with perlenv and cpanm
   --mode=install_sandbox		installs MySQL::Sandbox and prompts for modification of .bashrc
   --mode=wget_mysql			downloads MySQL from Oracle
   --mode=wget_percona		downloads Percona Server with TokuDB
   --mode=install_mysql		installs MySQL and modifies my.cnf for performance
   --mode=edit_deep_report	installs TokuDB plugin
   --mode=edit_tokudb			installs Deep plugin
   
   For help write:
   MySQLinstall -h
   MySQLinstall -m
  
  
  =head1 LICENSE
  
  Copyright (C) Martin Sebastijan Šestak.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  mocnii E<lt>msestak@irb.hrE<gt>
  
  =head1 EXAMPLE
   MySQLinstall --mode=install_mysql --in=./download/Percona-Server-5.6.25-rel73.1-Linux.x86_64.ssl101.tar.gz
   MySQLinstall --mode=edit_tokudb --opt=/home/msestak/opt/mysql/5.6.25/ --sand=/home/msestak/sandboxes/msb_5_6_25/
   
   MySQLinstall --mode=install_mysql -i mysql-5.6.24-linux-glibc2.5-x86_64.tar.gz
   MySQLinstall --mode=edit_deep -i deep-mysql-5.6.24-community-plugin-3.2.0.19297-1.el6.x86_64.rpm --sand=/msestak/sandboxes/msb_5_6_24/ --opt=/msestak/opt/mysql/5.6.24/
  
   MySQLinstall --mode=install_mysql -i mysql-5.6.24-linux-glibc2.5-x86_64.tar.gz
   MySQLinstall --mode=edit_deep_report -i deep-mysql-5.6.24-community-plugin-3.2.0.19654.el6.x86_64.tar.gz --sand=/msestak/sandboxes/msb_5_6_24/ --opt=/msestak/opt/mysql/5.6.24/
  
   MySQLinstall --mode=install_mysql -i ./download/mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz
   MySQLinstall --mode=edit_deep_report -i ./download/deep-mysql-5.6.27-community-plugin-3.3.0.20340.el6.x86_64.tar.gz --sand=/home/msestak/sandboxes/msb_5_6_27/ --opt=/home/msestak/opt/mysql/5.6.27/
  
  =cut
  
MYSQLINSTALL

$fatpacked{"Number/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NUMBER_COMPARE';
  package Number::Compare;
  use strict;
  use Carp qw(croak);
  use vars qw/$VERSION/;
  $VERSION = '0.03';
  
  sub new  {
      my $referent = shift;
      my $class = ref $referent || $referent;
      my $expr = $class->parse_to_perl( shift );
  
      bless eval "sub { \$_[0] $expr }", $class;
  }
  
  sub parse_to_perl {
      shift;
      my $test = shift;
  
      $test =~ m{^
                 ([<>]=?)?   # comparison
                 (.*?)       # value
                 ([kmg]i?)?  # magnitude
                $}ix
         or croak "don't understand '$test' as a test";
  
      my $comparison = $1 || '==';
      my $target     = $2;
      my $magnitude  = $3 || '';
      $target *=           1000 if lc $magnitude eq 'k';
      $target *=           1024 if lc $magnitude eq 'ki';
      $target *=        1000000 if lc $magnitude eq 'm';
      $target *=      1024*1024 if lc $magnitude eq 'mi';
      $target *=     1000000000 if lc $magnitude eq 'g';
      $target *= 1024*1024*1024 if lc $magnitude eq 'gi';
  
      return "$comparison $target";
  }
  
  sub test { $_[0]->( $_[1] ) }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Number::Compare - numeric comparisons
  
  =head1 SYNOPSIS
  
   Number::Compare->new(">1Ki")->test(1025); # is 1025 > 1024
  
   my $c = Number::Compare->new(">1M");
   $c->(1_200_000);                          # slightly terser invocation
  
  =head1 DESCRIPTION
  
  Number::Compare compiles a simple comparison to an anonymous
  subroutine, which you can call with a value to be tested again.
  
  Now this would be very pointless, if Number::Compare didn't understand
  magnitudes.
  
  The target value may use magnitudes of kilobytes (C<k>, C<ki>),
  megabytes (C<m>, C<mi>), or gigabytes (C<g>, C<gi>).  Those suffixed
  with an C<i> use the appropriate 2**n version in accordance with the
  IEC standard: http://physics.nist.gov/cuu/Units/binary.html
  
  =head1 METHODS
  
  =head2 ->new( $test )
  
  Returns a new object that compares the specified test.
  
  =head2 ->test( $value )
  
  A longhanded version of $compare->( $value ).  Predates blessed
  subroutine reference implementation.
  
  =head2 ->parse_to_perl( $test )
  
  Returns a perl code fragment equivalent to the test.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002,2011 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  http://physics.nist.gov/cuu/Units/binary.html
  
  =cut
NUMBER_COMPARE

$fatpacked{"Text/Glob.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_GLOB';
  package Text::Glob;
  use strict;
  use Exporter;
  use vars qw/$VERSION @ISA @EXPORT_OK
              $strict_leading_dot $strict_wildcard_slash/;
  $VERSION = '0.09';
  @ISA = 'Exporter';
  @EXPORT_OK = qw( glob_to_regex glob_to_regex_string match_glob );
  
  $strict_leading_dot    = 1;
  $strict_wildcard_slash = 1;
  
  use constant debug => 0;
  
  sub glob_to_regex {
      my $glob = shift;
      my $regex = glob_to_regex_string($glob);
      return qr/^$regex$/;
  }
  
  sub glob_to_regex_string
  {
      my $glob = shift;
      my ($regex, $in_curlies, $escaping);
      local $_;
      my $first_byte = 1;
      for ($glob =~ m/(.)/gs) {
          if ($first_byte) {
              if ($strict_leading_dot) {
                  $regex .= '(?=[^\.])' unless $_ eq '.';
              }
              $first_byte = 0;
          }
          if ($_ eq '/') {
              $first_byte = 1;
          }
          if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
              $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
              $regex .= "\\$_";
          }
          elsif ($_ eq '*') {
              $regex .= $escaping ? "\\*" :
                $strict_wildcard_slash ? "[^/]*" : ".*";
          }
          elsif ($_ eq '?') {
              $regex .= $escaping ? "\\?" :
                $strict_wildcard_slash ? "[^/]" : ".";
          }
          elsif ($_ eq '{') {
              $regex .= $escaping ? "\\{" : "(";
              ++$in_curlies unless $escaping;
          }
          elsif ($_ eq '}' && $in_curlies) {
              $regex .= $escaping ? "}" : ")";
              --$in_curlies unless $escaping;
          }
          elsif ($_ eq ',' && $in_curlies) {
              $regex .= $escaping ? "," : "|";
          }
          elsif ($_ eq "\\") {
              if ($escaping) {
                  $regex .= "\\\\";
                  $escaping = 0;
              }
              else {
                  $escaping = 1;
              }
              next;
          }
          else {
              $regex .= $_;
              $escaping = 0;
          }
          $escaping = 0;
      }
      print "# $glob $regex\n" if debug;
  
      return $regex;
  }
  
  sub match_glob {
      print "# ", join(', ', map { "'$_'" } @_), "\n" if debug;
      my $glob = shift;
      my $regex = glob_to_regex $glob;
      local $_;
      grep { $_ =~ $regex } @_;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::Glob - match globbing patterns against text
  
  =head1 SYNOPSIS
  
   use Text::Glob qw( match_glob glob_to_regex );
  
   print "matched\n" if match_glob( "foo.*", "foo.bar" );
  
   # prints foo.bar and foo.baz
   my $regex = glob_to_regex( "foo.*" );
   for ( qw( foo.bar foo.baz foo bar ) ) {
       print "matched: $_\n" if /$regex/;
   }
  
  =head1 DESCRIPTION
  
  Text::Glob implements glob(3) style matching that can be used to match
  against text, rather than fetching names from a filesystem.  If you
  want to do full file globbing use the File::Glob module instead.
  
  =head2 Routines
  
  =over
  
  =item match_glob( $glob, @things_to_test )
  
  Returns the list of things which match the glob from the source list.
  
  =item glob_to_regex( $glob )
  
  Returns a compiled regex which is the equivalent of the globbing
  pattern.
  
  =item glob_to_regex_string( $glob )
  
  Returns a regex string which is the equivalent of the globbing
  pattern.
  
  =back
  
  =head1 SYNTAX
  
  The following metacharacters and rules are respected.
  
  =over
  
  =item C<*> - match zero or more characters
  
  C<a*> matches C<a>, C<aa>, C<aaaa> and many many more.
  
  =item C<?> - match exactly one character
  
  C<a?> matches C<aa>, but not C<a>, or C<aaa>
  
  =item Character sets/ranges
  
  C<example.[ch]> matches C<example.c> and C<example.h>
  
  C<demo.[a-c]> matches C<demo.a>, C<demo.b>, and C<demo.c>
  
  =item alternation
  
  C<example.{foo,bar,baz}> matches C<example.foo>, C<example.bar>, and
  C<example.baz>
  
  =item leading . must be explictly matched
  
  C<*.foo> does not match C<.bar.foo>.  For this you must either specify
  the leading . in the glob pattern (C<.*.foo>), or set
  C<$Text::Glob::strict_leading_dot> to a false value while compiling
  the regex.
  
  =item C<*> and C<?> do not match /
  
  C<*.foo> does not match C<bar/baz.foo>.  For this you must either
  explicitly match the / in the glob (C<*/*.foo>), or set
  C<$Text::Glob::strict_wildcard_slash> to a false value with compiling
  the regex.
  
  =back
  
  =head1 BUGS
  
  The code uses qr// to produce compiled regexes, therefore this module
  requires perl version 5.005_03 or newer.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2006, 2007 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Glob>, glob(3)
  
  =cut
TEXT_GLOB

$fatpacked{"x86_64-linux-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.42";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of ARRAY references, each containing two items from the given
  list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @KVLIST ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these ARRAY references are blessed objects, recognising
  the two methods C<key> and C<value>. The following code is equivalent:
  
      foreach my $pair ( pairs @KVLIST ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of ARRAY
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.42";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.42";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is actually
  implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its
  functions so that those without access to a C compiler may still use it.
  However some of the functions are only available when a C compiler was
  available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-thread-multi/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.42";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_SUB_UTIL

$fatpacked{"x86_64-linux-thread-multi/Want.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_WANT';
  package Want;
  
  require 5.006;
  use Carp 'croak';
  use strict;
  use warnings;
  
  require Exporter;
  require DynaLoader;
  
  our @ISA = qw(Exporter DynaLoader);
  
  our @EXPORT = qw(want rreturn lnoreturn);
  our @EXPORT_OK = qw(howmany wantref);
  our $VERSION = '0.25';
  
  bootstrap Want $VERSION;
  
  my %reftype = (
      ARRAY  => 1,
      HASH   => 1,
      CODE   => 1,
      GLOB   => 1,
      OBJECT => 1,
  );
  
  sub _wantone {
      my ($uplevel, $arg) = @_;
      
      my $wantref = wantref($uplevel + 1);
      if	  ($arg =~ /^\d+$/) {
  	my $want_count = want_count($uplevel);
  	return ($want_count == -1 || $want_count >= $arg);
      }
      elsif (lc($arg) eq 'infinity') {
  	return (want_count($uplevel) == -1);
      }
      elsif ($arg eq 'REF') {
  	return $wantref;
      }
      elsif ($reftype{$arg}) {
  	return ($wantref eq $arg);
      }
      elsif ($arg eq 'REFSCALAR') {
  	return ($wantref eq 'SCALAR');
      }
      elsif ($arg eq 'LVALUE') {
  	return want_lvalue($uplevel);
      }
      elsif ($arg eq 'RVALUE') {
  	return !want_lvalue($uplevel);
      }
      elsif ($arg eq 'VOID') {
  	return !defined(wantarray_up($uplevel));
      }
      elsif ($arg eq 'SCALAR') {
  	my $gimme = wantarray_up($uplevel);
  	return (defined($gimme) && 0 == $gimme);
      }
      elsif ($arg eq 'BOOL' || $arg eq 'BOOLEAN') {
  	return want_boolean(bump_level($uplevel));
      }
      elsif ($arg eq 'LIST') {
  	return wantarray_up($uplevel);
      }
      elsif ($arg eq 'COUNT') {
  	croak("want: COUNT must be the *only* parameter");
      }
      elsif ($arg eq 'ASSIGN') {
  	return !!wantassign($uplevel + 1);
      }
      else {
  	croak ("want: Unrecognised specifier $arg");
      }    
  }
  
  sub want {
      if (@_ == 1 && $_[0] eq 'ASSIGN') {
  	@_ = (1);
  	goto &wantassign;
      }
      want_uplevel(1, @_);
  }
  
  # Simulate the propagation of context through a return value.
  sub bump_level {
      my ($level) = @_;
      for(;;) {
  	my ($p, $r) = parent_op_name($level+1);
  	if ($p eq "return"
          or  $p eq "(none)" && $r =~ /^leavesub(lv)?$/)
  	{
  	    ++$level
  	}
  	else {
  	    return $level
  	}
      }
  }
  
  sub want_uplevel {
      my ($level, @args) = @_;
  
      # Deal with special cases (for RFC21-consistency):
      if (1 == @args) {
  	@_ = (1 + $level);
  	goto &wantref    if $args[0] eq 'REF';
  	goto &howmany    if $args[0] eq 'COUNT';
  	goto &wantassign if $args[0] eq 'ASSIGN';
      }
  
      for my $arg (map split, @args) {
  	if ($arg =~ /^!(.*)/) {
  	    return 0 unless !_wantone(2 + $level, $1);
  	}
  	else {
  	    return 0 unless _wantone(2 + $level, $arg);
  	}
      }
      
      return 1;
  }
  
  sub howmany () {
      my $level = bump_level(@_, 1);
      my $count = want_count($level);
      return ($count < 0 ? undef : $count);
  }
  
  sub wantref {
      my $level = bump_level(@_, 1);
      my $n = parent_op_name($level);
      if    ($n eq 'rv2av') {
  	return "ARRAY";
      }
      elsif ($n eq 'rv2hv') {
  	return "HASH";
      }
      elsif ($n eq 'rv2cv' || $n eq 'entersub') {
  	return "CODE";
      }
      elsif ($n eq 'rv2gv' || $n eq 'gelem') {
  	return "GLOB";
      }
      elsif ($n eq 'rv2sv') {
  	return "SCALAR";
      }
      elsif ($n eq 'method_call') {
  	return 'OBJECT';
      }
      elsif ($n eq 'multideref') {
  	return first_multideref_type($level);
      }
      else {
  	return "";
      }
  }
  
  sub wantassign {
      my $uplevel = shift();
      return unless want_lvalue($uplevel);
      my $r = want_assign(bump_level($uplevel));
      if (want('BOOL')) {
  	return (defined($r) && 0 != $r);
      }
      else {
  	return $r ? (want('SCALAR') ? $r->[$#$r] : @$r) : ();
      }
  }
  
  sub rreturn (@) {
      if (want_lvalue(1)) {
          croak "Can't rreturn in lvalue context";
      }
      double_return();
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      {
          return wantarray ? @_ : $_[$#_];
      }
  }
  
  sub lnoreturn () {
      if (!want_lvalue(1) || !want_assign(1)) {
          croak "Can't lnoreturn except in ASSIGN context";
      }
      double_return();
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      {
          return disarm_temp(my $undef);
      }
  }
  
  # Some naughty people were relying on these internal methods.
  *_wantref = \&wantref;
  *_wantassign = \&wantassign;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Want - A generalisation of C<wantarray>
  
  =head1 SYNOPSIS
  
    use Want;
    sub foo :lvalue {
        if    (want(qw'LVALUE ASSIGN')) {
          print "We have been assigned ", want('ASSIGN');
          lnoreturn;
        }
        elsif (want('LIST')) {
          rreturn (1, 2, 3);
        }
        elsif (want('BOOL')) {
          rreturn 0;
        }
        elsif (want(qw'SCALAR !REF')) {
          rreturn 23;
        }
        elsif (want('HASH')) {
          rreturn { foo => 17, bar => 23 };
        }
        return;  # You have to put this at the end to keep the compiler happy
    }
  
  =head1 DESCRIPTION
  
  This module generalises the mechanism of the B<wantarray> function,
  allowing a function to determine in some detail how its return value
  is going to be immediately used.
  
  =head2 Top-level contexts:
  
  The three kinds of top-level context are well known:
  
  =over 4
  
  =item B<VOID>
  
  The return value is not being used in any way. It could be an entire statement
  like C<foo();>, or the last component of a compound statement which is itself in
  void context, such as C<$test || foo();>n. Be warned that the last statement
  of a subroutine will be in whatever context the subroutine was called in, because
  the result is implicitly returned.
  
  =item B<SCALAR>
  
  The return value is being treated as a scalar value of some sort:
  
    my $x = foo();
    $y += foo();
    print "123" x foo();
    print scalar foo();
    warn foo()->{23};
    ...etc...
  
  =item B<LIST>
  
  The return value is treated as a list of values:
  
    my @x = foo();
    my ($x) = foo();
    () = foo();		# even though the results are discarded
    print foo();
    bar(foo());		# unless the bar subroutine has a prototype
    print @hash{foo()};	# (hash slice)
    ...etc...
  
  =back
  
  =head2 Lvalue subroutines:
  
  The introduction of B<lvalue subroutines> in Perl 5.6 has created a new type
  of contextual information, which is independent of those listed above. When
  an lvalue subroutine is called, it can either be called in the ordinary way
  (so that its result is treated as an ordinary value, an B<rvalue>); or else
  it can be called so that its result is considered updatable, an B<lvalue>.
  
  These rather arcane terms (lvalue and rvalue) are easier to remember if you
  know why they are so called. If you consider a simple assignment statement
  C<left = right>, then the B<l>eft-hand side is an B<l>value and the B<r>ight-hand
  side is an B<r>value.
  
  So (for lvalue subroutines only) there are two new types of context:
  
  =over 4
  
  =item B<RVALUE>
  
  The caller is definitely not trying to assign to the result:
  
    foo();
    my $x = foo();
    ...etc...
  
  If the sub is declared without the C<:lvalue> attribute, then it will
  I<always> be in RVALUE context.
  
  If you need to return values from an lvalue subroutine in RVALUE context,
  you should use the C<rreturn> function rather than an ordinary C<return>.
  Otherwise you'll probably get a compile-time error in perl 5.6.1 and later.
  
  =item B<LVALUE>
  
  Either the caller is directly assigning to the result of the sub call:
  
    foo() = $x;
    foo() = (1, 1, 2, 3, 5, 8);
  
  or the caller is making a reference to the result, which might be assigned to
  later:
  
    my $ref = \(foo());	# Could now have: $$ref = 99;
    
    # Note that this example imposes LIST context on the sub call.
    # So we're taking a reference to the first element to be
    # returned _in list context_.
    # If we want to call the function in scalar context, we can
    # do it like this:
    my $ref = \(scalar foo());
  
  or else the result of the function call is being used as part of the argument list
  for I<another> function call:
  
    bar(foo());	# Will *always* call foo in lvalue context,
    		# (provided that foo is an C<:lvalue> sub)
    		# regardless of what bar actually does.
  
  The reason for this last case is that bar might be a sub which modifies its
  arguments. They're rare in contemporary Perl code, but perfectly possible:
  
    sub bar {
      $_[0] = 23;
    }
  
  (This is really a throwback to Perl 4, which didn't support explicit references.)
  
  =back
  
  =head2 Assignment context:
  
  The commonest use of lvalue subroutines is with the assignment statement:
  
    size() = 12;
    (list()) = (1..10);
  
  A useful motto to remember when thinking about assignment statements is
  I<context comes from the left>. Consider code like this:
  
    my ($x, $y, $z);
    sub list () :lvalue { ($x, $y, $z) }
    list = (1, 2, 3);
    print "\$x = $x; \$y = $y; \$z = $z\n";
  
  This prints C<$x = ; $y = ; $z = 3>, which may not be what you were expecting.
  The reason is that the assignment is in scalar context, so the comma operator
  is in scalar context too, and discards all values but the last. You can fix
  it by writing C<(list) = (1,2,3);> instead.
  
  If your lvalue subroutine is used on the left of an assignment statement,
  it's in B<ASSIGN> context.  If ASSIGN is the only argument to C<want()>, then
  it returns a reference to an array of the value(s) of the right-hand side.
  
  In this case, you should return with the C<lnoreturn> function, rather than
  an ordinary C<return>. 
  
  This makes it very easy to write lvalue subroutines which do clever things:
  
    use Want;
    use strict;
    sub backstr :lvalue {
      if (want(qw'LVALUE ASSIGN')) {
        my ($a) = want('ASSIGN');
        $_[0] = reverse $a;
        lnoreturn;
      }
      elsif (want('RVALUE')) {
        rreturn scalar reverse $_[0];
      }
      else {
        carp("Not in ASSIGN context");
      }
      return
    }
   
    print "foo -> ", backstr("foo"), "\n";	# foo -> oof
    backstr(my $robin) = "nibor";
    print "\$robin is now $robin\n";		# $robin is now robin
  
  Notice that you need to put a (meaningless) return
  statement at the end of the function, otherwise you will get the
  error
  I<Can't modify non-lvalue subroutine call in lvalue subroutine return>.
  
  The only way to write that C<backstr> function without using Want is to return
  a tied variable which is tied to a custom class.
  
  =head2 Reference context:
  
  Sometimes in scalar context the caller is expecting a reference of some sort
  to be returned:
  
      print foo()->();     # CODE reference expected
      print foo()->{bar};  # HASH reference expected
      print foo()->[23];   # ARRAY reference expected
      print ${foo()};	 # SCALAR reference expected
      print foo()->bar();	 # OBJECT reference expected
      
      my $format = *{foo()}{FORMAT} # GLOB reference expected
  
  You can check this using conditionals like C<if (want('CODE'))>.
  There is also a function C<wantref()> which returns one of the strings
  "CODE", "HASH", "ARRAY", "GLOB", "SCALAR" or "OBJECT"; or the empty string
  if a reference is not expected.
  
  Because C<want('SCALAR')> is already used to select ordinary scalar context,
  you have to use C<want('REFSCALAR')> to find out if a SCALAR reference is
  expected. Or you could use C<want('REF') eq 'SCALAR'> of course.
  
  Be warned that C<want('ARRAY')> is a B<very> different thing from C<wantarray()>.
  
  =head2 Item count
  
  Sometimes in list context the caller is expecting a particular number of items
  to be returned:
  
      my ($x, $y) = foo();   # foo is expected to return two items
  
  If you pass a number to the C<want> function, then it will return true or false
  according to whether at least that many items are wanted. So if we are in the
  definition of a sub which is being called as above, then:
  
      want(1) returns true
      want(2) returns true
      want(3) returns false
  
  Sometimes there is no limit to the number of items that might be used:
  
      my @x = foo();
      do_something_with( foo() );
  
  In this case, C<want(2)>, C<want(100)>, C<want(1E9)> and so on will all return
  true; and so will C<want('Infinity')>.
  
  The C<howmany> function can be used to find out how many items are wanted.
  If the context is scalar, then C<want(1)> returns true and C<howmany()> returns
  1. If you want to check whether your result is being assigned to a singleton
  list, you can say C<if (want('LIST', 1)) { ... }>.
  
  
  =head2 Boolean context
  
  Sometimes the caller is only interested in the truth or falsity of a function's
  return value:
  
      if (everything_is_okay()) {
  	# Carry on
      }
      
      print (foo() ? "ok\n" : "not ok\n");
      
  In the following example, all subroutine calls are in BOOL context:
  
      my $x = ( (foo() && !bar()) xor (baz() || quux()) );
  
  Boolean context, like the reference contexts above, is considered to be a subcontext
  of SCALAR.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item want(SPECIFIERS)
  
  This is the primary interface to this module, and should suffice for most
  purposes. You pass it a list of context specifiers, and the return value
  is true whenever all of the specifiers hold.
  
      want('LVALUE', 'SCALAR');   # Are we in scalar lvalue context?
      want('RVALUE', 3);		# Are at least three rvalues wanted?
      want('ARRAY');	# Is the return value used as an array ref?
  
  You can also prefix a specifier with an exclamation mark to indicate that you
  B<don't> want it to be true
  
      want(2, '!3');		# Caller wants exactly two items.
      want(qw'REF !CODE !GLOB');  # Expecting a reference that
      				#   isn't a CODE or GLOB ref.
      want(100, '!Infinity');	# Expecting at least 100 items,
      				#   but there is a limit.
  
  If the I<REF> keyword is the only parameter passed, then the type of reference will be
  returned.  This is just a synonym for the C<wantref> function: it's included because
  you might find it useful if you don't want to pollute your namespace by importing
  several functions, and to conform to Damian Conway's suggestion in RFC 21.
  
  Finally, the keyword I<COUNT> can be used, provided that it's the only keyword
  you pass. Mixing COUNT with other keywords is an error. This is a synonym for the
  C<howmany> function.
  
  A full list of the permitted keyword is in the B<ARGUMENTS> section below.
  
  =item rreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you know that you're in RVALUE context. If you try to use a normal C<return>,
  you'll get a compile-time error in Perl 5.6.1 and above unless you return an
  lvalue. (Note: this is no longer true in Perl 5.16, where an ordinary return
  will once again work.)
  
  =item lnoreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you're in ASSIGN context and you've used C<want('ASSIGN')> to carry out the
  appropriate action.
  
  If you use C<rreturn> or C<lnoreturn>, then you have to put a bare C<return;>
  at the very end of your lvalue subroutine, in order to stop the Perl compiler
  from complaining. Think of it as akin to the C<1;> that you have to put at the
  end of a module. (Note: this is no longer true in Perl 5.16.)
  
  =item howmany()
  
  Returns the I<expectation count>, i.e. the number of items expected. If the 
  expectation count is undefined, that
  indicates that an unlimited number of items might be used (e.g. the return
  value is being assigned to an array). In void context the expectation count
  is zero, and in scalar context it is one.
  
  The same as C<want('COUNT')>.
  
  =item wantref()
  
  Returns the type of reference which the caller is expecting, or the empty string
  if the caller isn't expecting a reference immediately.
  
  The same as C<want('REF')>.
  
  =back
  
  =head1 EXAMPLES
  
      use Carp 'croak';
      use Want 'howmany';
      sub numbers {
  	my $count = howmany();
  	croak("Can't make an infinite list") if !defined($count);
  	return (1..$count);
      }
      my ($one, $two, $three) = numbers();
      
      
      use Want 'want';
      sub pi () {
  	if    (want('ARRAY')) {
  	    return [3, 1, 4, 1, 5, 9];
  	}
  	elsif (want('LIST')) {
  	    return (3, 1, 4, 1, 5, 9);
  	}
  	else {
  	    return 3;
  	}
      }
      print pi->[2];	# prints 4
      print ((pi)[3]);	# prints 1
  
  =head1 ARGUMENTS
  
  The permitted arguments to the C<want> function are listed below.
  The list is structured so that sub-contexts appear below the context that they
  are part of.
  
  =over 4
  
  =item *
  
  VOID
  
  =item *
  
  SCALAR
  
  =over 4
  
  =item *
  
  REF
  
  =over 4
  
  =item *
  
  REFSCALAR
  
  =item *
  
  CODE
  
  =item *
  
  HASH
  
  =item *
  
  ARRAY
  
  =item *
  
  GLOB
  
  =item *
  
  OBJECT
  
  =back
  
  =item *
  
  BOOL
  
  =back
  
  =item *
  
  LIST
  
  =over 4
  
  =item *
  
  COUNT
  
  =item *
  
  E<lt>numberE<gt>
  
  =item *
  
  Infinity
  
  =back
  
  =item *
  
  LVALUE
  
  =over 4
  
  =item *
  
  ASSIGN
  
  =back
  
  =item *
  
  RVALUE
  
  =back
  
  =head1 EXPORT
  
  The C<want> and C<rreturn> functions are exported by default.
  The C<wantref> and/or C<howmany> functions can also be imported:
  
    use Want qw'want howmany';
  
  If you don't import these functions, you must qualify their names as (e.g.)
  C<Want::wantref>.
  
  =head1 INTERFACE
  
  This module is still under development, and the public interface may change in
  future versions. The C<want> function can now be regarded as stable.
  
  I'd be interested to know how you're using this module.
  
  =head1 SUBTLETIES
  
  There are two different levels of B<BOOL> context. I<Pure> boolean context
  occurs in conditional expressions, and the operands of the C<xor> and C<!>/C<not>
  operators.
  Pure boolean context also propagates down through the C<&&> and C<||> operators.
  
  However, consider an expression like C<my $x = foo() && "yes">. The subroutine
  is called in I<pseudo>-boolean context - its return value isn't B<entirely>
  ignored, because the undefined value, the empty string and the integer 0 are
  all false.
  
  At the moment C<want('BOOL')> is true in either pure or pseudo boolean
  context. Let me know if this is a problem.
  
  =head1 BUGS
  
   * Doesn't work from inside a tie-handler.
  
  =head1 AUTHOR
  
  Robin Houston, E<lt>robin@cpan.orgE<gt>
  
  Thanks to Damian Conway for encouragement and good suggestions,
  and Father Chrysostomos for a patch.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<perlfunc/wantarray>
  
  =item *
  
  Perl6 RFC 21, by Damian Conway.
  http://dev.perl.org/rfc/21.html
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2012, Robin Houston. All Rights Reserved.
  This module is free software. It may be used, redistributed
  and/or modified under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_WANT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

package MySQLinstall;

use 5.010001;
use strict;
use warnings;
use File::Spec::Functions qw(:ALL);
use Carp;
use Getopt::Long;
use Pod::Usage;
use Capture::Tiny qw/capture/;
use Data::Dumper;
#use Regexp::Debugger;
use Log::Log4perl;
use File::Find::Rule;
use IO::Prompter;
use Config::Std { def_sep => '=' };   #MySQL uses =

our $VERSION = "0.01";

our @EXPORT_OK = qw{
  run
  init_logging
  get_parameters_from_cmd

};

#MODULINO - works with debugger too
run() if !caller() or (caller)[0] eq 'DB';

### INTERFACE SUB starting all others ###
# Usage      : main();
# Purpose    : it starts all other subs and entire modulino
# Returns    : nothing
# Parameters : none (argument handling by Getopt::Long)
# Throws     : lots of exceptions from logging
# Comments   : start of entire module
# See Also   : n/a
sub run {
    croak 'main() does not need parameters' unless @_ == 0;

    #first capture parameters to enable VERBOSE flag for logging
    my ($param_href) = get_parameters_from_cmd();

    #preparation of parameters
    my $VERBOSE    = $param_href->{VERBOSE};
    my $QUIET      = $param_href->{QUIET};
    my @MODE     = @{ $param_href->{MODE} };
	my $URL      = $param_href->{URL};
    my $URL_TOKUDB = $param_href->{URL_TOKUDB};
	my $OPT      = $param_href->{OPT};
    my $SANDBOX = $param_href->{SANDBOX};
    my $INFILE   = $param_href->{INFILE};
    my $OUT      = $param_href->{OUT};   #not used
    my $HOST     = $param_href->{HOST};
    my $DATABASE = $param_href->{DATABASE};   #not used
    my $USER     = $param_href->{USER};
    my $PASSWORD = $param_href->{PASSWORD};
    my $PORT     = $param_href->{PORT};
    my $SOCKET   = $param_href->{SOCKET};

    #start logging for the rest of program (without capturing of parameters)
	
    init_logging($VERBOSE);
    ##########################
    # ... in some function ...
    ##########################
    my $log = Log::Log4perl::get_logger("main");

    # Logs both to Screen and File appender
    $log->info("This is start of logging for $0");
    $log->trace("This is example of trace logging for $0");

    #get dump of param_href if -v (VERBOSE) flag is on (for debugging)
    my $dump_print = sprintf( Dumper($param_href) ) if $VERBOSE;
    $log->debug( '$param_href = ', "$dump_print" ) if $VERBOSE;

    #call write modes (different subs that print different jobs)
	my %dispatch = (
        install_perl             => \&install_perl,                  #using perlenv
        install_sandbox          => \&install_sandbox,               #and create dirs
        wget_mysql               => \&wget_mysql,                    #from mysql
        wget_percona             => \&wget_percona_with_tokudb,      #from percona
        install_mysql            => \&install_mysql,                 #edit also general options in my.cnf for InnoDB
        edit_tokudb              => \&edit_tokudb,                   #not implemented
        edit_deep                => \&edit_deep,                     #edit my.cnf for Deep engine and install it
        edit_deep_report         => \&edit_deep_report,              #edit my.cnf for Deep engine and install it (with reporting to deep.is)

    );

    foreach my $mode (@MODE) {
        if ( exists $dispatch{$mode} ) {
            $log->info("RUNNING ACTION for mode: ", $mode);

            $dispatch{$mode}->( $param_href );

            $log->info("TIME when finished for: $mode");
        }
        else {
            #complain if mode misspelled or just plain wrong
            $log->logcroak( "Unrecognized mode --mode={$mode} on command line thus aborting");
        }
    }

    return;
}

### INTERNAL UTILITY ###
# Usage      : my ($param_href) = get_parameters_from_cmd();
# Purpose    : processes parameters from command line
# Returns    : $param_href --> hash ref of all command line arguments and files
# Parameters : none -> works by argument handling by Getopt::Long
# Throws     : lots of exceptions from die
# Comments   : it starts logger at start
# See Also   : init_logging()
sub get_parameters_from_cmd {

    #no logger here
	my @arg_copy = @ARGV;
    my ( $help, $man, $URL, $SANDBOX, $OPT, $INFILE, $OUT, $HOST, $DATABASE, $USER, $PASSWORD, $PORT, $SOCKET, @MODE );
    my $QUIET   = 0;    #by default it is verbose with INFO level
    my $VERBOSE = 0;    #default INFO log level

    GetOptions(
        'help|h'        => \$help,
        'man|m'         => \$man,
        'url=s'         => \$URL,
        'sandbox|sand=s'=> \$SANDBOX,
        'opt=s'         => \$OPT,

        'infile|if=s'   => \$INFILE,
        'out|o=s'       => \$OUT,
        'host|h=s'      => \$HOST,
        'database|d=s'  => \$DATABASE,
        'user|u=s'      => \$USER,
        'password|p=s'  => \$PASSWORD,
        'port|po=i'     => \$PORT,
        'socket|s=s'    => \$SOCKET,
        'mode|mo=s{1,}' => \@MODE,       #accepts 1 or more arguments
        'quiet|q'       => \$QUIET,      #flag
        'verbose+'      => \$VERBOSE,    #flag
    ) or pod2usage( -verbose => 1 );

    @MODE = split( /,/, join( ',', @MODE ) );
    die 'No @MODE specified on command line' unless @MODE;

    pod2usage( -verbose => 1 ) if $help;
    pod2usage( -verbose => 2 ) if $man;

	#if not -q or --quit print all this (else be quiet)
	if ($QUIET == 0) {
		print STDERR 'My @ARGV: {', join( "} {", @arg_copy ), '}', "\n";
	
		if ($INFILE) {
			say 'My input file: ', canonpath($INFILE);
			$INFILE = rel2abs($INFILE);
			say 'My absolute input file: ', canonpath($INFILE);
		}
		if ($OUT) {
			say 'My output path: ', canonpath($OUT);
			$OUT = rel2abs($OUT);
			say 'My absolute output path: ', canonpath($OUT);
		}
	}
	else {
		$VERBOSE = -1;
	}

    return (
        {   MODE     => \@MODE,
            VERBOSE  => $VERBOSE,
            QUIET    => $QUIET,
            INFILE   => $INFILE,
            URL      => $URL,
            SANDBOX  => $SANDBOX,
            OPT      => $OPT,
            OUT      => $OUT,
            HOST     => $HOST,
            DATABASE => $DATABASE,
            USER     => $USER,
            PASSWORD => $PASSWORD,
            PORT     => $PORT,
            SOCKET   => $SOCKET,
        }
    );
}


### INTERNAL UTILITY ###
# Usage      : init_logging();
# Purpose    : enables Log::Log4perl log() to Screen and File
# Returns    : nothing
# Parameters : doesn't need parameters (logfile is in same directory and same name as script -pl +log
# Throws     : croaks if it receives parameters
# Comments   : used to setup a logging framework
# See Also   : Log::Log4perl at https://metacpan.org/pod/Log::Log4perl
sub init_logging {
    croak 'init_logging() needs VERBOSE parameter' unless @_ == 1;
    my ($VERBOSE) = @_;

    #create log file in same dir where script is running
	#removes perl script and takes absolute path from rest of path
	my ($volume,$dir_out,$perl_script) = splitpath( $0 );
	#say '$dir_out:', $dir_out;
	$dir_out = rel2abs($dir_out);
	#say '$dir_out:', $dir_out;

    my ($app_name) = $perl_script =~ m{\A(.+)\.(?:.+)\z};   #takes name of the script and removes .pl or .pm or .t
    #say '$app_name:', $app_name;
    my $logfile = catfile( $volume, $dir_out, $app_name . '.log' );    #combines all of above with .log
	#say '$logfile:', $logfile;
	$logfile = canonpath($logfile);
	#say '$logfile:', $logfile;

    #colored output on windows
    my $osname = $^O;
    if ( $osname eq 'MSWin32' ) {
        require Win32::Console::ANSI;                                 #require needs import
        Win32::Console::ANSI->import();
    }

    #enable different levels based on VERBOSE flag
    my $log_level;
    if    ($VERBOSE == 0)  { $log_level = 'INFO';  }
    elsif ($VERBOSE == 1)  { $log_level = 'DEBUG'; }
    elsif ($VERBOSE == 2)  { $log_level = 'TRACE'; }
    elsif ($VERBOSE == -1) { $log_level = 'OFF';   }
	else                   { $log_level = 'INFO';  }

    #levels:
    #TRACE, DEBUG, INFO, WARN, ERROR, FATAL
    ###############################################################################
    #                              Log::Log4perl Conf                             #
    ###############################################################################
    # Configuration in a string ...
    my $conf = qq(
      log4perl.category.main              = $log_level, Logfile, Screen
     
      log4perl.appender.Logfile           = Log::Log4perl::Appender::File
      log4perl.appender.Logfile.Threshold = TRACE
      log4perl.appender.Logfile.filename  = $logfile
      log4perl.appender.Logfile.mode      = append
      log4perl.appender.Logfile.autoflush = 1
      log4perl.appender.Logfile.umask     = 0022
      log4perl.appender.Logfile.header_text = INVOCATION:$0 @ARGV
      log4perl.appender.Logfile.layout    = Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Logfile.layout.ConversionPattern = [%d{yyyy/MM/dd HH:mm:ss,SSS}]%m%n
     
      log4perl.appender.Screen            = Log::Log4perl::Appender::ScreenColoredLevels
      log4perl.appender.Screen.stderr     = 1
      log4perl.appender.Screen.layout     = Log::Log4perl::Layout::PatternLayout
      log4perl.appender.Screen.layout.ConversionPattern  = [%d{yyyy/MM/dd HH:mm:ss,SSS}]%m%n
    );

    # ... passed as a reference to init()
    Log::Log4perl::init( \$conf );

    return;
}


sub init_logging2 {
    croak 'init_logging() needs VERBOSE parameter' unless @_ == 1;
    my ($VERBOSE) = @_;

    #create log file in same dir where script is running
	#removes perl script and takes absolute path from rest of path
	my ($volume,$dir_out,$perl_script) = splitpath( $0 );
	#say '$dir_out:', $dir_out;
	$dir_out = rel2abs($dir_out);
	#say '$dir_out:', $dir_out;

    my ($app_name) = $perl_script =~ m{\A(.+)\.(?:.+)\z};   #takes name of the script and removes .pl or .pm or .t
    #say '$app_name:', $app_name;
    my $logfile = catfile( $volume, $dir_out, $app_name . '.log' );    #combines all of above with .log
	#say '$logfile:', $logfile;
	$logfile = canonpath($logfile);
	#say '$logfile:', $logfile;

    #colored output on windows
    my $osname = $^O;
    if ( $osname eq 'MSWin32' ) {
        require Win32::Console::ANSI;                                 #require needs import
        Win32::Console::ANSI->import();
    }

    #enable different levels based on VERBOSE flag
    my $log_level;
    if    ($VERBOSE == 0)  { $log_level = 'INFO';  }
    elsif ($VERBOSE == 1)  { $log_level = 'DEBUG'; }
    elsif ($VERBOSE == 2)  { $log_level = 'TRACE'; }
    elsif ($VERBOSE == -1) { $log_level = 'OFF';   }
	else                   { $log_level = 'INFO';  }

    #levels:
    #ALL, TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF
    ###############################################################################
    #                              Log::Log4perl Conf                             #
    ###############################################################################
    # Configuration is dynamic
	# Define a category logger
	my $log = Log::Log4perl->get_logger("main");
 
    # Define a layout
	my $layout = Log::Log4perl::Layout::PatternLayout->new("[%d{yyyy/MM/dd HH:mm:ss,SSS}]%m%n");
 
   # Define a file appender
	my $file_appender = Log::Log4perl::Appender->new(
                        "Log::Log4perl::Appender::File",
                        name      => "Logfile",
                        filename  => "$logfile",
						autoflush => 1,
						umask => 022,
						header_text => "INVOCATION:$0 @ARGV", 
						#Threshold => "TRACE",
					);
 
   # Define a stderr appender
	my $stderr_appender =  Log::Log4perl::Appender->new(
                        "Log::Log4perl::Appender::ScreenColoredLevels",
                        name      => "Screen",
                        stderr    => 1,
					);
 
   # Have both appenders use the same layout (could be different)
	$stderr_appender->layout($layout);
	$file_appender->layout($layout);

 
	$log->add_appender($stderr_appender);
	$log->add_appender($file_appender);
	$log->level($log_level);
	$file_appender->threshold( "TRACE" );
	#Log::Log4perl->appender_thresholds_adjust(-1, ['Logfile']);
	#print Dumper( Log::Log4perl->appenders() );


    return;
}

### INTERNAL UTILITY ###
# Usage      : my ($stdout, $stderr, $exit) = capture_output( $cmd, $param_href );
# Purpose    : accepts command, executes it, captures output and returns it in vars
# Returns    : STDOUT, STDERR and EXIT as vars
# Parameters : ($cmd_to_execute)
# Throws     : 
# Comments   : second param is verbose flag (default off)
# See Also   :
sub capture_output {
    my $log = Log::Log4perl::get_logger("main");
    $log->logdie( 'capture_output() needs a $cmd' ) unless (@_ ==  2 or 1);
    my ($cmd, $param_href) = @_;

    my $VERBOSE = defined $param_href->{VERBOSE}  ? $param_href->{VERBOSE}  : undef;   #default is silent
    $log->info(qq|Report: COMMAND is: $cmd|);

    my ( $stdout, $stderr, $exit ) = capture {
        system($cmd );
    };

    if ($VERBOSE == 2) {
        $log->trace( 'STDOUT is: ', "$stdout", "\n", 'STDERR  is: ', "$stderr", "\n", 'EXIT   is: ', "$exit" );
    }

    return  $stdout, $stderr, $exit;
}


### INTERFACE SUB ###
# Usage      : install_perl( $param_href );
# Purpose    : install latest perl if not installed
# Returns    : nothing
# Parameters : ( $param_href ) params from command line
# Throws     : croaks if wrong number of parameters
# Comments   : first sub in chain, run only once at start
# See Also   :
sub install_perl {
    my $log = Log::Log4perl::get_logger("main");
    $log->logcroak ('install_perl() needs a $param_href' ) unless @_ == 1;
    my ( $param_href ) = @_;

    #check perl version
    my $cmd_perl_version = 'perl -v';
    my ($stdout, $stderr, $exit) = capture_output( $cmd_perl_version, $param_href );
    if ($exit == 0) {
        $log->info( 'Checking Perl version with perl -v' );
        if ( $stdout =~ m{v(\d+\.(\d+)\.\d+)}g ) {
            my $perl_ver = $1;
            my $ver_num = $2;
            $log->warn( "We have Perl $perl_ver and we need to update" );

            #start perlenv install
            $log->info( 'Checking if we can install plenv' );
            my $cmd_plenv = 'git clone git://github.com/tokuhirom/plenv.git ~/.plenv';
            my ($stdout_env, $stderr_env, $exit_env) = capture_output( $cmd_plenv, $param_href );
            my ($git_missing) = $stderr_env =~ m{(git)};
            my ($plenv_exist) = $stderr_env =~ m{(plenv)};

            if ($exit_env != 0 ) {
                if ( $git_missing ) {
                    $log->warn( 'Need to install git' );
                    my $cmd_git = 'sudo yum -y install git';
                    my ($stdout_git, $stderr_git, $exit_git) = capture_output( $cmd_git, $param_href );
                    if ($exit_git == 0 ) {
                        $log->trace( 'git successfully installed' );
                    }
                    my $cmd_tools = q{sudo yum -y groupinstall "Development tools"};
                    system $cmd_tools;
                }
                elsif ( $plenv_exist ) {
                    $log->trace( "plenv already installed: $stderr_env" );
                }
            }
            else {
                $log->trace( 'Installed plenv' );
                
                #updating .bash_profile for plenv to work
                my $cmd_path = q{echo 'export PATH="$HOME/.plenv/bin:$PATH"' >> ~/.bash_profile};
                my $cmd_eval = q{echo 'eval "$(plenv init -)"' >> ~/.bash_profile};
                my $cmd_exec = q{source $HOME/.bash_profile};
                system ($cmd_path);
                system ($cmd_eval);
                system ($cmd_exec);
                $log->trace( 'Updated $PATH variable and initiliazed plenv' );
                
                #installing Perl-Build plugin for install function in plenv
                my $cmd_perl_build = q{git clone git://github.com/tokuhirom/Perl-Build.git ~/.plenv/plugins/perl-build/};
                my ($stdout_bp, $stderr_bp, $exit_bp) = capture_output( $cmd_perl_build, $param_href );
                if ($exit_bp == 0) {
                    $log->trace( 'Installed Perl-Build plugin for plenv from github' );
                }

                #list all perls available
                my $cmd_list_perls = q{plenv install --list};
                my ($stdout_list, $stderr_list, $exit_list) = capture_output( $cmd_list_perls, $param_href );
                my @perls = split("\n", $stdout_list);
                #say @perls;
                
                #ask to choose which Perl to install
                my $perl_to_install
                  = prompt 'Choose which Perl version you want to install',
                  -number,
                  -menu => [ @perls ],
                  '>';
                my @thread_options = qw/usethreads nothreads/;
                my $thread_option
                  = prompt 'Do you want to install Perl with or without threads?',
                  -menu => [ @thread_options ],
                  '>';
                $log->trace( "Will install $perl_to_install with $thread_option" );

                #install Perl
                my $cmd_install;
                if ($thread_option eq 'nothreads') {
                    $cmd_install = qq{plenv install -j 8 -Dcc=gcc $perl_to_install};
                }
                else {
                    $cmd_install = qq{plenv install -j 8 -Dcc=gcc -D usethreads $perl_to_install};
                }
                my ($stdout_ins, $stderr_ins, $exit_ins) = capture_output( $cmd_install, $param_href );
                if ($exit_ins == 0) {
                    $log->trace( "Perl $perl_to_install installed successfully!" );
                }

                #finish installation, set perl as global
                my $cmd_rehash = q{plenv rehash};
                my $cmd_global = qq{plenv global $perl_to_install};
                my $cmd_cpanm = q{plenv install-cpanm};
                #my $cmd_lib   = q{sudo cpanm --local-lib=~/perl5 local::lib && eval $(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)};
                system ($cmd_rehash);
                system ($cmd_global);
                my ($stdout_cp, $stderr_cp, $exit_cp) = capture_output( $cmd_cpanm, $param_href );
                if ($exit_cp == 0) {
                    $log->trace( "Perl $perl_to_install is now global and cpanm installed" );
                }

                #check if right Perl installed
                my ($stdout_ver, $stderr_ver, $exit_ver) = capture_output( $cmd_perl_version, $param_href );
                if ($exit_ver == 0) {
                    $log->info( 'Checking Perl version with perl -v' );
                    if ( $stdout_ver =~ m{v(\d+\.(\d+)\.\d+)}g ) {
                        my $perl_ver2 = $1;
                        $log->warn( "We have Perl $perl_ver2 " );
                    }
                }
                }
        }
    }
    else {
        $log->logcarp( 'Got lost checking Perl version' );
    }

    return;
}


1;
__END__

=encoding utf-8

=head1 NAME

MySQLinstall - is installation script that installs Perl using plenv, MySQL::Sandbox using cpanm, MySQL in a sandbox, additional engines like TokuDB and Deep and updates configuration.

=head1 SYNOPSIS

 MySQLinstall --mode=install_perl

 MySQLinstall --mode=install_sandbox --sandbox=/msestak/sandboxes/ --opt=/msestak/opt/mysql/

 MySQLinstall --mode=wget_mysql -url http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-5.5.43-linux2.6-x86_64.tar.gz

 MySQLinstall --mode=wget_percona -url https://www.percona.com/downloads/Percona-Server-5.6/Percona-Server-5.6.24-72.2/binary/tarball/Percona-Server-5.6.24-rel72.2-Linux.x86_64.ssl101.tar.gz -url_tokudb https://www.percona.com/downloads/Percona-Server-5.6/Percona-Server-5.6.24-72.2/binary/tarball/Percona-Server-5.6.24-rel72.2-TokuDB.Linux.x86_64.ssl101.tar.gz

 MySQLinstall --mode=install_mysql -i ./download/mysql-5.6.26-linux-glibc2.5-x86_64.tar.gz
 MySQLinstall --mode=install_mysql --in=./download/Percona-Server-5.6.25-rel73.1-Linux.x86_64.ssl101.tar.gz

 MySQLinstall --mode=edit_tokudb --opt=/home/msestak/opt/mysql/5.6.25/ --sand=/home/msestak/sandboxes/msb_5_6_25/

 MySQLinstall --mode=edit_deep -i deep-mysql-5.6.25-community-plugin-3.2.0.19654-1.el6.x86_64.rpm --sand=/msestak/sandboxes/msb_5_6_25/ --opt=/msestak/opt/mysql/5.6.25/
 or with reporting
 MySQLinstall --mode=edit_deep_report -i ./download/deep-mysql-5.6.26-community-plugin-3.2.0.19896.el6.x86_64.tar.gz --sand=/home/msestak/sandboxes/msb_5_6_26 --opt=/home/msestak/opt/mysql/5.6.26



=head1 DESCRIPTION

 MySQLinstall is installation script that installs Perl using plenv, MySQL::Sandbox using cpanm, MySQL in a sandbox, additional engines like TokuDB and Deep and updates configuration. 

 --mode=mode				Description
 --mode=install_perl		installs latest Perl with perlenv and cpanm
 --mode=install_sandbox		installs MySQL::Sandbox and prompts for modification of .bashrc
 --mode=wget_mysql			downloads MySQL from Oracle
 --mode=wget_percona		downloads Percona Server with TokuDB
 --mode=install_mysql		installs MySQL and modifies my.cnf for performance
 --mode=edit_deep_report	installs TokuDB plugin
 --mode=edit_tokudb			installs Deep plugin
 
 For help write:
 MySQLinstall -h
 MySQLinstall -m


=head1 LICENSE

Copyright (C) Martin Sebastijan Šestak.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 AUTHOR

mocnii E<lt>msestak@irb.hrE<gt>

=head1 EXAMPLE
 MySQLinstall --mode=install_mysql --in=./download/Percona-Server-5.6.25-rel73.1-Linux.x86_64.ssl101.tar.gz
 MySQLinstall --mode=edit_tokudb --opt=/home/msestak/opt/mysql/5.6.25/ --sand=/home/msestak/sandboxes/msb_5_6_25/
 
 MySQLinstall --mode=install_mysql -i mysql-5.6.24-linux-glibc2.5-x86_64.tar.gz
 MySQLinstall --mode=edit_deep -i deep-mysql-5.6.24-community-plugin-3.2.0.19297-1.el6.x86_64.rpm --sand=/msestak/sandboxes/msb_5_6_24/ --opt=/msestak/opt/mysql/5.6.24/

 MySQLinstall --mode=install_mysql -i mysql-5.6.24-linux-glibc2.5-x86_64.tar.gz
 MySQLinstall --mode=edit_deep_report -i deep-mysql-5.6.24-community-plugin-3.2.0.19654.el6.x86_64.tar.gz --sand=/msestak/sandboxes/msb_5_6_24/ --opt=/msestak/opt/mysql/5.6.24/

 MySQLinstall --mode=install_mysql -i ./download/mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz
 MySQLinstall --mode=edit_deep_report -i ./download/deep-mysql-5.6.27-community-plugin-3.3.0.20340.el6.x86_64.tar.gz --sand=/home/msestak/sandboxes/msb_5_6_27/ --opt=/home/msestak/opt/mysql/5.6.27/

=cut

